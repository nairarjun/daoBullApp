{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nimport * as utils from './utils.js';\nimport baseLogger from './logger.js';\n\nvar Interpolator = function () {\n  function Interpolator() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Interpolator);\n\n    this.logger = baseLogger.create('interpolator');\n    this.init(options, true);\n  }\n  /* eslint no-param-reassign: 0 */\n\n\n  Interpolator.prototype.init = function init() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var reset = arguments[1];\n\n    if (reset) {\n      this.options = options;\n\n      this.format = options.interpolation && options.interpolation.format || function (value) {\n        return value;\n      };\n    }\n\n    if (!options.interpolation) options.interpolation = {\n      escapeValue: true\n    };\n    var iOpts = options.interpolation;\n    this.escape = iOpts.escape !== undefined ? iOpts.escape : utils.escape;\n    this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;\n    this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;\n    this.prefix = iOpts.prefix ? utils.regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';\n    this.suffix = iOpts.suffix ? utils.regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';\n    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';\n    this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';\n    this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';\n    this.nestingPrefix = iOpts.nestingPrefix ? utils.regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || utils.regexEscape('$t(');\n    this.nestingSuffix = iOpts.nestingSuffix ? utils.regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || utils.regexEscape(')');\n    this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000; // the regexp\n\n    this.resetRegExp();\n  };\n\n  Interpolator.prototype.reset = function reset() {\n    if (this.options) this.init(this.options);\n  };\n\n  Interpolator.prototype.resetRegExp = function resetRegExp() {\n    // the regexp\n    var regexpStr = this.prefix + '(.+?)' + this.suffix;\n    this.regexp = new RegExp(regexpStr, 'g');\n    var regexpUnescapeStr = '' + this.prefix + this.unescapePrefix + '(.+?)' + this.unescapeSuffix + this.suffix;\n    this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');\n    var nestingRegexpStr = this.nestingPrefix + '(.+?)' + this.nestingSuffix;\n    this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');\n  };\n\n  Interpolator.prototype.interpolate = function interpolate(str, data, lng, options) {\n    var _this = this;\n\n    var match = void 0;\n    var value = void 0;\n    var replaces = void 0;\n\n    function regexSafe(val) {\n      return val.replace(/\\$/g, '$$$$');\n    }\n\n    var handleFormat = function handleFormat(key) {\n      if (key.indexOf(_this.formatSeparator) < 0) return utils.getPath(data, key);\n      var p = key.split(_this.formatSeparator);\n      var k = p.shift().trim();\n      var f = p.join(_this.formatSeparator).trim();\n      return _this.format(utils.getPath(data, k), f, lng);\n    };\n\n    this.resetRegExp();\n    var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;\n    replaces = 0; // unescape if has unescapePrefix/Suffix\n\n    /* eslint no-cond-assign: 0 */\n\n    while (match = this.regexpUnescape.exec(str)) {\n      value = handleFormat(match[1].trim());\n      str = str.replace(match[0], value);\n      this.regexpUnescape.lastIndex = 0;\n      replaces++;\n\n      if (replaces >= this.maxReplaces) {\n        break;\n      }\n    }\n\n    replaces = 0; // regular escape on demand\n\n    while (match = this.regexp.exec(str)) {\n      value = handleFormat(match[1].trim());\n\n      if (value === undefined) {\n        if (typeof missingInterpolationHandler === 'function') {\n          var temp = missingInterpolationHandler(str, match, options);\n          value = typeof temp === 'string' ? temp : '';\n        } else {\n          this.logger.warn('missed to pass in variable ' + match[1] + ' for interpolating ' + str);\n          value = '';\n        }\n      } else if (typeof value !== 'string' && !this.useRawValueToEscape) {\n        value = utils.makeString(value);\n      }\n\n      value = this.escapeValue ? regexSafe(this.escape(value)) : regexSafe(value);\n      str = str.replace(match[0], value);\n      this.regexp.lastIndex = 0;\n      replaces++;\n\n      if (replaces >= this.maxReplaces) {\n        break;\n      }\n    }\n\n    return str;\n  };\n\n  Interpolator.prototype.nest = function nest(str, fc) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var match = void 0;\n    var value = void 0;\n\n    var clonedOptions = _extends({}, options);\n\n    clonedOptions.applyPostProcessor = false; // avoid post processing on nested lookup\n    // if value is something like \"myKey\": \"lorem $(anotherKey, { \"count\": {{aValueInOptions}} })\"\n\n    function handleHasOptions(key, inheritedOptions) {\n      if (key.indexOf(',') < 0) return key;\n      var p = key.split(',');\n      key = p.shift();\n      var optionsString = p.join(',');\n      optionsString = this.interpolate(optionsString, clonedOptions);\n      optionsString = optionsString.replace(/'/g, '\"');\n\n      try {\n        clonedOptions = JSON.parse(optionsString);\n        if (inheritedOptions) clonedOptions = _extends({}, inheritedOptions, clonedOptions);\n      } catch (e) {\n        this.logger.error('failed parsing options string in nesting for key ' + key, e);\n      }\n\n      return key;\n    } // regular escape on demand\n\n\n    while (match = this.nestingRegexp.exec(str)) {\n      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions); // is only the nesting key (key1 = '$(key2)') return the value without stringify\n\n      if (value && match[0] === str && typeof value !== 'string') return value; // no string to include or empty\n\n      if (typeof value !== 'string') value = utils.makeString(value);\n\n      if (!value) {\n        this.logger.warn('missed to resolve ' + match[1] + ' for nesting ' + str);\n        value = '';\n      } // Nested keys should not be escaped by default #854\n      // value = this.escapeValue ? regexSafe(utils.escape(value)) : regexSafe(value);\n\n\n      str = str.replace(match[0], value);\n      this.regexp.lastIndex = 0;\n    }\n\n    return str;\n  };\n\n  return Interpolator;\n}();\n\nexport default Interpolator;","map":{"version":3,"sources":["/home/turbo/devel/MyGame/contracts/eos-hackathon/decentralize-io-ui/node_modules/i18next/dist/es/Interpolator.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_classCallCheck","instance","Constructor","TypeError","utils","baseLogger","Interpolator","options","undefined","logger","create","init","reset","format","interpolation","value","escapeValue","iOpts","escape","useRawValueToEscape","prefix","regexEscape","prefixEscaped","suffix","suffixEscaped","formatSeparator","unescapePrefix","unescapeSuffix","nestingPrefix","nestingPrefixEscaped","nestingSuffix","nestingSuffixEscaped","maxReplaces","resetRegExp","regexpStr","regexp","RegExp","regexpUnescapeStr","regexpUnescape","nestingRegexpStr","nestingRegexp","interpolate","str","data","lng","_this","match","replaces","regexSafe","val","replace","handleFormat","indexOf","getPath","p","split","k","shift","trim","f","join","missingInterpolationHandler","exec","lastIndex","temp","warn","makeString","nest","fc","clonedOptions","applyPostProcessor","handleHasOptions","inheritedOptions","optionsString","JSON","parse","e","error"],"mappings":"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","sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nimport * as utils from './utils.js';\nimport baseLogger from './logger.js';\n\nvar Interpolator = function () {\n  function Interpolator() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Interpolator);\n\n    this.logger = baseLogger.create('interpolator');\n\n    this.init(options, true);\n  }\n\n  /* eslint no-param-reassign: 0 */\n\n\n  Interpolator.prototype.init = function init() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var reset = arguments[1];\n\n    if (reset) {\n      this.options = options;\n      this.format = options.interpolation && options.interpolation.format || function (value) {\n        return value;\n      };\n    }\n    if (!options.interpolation) options.interpolation = { escapeValue: true };\n\n    var iOpts = options.interpolation;\n\n    this.escape = iOpts.escape !== undefined ? iOpts.escape : utils.escape;\n    this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;\n    this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;\n\n    this.prefix = iOpts.prefix ? utils.regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';\n    this.suffix = iOpts.suffix ? utils.regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';\n\n    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';\n\n    this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';\n    this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';\n\n    this.nestingPrefix = iOpts.nestingPrefix ? utils.regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || utils.regexEscape('$t(');\n    this.nestingSuffix = iOpts.nestingSuffix ? utils.regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || utils.regexEscape(')');\n\n    this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;\n\n    // the regexp\n    this.resetRegExp();\n  };\n\n  Interpolator.prototype.reset = function reset() {\n    if (this.options) this.init(this.options);\n  };\n\n  Interpolator.prototype.resetRegExp = function resetRegExp() {\n    // the regexp\n    var regexpStr = this.prefix + '(.+?)' + this.suffix;\n    this.regexp = new RegExp(regexpStr, 'g');\n\n    var regexpUnescapeStr = '' + this.prefix + this.unescapePrefix + '(.+?)' + this.unescapeSuffix + this.suffix;\n    this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');\n\n    var nestingRegexpStr = this.nestingPrefix + '(.+?)' + this.nestingSuffix;\n    this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');\n  };\n\n  Interpolator.prototype.interpolate = function interpolate(str, data, lng, options) {\n    var _this = this;\n\n    var match = void 0;\n    var value = void 0;\n    var replaces = void 0;\n\n    function regexSafe(val) {\n      return val.replace(/\\$/g, '$$$$');\n    }\n\n    var handleFormat = function handleFormat(key) {\n      if (key.indexOf(_this.formatSeparator) < 0) return utils.getPath(data, key);\n\n      var p = key.split(_this.formatSeparator);\n      var k = p.shift().trim();\n      var f = p.join(_this.formatSeparator).trim();\n\n      return _this.format(utils.getPath(data, k), f, lng);\n    };\n\n    this.resetRegExp();\n\n    var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;\n\n    replaces = 0;\n    // unescape if has unescapePrefix/Suffix\n    /* eslint no-cond-assign: 0 */\n    while (match = this.regexpUnescape.exec(str)) {\n      value = handleFormat(match[1].trim());\n      str = str.replace(match[0], value);\n      this.regexpUnescape.lastIndex = 0;\n      replaces++;\n      if (replaces >= this.maxReplaces) {\n        break;\n      }\n    }\n\n    replaces = 0;\n    // regular escape on demand\n    while (match = this.regexp.exec(str)) {\n      value = handleFormat(match[1].trim());\n      if (value === undefined) {\n        if (typeof missingInterpolationHandler === 'function') {\n          var temp = missingInterpolationHandler(str, match, options);\n          value = typeof temp === 'string' ? temp : '';\n        } else {\n          this.logger.warn('missed to pass in variable ' + match[1] + ' for interpolating ' + str);\n          value = '';\n        }\n      } else if (typeof value !== 'string' && !this.useRawValueToEscape) {\n        value = utils.makeString(value);\n      }\n      value = this.escapeValue ? regexSafe(this.escape(value)) : regexSafe(value);\n      str = str.replace(match[0], value);\n      this.regexp.lastIndex = 0;\n      replaces++;\n      if (replaces >= this.maxReplaces) {\n        break;\n      }\n    }\n    return str;\n  };\n\n  Interpolator.prototype.nest = function nest(str, fc) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var match = void 0;\n    var value = void 0;\n\n    var clonedOptions = _extends({}, options);\n    clonedOptions.applyPostProcessor = false; // avoid post processing on nested lookup\n\n    // if value is something like \"myKey\": \"lorem $(anotherKey, { \"count\": {{aValueInOptions}} })\"\n    function handleHasOptions(key, inheritedOptions) {\n      if (key.indexOf(',') < 0) return key;\n\n      var p = key.split(',');\n      key = p.shift();\n      var optionsString = p.join(',');\n      optionsString = this.interpolate(optionsString, clonedOptions);\n      optionsString = optionsString.replace(/'/g, '\"');\n\n      try {\n        clonedOptions = JSON.parse(optionsString);\n\n        if (inheritedOptions) clonedOptions = _extends({}, inheritedOptions, clonedOptions);\n      } catch (e) {\n        this.logger.error('failed parsing options string in nesting for key ' + key, e);\n      }\n\n      return key;\n    }\n\n    // regular escape on demand\n    while (match = this.nestingRegexp.exec(str)) {\n      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);\n\n      // is only the nesting key (key1 = '$(key2)') return the value without stringify\n      if (value && match[0] === str && typeof value !== 'string') return value;\n\n      // no string to include or empty\n      if (typeof value !== 'string') value = utils.makeString(value);\n      if (!value) {\n        this.logger.warn('missed to resolve ' + match[1] + ' for nesting ' + str);\n        value = '';\n      }\n      // Nested keys should not be escaped by default #854\n      // value = this.escapeValue ? regexSafe(utils.escape(value)) : regexSafe(value);\n      str = str.replace(match[0], value);\n      this.regexp.lastIndex = 0;\n    }\n    return str;\n  };\n\n  return Interpolator;\n}();\n\nexport default Interpolator;"]},"metadata":{},"sourceType":"module"}