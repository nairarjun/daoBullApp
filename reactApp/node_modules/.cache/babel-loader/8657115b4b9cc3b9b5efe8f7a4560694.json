{"ast":null,"code":"/**\n * EOSIO Signing Request v2.2.0\n * https://github.com/greymass/eosio-signing-request\n *\n * @license\n * Copyright © 2021 Greymass Inc.\n * \n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the “Software”), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n * \n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n * \n * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR\n * INTENDED FOR USE IN THE DESIGN, CONSTRUCTION, OPERATION OR\n * MAINTENANCE OF ANY MILITARY FACILITY.\n */\nimport { Checksum256, TypeAlias, UInt8, Variant, Name, Struct, PermissionLevel, Action, Transaction, isInstanceOf, Serializer, TimePointSec, Authority, Signature, Bytes, ABIEncoder, ABIDecoder, ABI, UInt16, UInt32 } from '@greymass/eosio';\nimport { __decorate } from 'tslib';\n/**\n * Base64u - URL-Safe Base64 variant no padding.\n * Based on https://gist.github.com/jonleighton/958841\n */\n\nconst baseCharset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nconst lookup = new Uint8Array(256);\n\nfor (let i = 0; i < 62; i++) {\n  lookup[baseCharset.charCodeAt(i)] = i;\n} // support both urlsafe and standard base64\n\n\nlookup[43] = lookup[45] = 62;\nlookup[47] = lookup[95] = 63;\n\nfunction encode(data, urlSafe = true) {\n  const byteLength = data.byteLength;\n  const byteRemainder = byteLength % 3;\n  const mainLength = byteLength - byteRemainder;\n  const charset = baseCharset + (urlSafe ? '-_' : '+/');\n  const parts = [];\n  let a;\n  let b;\n  let c;\n  let d;\n  let chunk; // Main loop deals with bytes in chunks of 3\n\n  for (let i = 0; i < mainLength; i += 3) {\n    // Combine the three bytes into a single integer\n    chunk = data[i] << 16 | data[i + 1] << 8 | data[i + 2]; // Use bitmasks to extract 6-bit segments from the triplet\n\n    a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\n\n    b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\n\n    c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\n\n    d = chunk & 63; // 63       =  2^6 - 1\n    // Convert the raw binary segments to the appropriate ASCII encoding\n\n    parts.push(charset[a] + charset[b] + charset[c] + charset[d]);\n  } // Deal with the remaining bytes\n\n\n  if (byteRemainder === 1) {\n    chunk = data[mainLength];\n    a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\n    // Set the 4 least significant bits to zero\n\n    b = (chunk & 3) << 4; // 3   = 2^2 - 1\n\n    parts.push(charset[a] + charset[b]);\n  } else if (byteRemainder === 2) {\n    chunk = data[mainLength] << 8 | data[mainLength + 1];\n    a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\n\n    b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\n    // Set the 2 least significant bits to zero\n\n    c = (chunk & 15) << 2; // 15    = 2^4 - 1\n\n    parts.push(charset[a] + charset[b] + charset[c]);\n  }\n\n  return parts.join('');\n}\n\nfunction decode(input) {\n  const byteLength = input.length * 0.75;\n  const data = new Uint8Array(byteLength);\n  let a;\n  let b;\n  let c;\n  let d;\n  let p = 0;\n\n  for (let i = 0; i < input.length; i += 4) {\n    a = lookup[input.charCodeAt(i)];\n    b = lookup[input.charCodeAt(i + 1)];\n    c = lookup[input.charCodeAt(i + 2)];\n    d = lookup[input.charCodeAt(i + 3)];\n    data[p++] = a << 2 | b >> 4;\n    data[p++] = (b & 15) << 4 | c >> 2;\n    data[p++] = (c & 3) << 6 | d & 63;\n  }\n\n  return data;\n}\n\nvar base64u = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  encode: encode,\n  decode: decode\n});\n/** Chain ID aliases. */\n\nvar ChainName;\n\n(function (ChainName) {\n  ChainName[ChainName[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  ChainName[ChainName[\"EOS\"] = 1] = \"EOS\";\n  ChainName[ChainName[\"TELOS\"] = 2] = \"TELOS\";\n  ChainName[ChainName[\"JUNGLE\"] = 3] = \"JUNGLE\";\n  ChainName[ChainName[\"KYLIN\"] = 4] = \"KYLIN\";\n  ChainName[ChainName[\"WORBLI\"] = 5] = \"WORBLI\";\n  ChainName[ChainName[\"BOS\"] = 6] = \"BOS\";\n  ChainName[ChainName[\"MEETONE\"] = 7] = \"MEETONE\";\n  ChainName[ChainName[\"INSIGHTS\"] = 8] = \"INSIGHTS\";\n  ChainName[ChainName[\"BEOS\"] = 9] = \"BEOS\";\n  ChainName[ChainName[\"WAX\"] = 10] = \"WAX\";\n  ChainName[ChainName[\"PROTON\"] = 11] = \"PROTON\";\n  ChainName[ChainName[\"FIO\"] = 12] = \"FIO\";\n})(ChainName || (ChainName = {}));\n\nlet ChainId = class ChainId extends Checksum256 {\n  static from(value) {\n    if (value instanceof this) {\n      return value;\n    }\n\n    if (typeof value === 'number') {\n      value = ChainIdLookup.get(value);\n\n      if (!value) {\n        throw new Error('Unknown chain id alias');\n      }\n    }\n\n    return super.from(value);\n  }\n\n  get chainVariant() {\n    const name = this.chainName;\n\n    if (name !== ChainName.UNKNOWN) {\n      return ChainIdVariant.from(['chain_alias', name]);\n    }\n\n    return ChainIdVariant.from(this);\n  }\n\n  get chainName() {\n    const cid = this.hexString;\n\n    for (const [n, id] of ChainIdLookup) {\n      if (id === cid) {\n        return n;\n      }\n    }\n\n    return ChainName.UNKNOWN;\n  }\n\n};\nChainId = __decorate([TypeAlias('chain_id')], ChainId);\nlet ChainAlias = class ChainAlias extends UInt8 {};\nChainAlias = __decorate([TypeAlias('chain_alias')], ChainAlias);\nlet ChainIdVariant = class ChainIdVariant extends Variant {\n  get chainId() {\n    if (this.value instanceof ChainId) {\n      return this.value;\n    }\n\n    return ChainId.from(this.value.value);\n  }\n\n};\nChainIdVariant = __decorate([Variant.type('variant_id', [ChainAlias, ChainId])], ChainIdVariant);\nconst ChainIdLookup = new Map([[ChainName.EOS, 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906'], [ChainName.TELOS, '4667b205c6838ef70ff7988f6e8257e8be0e1284a2f59699054a018f743b1d11'], [ChainName.JUNGLE, 'e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473'], [ChainName.KYLIN, '5fff1dae8dc8e2fc4d5b23b2c7665c97f9e9d8edf2b6485a86ba311c25639191'], [ChainName.WORBLI, '73647cde120091e0a4b85bced2f3cfdb3041e266cbbe95cee59b73235a1b3b6f'], [ChainName.BOS, 'd5a3d18fbb3c084e3b1f3fa98c21014b5f3db536cc15d08f9f6479517c6a3d86'], [ChainName.MEETONE, 'cfe6486a83bad4962f232d48003b1824ab5665c36778141034d75e57b956e422'], [ChainName.INSIGHTS, 'b042025541e25a472bffde2d62edd457b7e70cee943412b1ea0f044f88591664'], [ChainName.BEOS, 'b912d19a6abd2b1b05611ae5be473355d64d95aeff0c09bedc8c166cd6468fe4'], [ChainName.WAX, '1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4'], [ChainName.PROTON, '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0'], [ChainName.FIO, '21dcae42c0182200e93f954a074011f9048a7624c6fe81d3c9541a614a88bd1c']]);\n/** SigningRequest ABI and typedefs. */\n\nvar RequestFlags_1;\nlet AccountName = class AccountName extends Name {};\nAccountName = __decorate([TypeAlias('account_name')], AccountName);\nlet PermissionName = class PermissionName extends Name {};\nPermissionName = __decorate([TypeAlias('permission_name')], PermissionName);\nlet IdentityV2 = class IdentityV2 extends Struct {};\n\n__decorate([Struct.field(PermissionLevel, {\n  optional: true\n})], IdentityV2.prototype, \"permission\", void 0);\n\nIdentityV2 = __decorate([Struct.type('identity')], IdentityV2);\nlet IdentityV3 = class IdentityV3 extends Struct {};\n\n__decorate([Struct.field('name')], IdentityV3.prototype, \"scope\", void 0);\n\n__decorate([Struct.field(PermissionLevel, {\n  optional: true\n})], IdentityV3.prototype, \"permission\", void 0);\n\nIdentityV3 = __decorate([Struct.type('identity')], IdentityV3);\nlet RequestVariantV2 = class RequestVariantV2 extends Variant {};\nRequestVariantV2 = __decorate([Variant.type('variant_req', [Action, {\n  type: Action,\n  array: true\n}, Transaction, IdentityV2])], RequestVariantV2);\nlet RequestVariantV3 = class RequestVariantV3 extends Variant {};\nRequestVariantV3 = __decorate([Variant.type('variant_req', [Action, {\n  type: Action,\n  array: true\n}, Transaction, IdentityV3])], RequestVariantV3);\nlet RequestFlags = RequestFlags_1 = class RequestFlags extends UInt8 {\n  get broadcast() {\n    return (this.value & RequestFlags_1.broadcast) !== 0;\n  }\n\n  set broadcast(enabled) {\n    this.setFlag(RequestFlags_1.broadcast, enabled);\n  }\n\n  get background() {\n    return (this.value & RequestFlags_1.background) !== 0;\n  }\n\n  set background(enabled) {\n    this.setFlag(RequestFlags_1.background, enabled);\n  }\n\n  setFlag(flag, enabled) {\n    if (enabled) {\n      this.value |= flag;\n    } else {\n      this.value &= ~flag;\n    }\n  }\n\n};\nRequestFlags.broadcast = 1 << 0;\nRequestFlags.background = 1 << 1;\nRequestFlags = RequestFlags_1 = __decorate([TypeAlias('request_flags')], RequestFlags);\nlet InfoPair = class InfoPair extends Struct {};\n\n__decorate([Struct.field('string')], InfoPair.prototype, \"key\", void 0);\n\n__decorate([Struct.field('bytes')], InfoPair.prototype, \"value\", void 0);\n\nInfoPair = __decorate([Struct.type('info_pair')], InfoPair);\nlet RequestDataV2 = class RequestDataV2 extends Struct {};\n\n__decorate([Struct.field(ChainIdVariant)], RequestDataV2.prototype, \"chain_id\", void 0);\n\n__decorate([Struct.field(RequestVariantV2)], RequestDataV2.prototype, \"req\", void 0);\n\n__decorate([Struct.field(RequestFlags)], RequestDataV2.prototype, \"flags\", void 0);\n\n__decorate([Struct.field('string')], RequestDataV2.prototype, \"callback\", void 0);\n\n__decorate([Struct.field(InfoPair, {\n  array: true\n})], RequestDataV2.prototype, \"info\", void 0);\n\nRequestDataV2 = __decorate([Struct.type('signing_request')], RequestDataV2);\nlet RequestDataV3 = class RequestDataV3 extends Struct {};\n\n__decorate([Struct.field(ChainIdVariant)], RequestDataV3.prototype, \"chain_id\", void 0);\n\n__decorate([Struct.field(RequestVariantV3)], RequestDataV3.prototype, \"req\", void 0);\n\n__decorate([Struct.field(RequestFlags)], RequestDataV3.prototype, \"flags\", void 0);\n\n__decorate([Struct.field('string')], RequestDataV3.prototype, \"callback\", void 0);\n\n__decorate([Struct.field(InfoPair, {\n  array: true\n})], RequestDataV3.prototype, \"info\", void 0);\n\nRequestDataV3 = __decorate([Struct.type('signing_request')], RequestDataV3);\nlet RequestSignature = class RequestSignature extends Struct {};\n\n__decorate([Struct.field('name')], RequestSignature.prototype, \"signer\", void 0);\n\n__decorate([Struct.field('signature')], RequestSignature.prototype, \"signature\", void 0);\n\nRequestSignature = __decorate([Struct.type('request_signature')], RequestSignature);\nvar IdentityProof_1;\nlet IdentityProof = IdentityProof_1 = class IdentityProof extends Struct {\n  static from(value) {\n    if (isInstanceOf(value, IdentityProof_1)) {\n      return value;\n    } else if (typeof value === 'string') {\n      return IdentityProof_1.fromString(value);\n    } else {\n      return super.from(value);\n    }\n  }\n  /**\n   * Create a new instance from an EOSIO authorization header string.\n   * \"EOSIO <base64payload>\"\n   */\n\n\n  static fromString(string) {\n    const parts = string.split(' ');\n\n    if (parts.length !== 2 || parts[0] !== 'EOSIO') {\n      throw new Error('Invalid IdentityProof string');\n    }\n\n    const data = decode(parts[1]);\n    return Serializer.decode({\n      data,\n      type: IdentityProof_1\n    });\n  }\n  /** Create a new instance from a callback payload. */\n\n\n  static fromPayload(payload, options = {}) {\n    const request = SigningRequest.from(payload.req, options);\n\n    if (!(request.version >= 3 && request.isIdentity())) {\n      throw new Error('Not an identity request');\n    }\n\n    return this.from({\n      chainId: payload.cid || request.getChainId(),\n      scope: request.getIdentityScope(),\n      expiration: payload.ex,\n      signer: {\n        actor: payload.sa,\n        permission: payload.sp\n      },\n      signature: payload.sig\n    });\n  }\n  /**\n   * Transaction this proof resolves to.\n   * @internal\n   */\n\n\n  get transaction() {\n    const action = Action.from({\n      account: '',\n      name: 'identity',\n      authorization: [this.signer],\n      data: IdentityV3.from({\n        scope: this.scope,\n        permission: this.signer\n      })\n    });\n    return Transaction.from({\n      ref_block_num: 0,\n      ref_block_prefix: 0,\n      expiration: this.expiration,\n      actions: [action]\n    });\n  }\n  /**\n   * Recover the public key that signed this proof.\n   */\n\n\n  recover() {\n    return this.signature.recoverDigest(this.transaction.signingDigest(this.chainId));\n  }\n  /**\n   * Verify that given authority signed this proof.\n   * @param auth The accounts signing authority.\n   * @param currentTime Time to verify expiry against, if unset will use system time.\n   */\n\n\n  verify(auth, currentTime) {\n    const now = TimePointSec.from(currentTime || new Date()).toMilliseconds();\n    return now < this.expiration.toMilliseconds() && Authority.from(auth).hasPermission(this.recover());\n  }\n  /**\n   * Encode the proof to an `EOSIO` auth header string.\n   */\n\n\n  toString() {\n    const data = Serializer.encode({\n      object: this\n    });\n    return `EOSIO ${encode(data.array, false)}`;\n  }\n\n};\n\n__decorate([Struct.field(ChainId)], IdentityProof.prototype, \"chainId\", void 0);\n\n__decorate([Struct.field(Name)], IdentityProof.prototype, \"scope\", void 0);\n\n__decorate([Struct.field(TimePointSec)], IdentityProof.prototype, \"expiration\", void 0);\n\n__decorate([Struct.field(PermissionLevel)], IdentityProof.prototype, \"signer\", void 0);\n\n__decorate([Struct.field(Signature)], IdentityProof.prototype, \"signature\", void 0);\n\nIdentityProof = IdentityProof_1 = __decorate([Struct.type('identity_proof')], IdentityProof);\n/**\n * EOSIO Signing Request (ESR).\n */\n\n/** Current supported protocol version, backwards compatible with version 2. */\n\nconst ProtocolVersion = 3;\n/**\n * The placeholder name: `............1` aka `uint64(1)`.\n * If used in action data will be resolved to current signer.\n * If used in as an authorization permission will be resolved to\n * the signers permission level.\n *\n * Example action:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"............1\", permission: \"............1\"}],\n *   data: {\n *     from: \"............1\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n * When signed by `foo@active` would resolve to:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"foo\", permission: \"active\"}],\n *   data: {\n *     from: \"foo\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n */\n\nconst PlaceholderName = Name.from('............1'); // aka uint64(1)\n\n/** Placeholder that will resolve to signer permission name. */\n\nconst PlaceholderPermission = Name.from('............2'); // aka uint64(2)\n\nconst PlaceholderAuth = PermissionLevel.from({\n  actor: PlaceholderName,\n  permission: PlaceholderPermission\n});\n\nclass SigningRequest {\n  /**\n   * Create a new signing request.\n   * Normally not used directly, see the `create` and `from` class methods.\n   */\n  constructor(version, data, zlib, abiProvider, signature) {\n    if (data.flags.broadcast && data.req.variantName === 'identity') {\n      throw new Error('Invalid request (identity request cannot be broadcast)');\n    }\n\n    this.version = version;\n    this.data = data;\n    this.zlib = zlib;\n    this.abiProvider = abiProvider;\n    this.signature = signature;\n  }\n  /** Return the identity ABI for given version. */\n\n\n  static identityAbi(version) {\n    const abi = Serializer.synthesize(this.identityType(version));\n    abi.actions = [{\n      name: 'identity',\n      type: 'identity',\n      ricardian_contract: ''\n    }];\n    return abi;\n  }\n  /** Return the ABISerializableType identity type for given version. */\n\n\n  static identityType(version) {\n    return version === 2 ? IdentityV2 : IdentityV3;\n  }\n  /** Return the ABISerializableType storage type for given version. */\n\n\n  static storageType(version) {\n    return version === 2 ? RequestDataV2 : RequestDataV3;\n  }\n  /** Create a new signing request. */\n\n\n  static async create(args, options = {}) {\n    let actions;\n\n    if (args.action) {\n      actions = [args.action];\n    } else if (args.actions) {\n      actions = args.actions;\n    } else if (args.transaction) {\n      actions = args.transaction.actions || [];\n    } else {\n      actions = [];\n    }\n\n    const requiredAbis = actions.filter(action => !Bytes.isBytes(action.data) && action.data.constructor.abiName === undefined).map(action => Name.from(action.account));\n    const abis = {};\n\n    if (requiredAbis.length > 0) {\n      const provider = options.abiProvider;\n\n      if (!provider) {\n        throw new Error('Missing abi provider');\n      }\n\n      const accountAbis = await Promise.all(requiredAbis.map(account => provider.getAbi(account)));\n\n      for (const [idx, abi] of accountAbis.entries()) {\n        abis[requiredAbis[idx].toString()] = abi;\n      }\n    }\n\n    return this.createSync(args, options, abis);\n  }\n  /**\n   * Synchronously create a new signing request.\n   * @throws If an un-encoded action with no abi def is encountered.\n   */\n\n\n  static createSync(args, options = {}, abis = {}) {\n    let version = 2;\n    const data = {};\n\n    const encode = action => encodeAction(action, abis); // multi-chain requests requires version 3\n\n\n    if (args.chainId === null) {\n      version = 3;\n    } // set the request data\n\n\n    if (args.identity !== undefined) {\n      if (args.identity.scope) {\n        version = 3;\n      }\n\n      data.req = ['identity', this.identityType(version).from(args.identity)];\n    } else if (args.action && !args.actions && !args.transaction) {\n      data.req = ['action', encode(args.action)];\n    } else if (args.actions && !args.action && !args.transaction) {\n      if (args.actions.length === 1) {\n        data.req = ['action', encode(args.actions[0])];\n      } else {\n        data.req = ['action[]', args.actions.map(encode)];\n      }\n    } else if (args.transaction && !args.action && !args.actions) {\n      const tx = args.transaction; // set default values if missing\n\n      if (tx.expiration === undefined) {\n        tx.expiration = '1970-01-01T00:00:00.000';\n      }\n\n      if (tx.ref_block_num === undefined) {\n        tx.ref_block_num = 0;\n      }\n\n      if (tx.ref_block_prefix === undefined) {\n        tx.ref_block_prefix = 0;\n      }\n\n      if (tx.context_free_actions === undefined) {\n        tx.context_free_actions = [];\n      }\n\n      if (tx.transaction_extensions === undefined) {\n        tx.transaction_extensions = [];\n      }\n\n      if (tx.delay_sec === undefined) {\n        tx.delay_sec = 0;\n      }\n\n      if (tx.max_cpu_usage_ms === undefined) {\n        tx.max_cpu_usage_ms = 0;\n      }\n\n      if (tx.max_net_usage_words === undefined) {\n        tx.max_net_usage_words = 0;\n      }\n\n      if (tx.actions === undefined) {\n        tx.actions = [];\n      }\n\n      if (tx.context_free_actions === undefined) {\n        tx.context_free_actions = [];\n      } // encode actions if needed\n\n\n      tx.actions = tx.actions.map(encode);\n      data.req = ['transaction', tx];\n    } else {\n      throw new TypeError('Invalid arguments: Must have exactly one of action, actions or transaction');\n    } // set the chain id\n\n\n    if (args.chainId === null) {\n      data.chain_id = ChainIdVariant.from(['chain_alias', 0]);\n    } else {\n      data.chain_id = ChainId.from(args.chainId || ChainName.EOS).chainVariant;\n    } // request flags and callback\n\n\n    const flags = RequestFlags.from(0);\n    let callback = '';\n    flags.broadcast = args.broadcast !== undefined ? args.broadcast : data.req[0] !== 'identity';\n\n    if (typeof args.callback === 'string') {\n      callback = args.callback;\n    } else if (typeof args.callback === 'object') {\n      callback = args.callback.url;\n      flags.background = args.callback.background || false;\n    }\n\n    data.flags = flags;\n    data.callback = callback; // info pairs\n\n    data.info = [];\n\n    if (typeof args.info === 'object') {\n      for (const key in args.info) {\n        const isOwn = Object.prototype.hasOwnProperty.call(args.info, key);\n\n        if (isOwn) {\n          let value = args.info[key];\n\n          if (typeof value === 'string') {\n            value = Bytes.from(value, 'utf8');\n          } else if (!(value instanceof Bytes)) {\n            value = Serializer.encode({\n              object: value\n            });\n          }\n\n          data.info.push({\n            key,\n            value\n          });\n        }\n      }\n    }\n\n    if (args.chainIds && args.chainId === null) {\n      const ids = args.chainIds.map(id => ChainId.from(id).chainVariant);\n      data.info.push({\n        key: 'chain_ids',\n        value: Serializer.encode({\n          object: ids,\n          type: {\n            type: ChainIdVariant,\n            array: true\n          }\n        })\n      });\n    }\n\n    const req = new SigningRequest(version, this.storageType(version).from(data), options.zlib, options.abiProvider); // sign the request if given a signature provider\n\n    if (options.signatureProvider) {\n      req.sign(options.signatureProvider);\n    }\n\n    return req;\n  }\n  /** Creates an identity request. */\n\n\n  static identity(args, options = {}) {\n    let permission = {\n      actor: args.account || PlaceholderName,\n      permission: args.permission || PlaceholderPermission\n    };\n\n    if (permission.actor === PlaceholderName && permission.permission === PlaceholderPermission) {\n      permission = undefined;\n    }\n\n    return this.createSync({ ...args,\n      identity: {\n        permission,\n        scope: args.scope\n      },\n      broadcast: false\n    }, options);\n  }\n  /**\n   * Create a request from a chain id and serialized transaction.\n   * @param chainId The chain id where the transaction is valid.\n   * @param serializedTransaction The serialized transaction.\n   * @param options Creation options.\n   */\n\n\n  static fromTransaction(chainId, serializedTransaction, options = {}) {\n    const id = ChainId.from(chainId);\n    serializedTransaction = Bytes.from(serializedTransaction);\n    const encoder = new ABIEncoder();\n    encoder.writeByte(2); // header\n\n    encoder.writeArray(Serializer.encode({\n      object: id.chainVariant\n    }).array);\n    encoder.writeByte(2); // transaction variant\n\n    encoder.writeArray(Bytes.from(serializedTransaction).array);\n    encoder.writeByte(RequestFlags.broadcast);\n    encoder.writeByte(0); // callback\n\n    encoder.writeByte(0); // info\n\n    return SigningRequest.fromData(encoder.getData(), options);\n  }\n  /** Creates a signing request from encoded `esr:` uri string. */\n\n\n  static from(uri, options = {}) {\n    if (typeof uri !== 'string') {\n      throw new Error('Invalid request uri');\n    }\n\n    const [scheme, path] = uri.split(':');\n\n    if (scheme !== 'esr' && scheme !== 'web+esr') {\n      throw new Error('Invalid scheme');\n    }\n\n    const data = decode(path.startsWith('//') ? path.slice(2) : path);\n    return SigningRequest.fromData(data, options);\n  }\n\n  static fromData(data, options = {}) {\n    data = Bytes.from(data);\n    const header = data.array[0];\n    const version = header & ~(1 << 7);\n\n    if (version !== 2 && version !== 3) {\n      throw new Error('Unsupported protocol version');\n    }\n\n    let payload = data.droppingFirst(1);\n\n    if ((header & 1 << 7) !== 0) {\n      if (!options.zlib) {\n        throw new Error('Compressed URI needs zlib');\n      }\n\n      payload = Bytes.from(options.zlib.inflateRaw(payload.array));\n    }\n\n    const decoder = new ABIDecoder(payload.array);\n    const req = Serializer.decode({\n      data: decoder,\n      type: this.storageType(version)\n    });\n    let sig;\n\n    if (decoder.canRead()) {\n      sig = Serializer.decode({\n        data: decoder,\n        type: RequestSignature\n      });\n    }\n\n    return new SigningRequest(version, req, options.zlib, options.abiProvider, sig);\n  }\n  /**\n   * Sign the request, mutating.\n   * @param signatureProvider The signature provider that provides a signature for the signer.\n   */\n\n\n  sign(signatureProvider) {\n    const message = this.getSignatureDigest();\n    this.signature = RequestSignature.from(signatureProvider.sign(message));\n  }\n  /**\n   * Get the signature digest for this request.\n   */\n\n\n  getSignatureDigest() {\n    // protocol version + utf8 \"request\"\n    const prefix = [this.version, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74];\n    return Checksum256.hash(Bytes.from(prefix).appending(this.getData()));\n  }\n  /**\n   * Set the signature data for this request, mutating.\n   * @param signer Account name of signer.\n   * @param signature The signature string.\n   */\n\n\n  setSignature(signer, signature) {\n    this.signature = RequestSignature.from({\n      signer,\n      signature\n    });\n  }\n  /**\n   * Set the request callback, mutating.\n   * @param url Where the callback should be sent.\n   * @param background Whether the callback should be sent in the background.\n   */\n\n\n  setCallback(url, background) {\n    this.data.callback = url;\n    this.data.flags.background = background;\n  }\n  /**\n   * Set broadcast flag.\n   * @param broadcast Whether the transaction should be broadcast by receiver.\n   */\n\n\n  setBroadcast(broadcast) {\n    this.data.flags.broadcast = broadcast;\n  }\n  /**\n   * Encode this request into an `esr:` uri.\n   * @argument compress Whether to compress the request data using zlib,\n   *                    defaults to true if omitted and zlib is present;\n   *                    otherwise false.\n   * @argument slashes Whether add slashes after the protocol scheme, i.e. `esr://`.\n   *                   Defaults to true.\n   * @returns An esr uri string.\n   */\n\n\n  encode(compress, slashes) {\n    const shouldCompress = compress !== undefined ? compress : this.zlib !== undefined;\n\n    if (shouldCompress && this.zlib === undefined) {\n      throw new Error('Need zlib to compress');\n    }\n\n    let header = this.version;\n    const data = this.getData();\n    const sigData = this.getSignatureData();\n    let array = new Uint8Array(data.byteLength + sigData.byteLength);\n    array.set(data, 0);\n    array.set(sigData, data.byteLength);\n\n    if (shouldCompress) {\n      const deflated = this.zlib.deflateRaw(array);\n\n      if (array.byteLength > deflated.byteLength) {\n        header |= 1 << 7;\n        array = deflated;\n      }\n    }\n\n    const out = new Uint8Array(1 + array.byteLength);\n    out[0] = header;\n    out.set(array, 1);\n    let scheme = 'esr:';\n\n    if (slashes !== false) {\n      scheme += '//';\n    }\n\n    return scheme + encode(out);\n  }\n  /** Get the request data without header or signature. */\n\n\n  getData() {\n    return Serializer.encode({\n      object: this.data\n    }).array;\n  }\n  /** Get signature data, returns an empty array if request is not signed. */\n\n\n  getSignatureData() {\n    if (!this.signature) {\n      return new Uint8Array(0);\n    }\n\n    return Serializer.encode({\n      object: this.signature\n    }).array;\n  }\n  /** ABI definitions required to resolve request. */\n\n\n  getRequiredAbis() {\n    return this.getRawActions().filter(action => !isIdentity(action)).map(action => action.account).filter((value, index, self) => self.indexOf(value) === index);\n  }\n  /** Whether TaPoS values are required to resolve request. */\n\n\n  requiresTapos() {\n    const tx = this.getRawTransaction();\n    return !this.isIdentity() && !hasTapos(tx);\n  }\n  /** Resolve required ABI definitions. */\n\n\n  async fetchAbis(abiProvider) {\n    const required = this.getRequiredAbis();\n\n    if (required.length > 0) {\n      const provider = abiProvider || this.abiProvider;\n\n      if (!provider) {\n        throw new Error('Missing ABI provider');\n      }\n\n      const abis = new Map();\n      await Promise.all(required.map(async account => {\n        abis.set(account.toString(), ABI.from(await provider.getAbi(account)));\n      }));\n      return abis;\n    } else {\n      return new Map();\n    }\n  }\n  /**\n   * Decode raw actions actions to object representations.\n   * @param abis ABI defenitions required to decode all actions.\n   * @param signer Placeholders in actions will be resolved to signer if set.\n   */\n\n\n  resolveActions(abis, signer) {\n    return this.getRawActions().map(rawAction => {\n      let abi;\n\n      if (isIdentity(rawAction)) {\n        abi = this.constructor.identityAbi(this.version);\n      } else {\n        const rawAbi = abis.get(rawAction.account.toString());\n\n        if (!rawAbi) {\n          throw new Error(`Missing ABI definition for ${rawAction.account}`);\n        }\n\n        abi = ABI.from(rawAbi);\n      }\n\n      const type = abi.getActionType(rawAction.name);\n\n      if (!type) {\n        throw new Error(`Missing type for action ${rawAction.account}:${rawAction.name} in ABI`);\n      }\n\n      let data = rawAction.decodeData(abi);\n      let authorization = rawAction.authorization;\n\n      if (signer) {\n        const signerPerm = PermissionLevel.from(signer);\n\n        const resolve = value => {\n          if (value instanceof Name) {\n            if (value.equals(PlaceholderName)) {\n              return signerPerm.actor;\n            } else if (value.equals(PlaceholderPermission)) {\n              return signerPerm.permission;\n            } else {\n              return value;\n            }\n          } else if (Array.isArray(value)) {\n            return value.map(resolve);\n          } else if (typeof value === 'object' && value !== null) {\n            for (const key of Object.keys(value)) {\n              value[key] = resolve(value[key]);\n            }\n\n            return value;\n          } else {\n            return value;\n          }\n        };\n\n        data = resolve(data);\n        authorization = authorization.map(auth => {\n          let {\n            actor,\n            permission\n          } = auth;\n\n          if (actor.equals(PlaceholderName)) {\n            actor = signerPerm.actor;\n          }\n\n          if (permission.equals(PlaceholderPermission)) {\n            permission = signerPerm.permission;\n          } // backwards compatibility, actor placeholder will also resolve to permission when used in auth\n\n\n          if (permission.equals(PlaceholderName)) {\n            permission = signerPerm.permission;\n          }\n\n          return PermissionLevel.from({\n            actor,\n            permission\n          });\n        });\n      }\n\n      return { ...rawAction,\n        authorization,\n        data\n      };\n    });\n  }\n\n  resolveTransaction(abis, signer, ctx = {}) {\n    const tx = this.getRawTransaction();\n\n    if (!this.isIdentity() && !hasTapos(tx)) {\n      if (ctx.expiration !== undefined && ctx.ref_block_num !== undefined && ctx.ref_block_prefix !== undefined) {\n        tx.expiration = TimePointSec.from(ctx.expiration);\n        tx.ref_block_num = UInt16.from(ctx.ref_block_num);\n        tx.ref_block_prefix = UInt32.from(ctx.ref_block_prefix);\n      } else if (ctx.block_num !== undefined && ctx.ref_block_prefix !== undefined && ctx.timestamp !== undefined) {\n        tx.expiration = expirationTime(ctx.timestamp, ctx.expire_seconds);\n        tx.ref_block_num = UInt16.from(ctx.block_num);\n        tx.ref_block_prefix = UInt32.from(ctx.ref_block_prefix);\n      } else {\n        throw new Error('Invalid transaction context, need either a reference block or explicit TaPoS values');\n      }\n    } else if (this.isIdentity() && this.version > 2) {\n      // From ESR version 3 all identity requests have expiration\n      tx.expiration = ctx.expiration ? TimePointSec.from(ctx.expiration) : expirationTime(ctx.timestamp, ctx.expire_seconds);\n    }\n\n    const actions = this.resolveActions(abis, signer); // TODO: resolve context free actions\n\n    const context_free_actions = tx.context_free_actions;\n    return { ...tx,\n      context_free_actions,\n      actions\n    };\n  }\n\n  resolve(abis, signer, ctx = {}) {\n    const tx = this.resolveTransaction(abis, signer, ctx);\n    const actions = tx.actions.map(action => {\n      let abi;\n\n      if (isIdentity(action)) {\n        abi = this.constructor.identityAbi(this.version);\n      } else {\n        abi = abis.get(action.account.toString());\n      }\n\n      if (!abi) {\n        throw new Error(`Missing ABI definition for ${action.account}`);\n      }\n\n      const type = abi.getActionType(action.name);\n      const data = Serializer.encode({\n        object: action.data,\n        type,\n        abi\n      });\n      return Action.from({ ...action,\n        data\n      });\n    });\n    const transaction = Transaction.from({ ...tx,\n      actions\n    });\n    let chainId;\n\n    if (this.isMultiChain()) {\n      if (!ctx.chainId) {\n        throw new Error('Missing chosen chain ID for multi-chain request');\n      }\n\n      chainId = ChainId.from(ctx.chainId);\n      const ids = this.getChainIds();\n\n      if (ids && !ids.some(id => chainId.equals(id))) {\n        throw new Error('Trying to resolve for chain ID not defined in request');\n      }\n    } else {\n      chainId = this.getChainId();\n    }\n\n    return new ResolvedSigningRequest(this, PermissionLevel.from(signer), transaction, tx, chainId);\n  }\n  /**\n   * Get the id of the chain where this request is valid.\n   * @returns The 32-byte chain id as hex encoded string.\n   */\n\n\n  getChainId() {\n    return this.data.chain_id.chainId;\n  }\n  /**\n   * Chain IDs this request is valid for, only valid for multi chain requests. Value of `null` when `isMultiChain` is true denotes any chain.\n   */\n\n\n  getChainIds() {\n    if (!this.isMultiChain()) {\n      return null;\n    }\n\n    const ids = this.getInfoKey('chain_ids', {\n      type: ChainIdVariant,\n      array: true\n    });\n\n    if (ids) {\n      return ids.map(id => id.chainId);\n    }\n\n    return null;\n  }\n  /**\n   * Set chain IDs this request is valid for, only considered for multi chain requests.\n   */\n\n\n  setChainIds(ids) {\n    const value = ids.map(id => ChainId.from(id).chainVariant);\n    this.setInfoKey('chain_ids', value, {\n      type: ChainIdVariant,\n      array: true\n    });\n  }\n  /**\n   * True if chainId is set to chain alias `0` which indicates that the request is valid for any chain.\n   */\n\n\n  isMultiChain() {\n    return this.data.chain_id.variantIdx === 0 && this.data.chain_id.value.value === ChainName.UNKNOWN;\n  }\n  /** Return the actions in this request with action data encoded. */\n\n\n  getRawActions() {\n    const req = this.data.req;\n\n    switch (req.variantName) {\n      case 'action':\n        return [req.value];\n\n      case 'action[]':\n        return req.value;\n\n      case 'identity':\n        {\n          if (this.version === 2) {\n            const id = req.value;\n            let data = '0101000000000000000200000000000000'; // placeholder permission\n\n            let authorization = [PlaceholderAuth];\n\n            if (id.permission) {\n              data = Serializer.encode({\n                object: id\n              });\n              authorization = [id.permission];\n            }\n\n            return [Action.from({\n              account: '',\n              name: 'identity',\n              authorization,\n              data\n            })];\n          } else {\n            // eslint-disable-next-line prefer-const\n            let {\n              scope,\n              permission\n            } = req.value;\n\n            if (!permission) {\n              permission = PlaceholderAuth;\n            }\n\n            const data = Serializer.encode({\n              object: {\n                scope,\n                permission\n              },\n              type: IdentityV3\n            });\n            return [Action.from({\n              account: '',\n              name: 'identity',\n              authorization: [permission],\n              data\n            })];\n          }\n        }\n\n      case 'transaction':\n        return req.value.actions;\n\n      default:\n        throw new Error('Invalid signing request data');\n    }\n  }\n  /** Unresolved transaction. */\n\n\n  getRawTransaction() {\n    const req = this.data.req;\n\n    switch (req.variantName) {\n      case 'transaction':\n        return Transaction.from({ ...req.value\n        });\n\n      case 'action':\n      case 'action[]':\n      case 'identity':\n        return Transaction.from({\n          actions: this.getRawActions(),\n          context_free_actions: [],\n          transaction_extensions: [],\n          expiration: '1970-01-01T00:00:00.000',\n          ref_block_num: 0,\n          ref_block_prefix: 0,\n          max_cpu_usage_ms: 0,\n          max_net_usage_words: 0,\n          delay_sec: 0\n        });\n\n      default:\n        throw new Error('Invalid signing request data');\n    }\n  }\n  /** Whether the request is an identity request. */\n\n\n  isIdentity() {\n    return this.data.req.variantName === 'identity';\n  }\n  /** Whether the request should be broadcast by signer. */\n\n\n  shouldBroadcast() {\n    if (this.isIdentity()) {\n      return false;\n    }\n\n    return this.data.flags.broadcast;\n  }\n  /**\n   * Present if the request is an identity request and requests a specific account.\n   * @note This returns `nil` unless a specific identity has been requested,\n   *       use `isIdentity` to check id requests.\n   */\n\n\n  getIdentity() {\n    if (!this.isIdentity()) {\n      return null;\n    }\n\n    const id = this.data.req.value;\n\n    if (id.permission && !id.permission.actor.equals(PlaceholderName)) {\n      return id.permission.actor;\n    }\n\n    return null;\n  }\n  /**\n   * Present if the request is an identity request and requests a specific permission.\n   * @note This returns `nil` unless a specific permission has been requested,\n   *       use `isIdentity` to check id requests.\n   */\n\n\n  getIdentityPermission() {\n    if (!this.isIdentity()) {\n      return null;\n    }\n\n    const id = this.data.req.value;\n\n    if (id.permission && !id.permission.permission.equals(PlaceholderPermission)) {\n      return id.permission.permission;\n    }\n\n    return null;\n  }\n  /**\n   * Present if the request is an identity request and requests a specific permission.\n   * @note This returns `nil` unless a specific permission has been requested,\n   *       use `isIdentity` to check id requests.\n   */\n\n\n  getIdentityScope() {\n    if (!this.isIdentity() || this.version <= 2) {\n      return null;\n    }\n\n    const id = this.data.req.value;\n    return id.scope;\n  }\n  /** Get raw info dict */\n\n\n  getRawInfo() {\n    const rv = {};\n\n    for (const {\n      key,\n      value\n    } of this.data.info) {\n      rv[key] = value;\n    }\n\n    return rv;\n  }\n\n  getRawInfoKey(key) {\n    const pair = this.data.info.find(pair => pair.key === key);\n\n    if (pair) {\n      return pair.value;\n    }\n  }\n\n  setRawInfoKey(key, value) {\n    let pair = this.data.info.find(pair => pair.key === key);\n\n    if (!pair) {\n      pair = InfoPair.from({\n        key,\n        value\n      });\n      this.data.info.push(pair);\n    } else {\n      pair.value = Bytes.from(value);\n    }\n  }\n  /** Set a metadata key. */\n\n\n  setInfoKey(key, object, type) {\n    let data;\n\n    if (typeof object === 'string' && !type) {\n      // match old behavior where strings encode to raw utf8 as opposed to\n      // eosio-abi encoded strings (varuint32 length prefix + utf8 bytes)\n      data = Bytes.from(object, 'utf8');\n    } else {\n      data = Serializer.encode({\n        object,\n        type\n      });\n    }\n\n    this.setRawInfoKey(key, data);\n  }\n\n  getInfoKey(key, type) {\n    const data = this.getRawInfoKey(key);\n\n    if (data) {\n      if (type) {\n        return Serializer.decode({\n          data,\n          type\n        });\n      } else {\n        // assume utf8 string if no type is given\n        return data.utf8String;\n      }\n    }\n  }\n  /** Return a deep copy of this request. */\n\n\n  clone() {\n    let signature;\n\n    if (this.signature) {\n      signature = RequestSignature.from(JSON.parse(JSON.stringify(this.signature)));\n    }\n\n    const RequestData = this.constructor.storageType(this.version);\n    const data = RequestData.from(JSON.parse(JSON.stringify(this.data)));\n    return new SigningRequest(this.version, data, this.zlib, this.abiProvider, signature);\n  } // Convenience methods.\n\n\n  toString() {\n    return this.encode();\n  }\n\n  toJSON() {\n    return this.encode();\n  }\n\n}\n\nclass ResolvedSigningRequest {\n  constructor(request, signer, transaction, resolvedTransaction, chainId) {\n    this.request = request;\n    this.signer = signer;\n    this.transaction = transaction;\n    this.resolvedTransaction = resolvedTransaction;\n    this.chainId = chainId;\n  }\n  /** Recreate a resolved request from a callback payload. */\n\n\n  static async fromPayload(payload, options = {}) {\n    const request = SigningRequest.from(payload.req, options);\n    const abis = await request.fetchAbis();\n    return request.resolve(abis, {\n      actor: payload.sa,\n      permission: payload.sp\n    }, {\n      ref_block_num: payload.rbn,\n      ref_block_prefix: payload.rid,\n      expiration: payload.ex,\n      chainId: payload.cid || request.getChainId()\n    });\n  }\n\n  get serializedTransaction() {\n    return Serializer.encode({\n      object: this.transaction\n    }).array;\n  }\n\n  get signingDigest() {\n    return this.transaction.signingDigest(this.chainId);\n  }\n\n  getCallback(signatures, blockNum) {\n    const {\n      callback,\n      flags\n    } = this.request.data;\n\n    if (!callback || callback.length === 0) {\n      return null;\n    }\n\n    if (!signatures || signatures.length === 0) {\n      throw new Error('Must have at least one signature to resolve callback');\n    }\n\n    const sigs = signatures.map(sig => Signature.from(sig));\n    const payload = {\n      sig: String(sigs[0]),\n      tx: String(this.transaction.id),\n      rbn: String(this.transaction.ref_block_num),\n      rid: String(this.transaction.ref_block_prefix),\n      ex: String(this.transaction.expiration),\n      req: this.request.encode(),\n      sa: String(this.signer.actor),\n      sp: String(this.signer.permission),\n      cid: String(this.chainId)\n    };\n\n    for (const [n, sig] of sigs.slice(1).entries()) {\n      payload[`sig${n}`] = String(sig);\n    }\n\n    if (blockNum) {\n      payload.bn = String(UInt32.from(blockNum));\n    }\n\n    const url = callback.replace(/({{([a-z0-9]+)}})/g, (_1, _2, m) => {\n      return payload[m] || '';\n    });\n    return {\n      background: flags.background,\n      payload,\n      url\n    };\n  }\n\n  getIdentityProof(signature) {\n    if (!this.request.isIdentity()) {\n      throw new Error('Not a identity request');\n    }\n\n    return IdentityProof.from({\n      chainId: this.chainId,\n      scope: this.request.getIdentityScope(),\n      expiration: this.transaction.expiration,\n      signer: this.signer,\n      signature\n    });\n  }\n\n}\n\nfunction encodeAction(action, abis) {\n  if (Bytes.isBytes(action.data) || action.data.constructor.abiName !== undefined) {\n    return Action.from(action);\n  }\n\n  const abi = abis[String(Name.from(action.account))];\n\n  if (!abi) {\n    throw new Error(`Missing ABI for ${action.account}`);\n  }\n\n  return Action.from(action, abi);\n}\n\nfunction isIdentity(action) {\n  const account = Name.from(action.account);\n  const name = Name.from(action.name);\n  return account.rawValue.equals(0) && name.equals('identity');\n}\n\nfunction hasTapos(tx) {\n  return !(tx.expiration.value.value === 0 && tx.ref_block_num.value === 0 && tx.ref_block_prefix.value === 0);\n}\n\nfunction expirationTime(timestamp, expireSeconds = 60) {\n  const ts = TimePointSec.from(timestamp || new Date());\n  const exp = UInt32.from(expireSeconds);\n  return TimePointSec.fromMilliseconds(ts.toMilliseconds() + exp.value * 1000);\n}\n\nexport { AccountName, base64u as Base64u, ChainAlias, ChainId, ChainIdVariant, ChainName, IdentityProof, IdentityV2, IdentityV3, InfoPair, PermissionName, PlaceholderAuth, PlaceholderName, PlaceholderPermission, ProtocolVersion, RequestDataV2, RequestDataV3, RequestFlags, RequestSignature, RequestVariantV2, RequestVariantV3, ResolvedSigningRequest, SigningRequest };","map":{"version":3,"sources":["../src/base64u.ts","../src/chain-id.ts","../src/abi.ts","../src/identity-proof.ts","../src/signing-request.ts"],"names":["Base64u.decode","Base64u.encode","base64u.decode","base64u.encode"],"mappings":"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","sourcesContent":["/**\n * EOSIO Signing Request v2.2.0\n * https://github.com/greymass/eosio-signing-request\n *\n * @license\n * Copyright © 2021 Greymass Inc.\n * \n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the “Software”), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n * \n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n * \n * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR\n * INTENDED FOR USE IN THE DESIGN, CONSTRUCTION, OPERATION OR\n * MAINTENANCE OF ANY MILITARY FACILITY.\n */\nimport { Checksum256, TypeAlias, UInt8, Variant, Name, Struct, PermissionLevel, Action, Transaction, isInstanceOf, Serializer, TimePointSec, Authority, Signature, Bytes, ABIEncoder, ABIDecoder, ABI, UInt16, UInt32 } from '@greymass/eosio';\nimport { __decorate } from 'tslib';\n\n/**\n * Base64u - URL-Safe Base64 variant no padding.\n * Based on https://gist.github.com/jonleighton/958841\n */\nconst baseCharset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nconst lookup = new Uint8Array(256);\nfor (let i = 0; i < 62; i++) {\n    lookup[baseCharset.charCodeAt(i)] = i;\n}\n// support both urlsafe and standard base64\nlookup[43] = lookup[45] = 62;\nlookup[47] = lookup[95] = 63;\nfunction encode(data, urlSafe = true) {\n    const byteLength = data.byteLength;\n    const byteRemainder = byteLength % 3;\n    const mainLength = byteLength - byteRemainder;\n    const charset = baseCharset + (urlSafe ? '-_' : '+/');\n    const parts = [];\n    let a;\n    let b;\n    let c;\n    let d;\n    let chunk;\n    // Main loop deals with bytes in chunks of 3\n    for (let i = 0; i < mainLength; i += 3) {\n        // Combine the three bytes into a single integer\n        chunk = (data[i] << 16) | (data[i + 1] << 8) | data[i + 2];\n        // Use bitmasks to extract 6-bit segments from the triplet\n        a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\n        b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\n        c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\n        d = chunk & 63; // 63       =  2^6 - 1\n        // Convert the raw binary segments to the appropriate ASCII encoding\n        parts.push(charset[a] + charset[b] + charset[c] + charset[d]);\n    }\n    // Deal with the remaining bytes\n    if (byteRemainder === 1) {\n        chunk = data[mainLength];\n        a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\n        // Set the 4 least significant bits to zero\n        b = (chunk & 3) << 4; // 3   = 2^2 - 1\n        parts.push(charset[a] + charset[b]);\n    }\n    else if (byteRemainder === 2) {\n        chunk = (data[mainLength] << 8) | data[mainLength + 1];\n        a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\n        b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\n        // Set the 2 least significant bits to zero\n        c = (chunk & 15) << 2; // 15    = 2^4 - 1\n        parts.push(charset[a] + charset[b] + charset[c]);\n    }\n    return parts.join('');\n}\nfunction decode(input) {\n    const byteLength = input.length * 0.75;\n    const data = new Uint8Array(byteLength);\n    let a;\n    let b;\n    let c;\n    let d;\n    let p = 0;\n    for (let i = 0; i < input.length; i += 4) {\n        a = lookup[input.charCodeAt(i)];\n        b = lookup[input.charCodeAt(i + 1)];\n        c = lookup[input.charCodeAt(i + 2)];\n        d = lookup[input.charCodeAt(i + 3)];\n        data[p++] = (a << 2) | (b >> 4);\n        data[p++] = ((b & 15) << 4) | (c >> 2);\n        data[p++] = ((c & 3) << 6) | (d & 63);\n    }\n    return data;\n}\n\nvar base64u = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    encode: encode,\n    decode: decode\n});\n\n/** Chain ID aliases. */\nvar ChainName;\n(function (ChainName) {\n    ChainName[ChainName[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    ChainName[ChainName[\"EOS\"] = 1] = \"EOS\";\n    ChainName[ChainName[\"TELOS\"] = 2] = \"TELOS\";\n    ChainName[ChainName[\"JUNGLE\"] = 3] = \"JUNGLE\";\n    ChainName[ChainName[\"KYLIN\"] = 4] = \"KYLIN\";\n    ChainName[ChainName[\"WORBLI\"] = 5] = \"WORBLI\";\n    ChainName[ChainName[\"BOS\"] = 6] = \"BOS\";\n    ChainName[ChainName[\"MEETONE\"] = 7] = \"MEETONE\";\n    ChainName[ChainName[\"INSIGHTS\"] = 8] = \"INSIGHTS\";\n    ChainName[ChainName[\"BEOS\"] = 9] = \"BEOS\";\n    ChainName[ChainName[\"WAX\"] = 10] = \"WAX\";\n    ChainName[ChainName[\"PROTON\"] = 11] = \"PROTON\";\n    ChainName[ChainName[\"FIO\"] = 12] = \"FIO\";\n})(ChainName || (ChainName = {}));\nlet ChainId = class ChainId extends Checksum256 {\n    static from(value) {\n        if (value instanceof this) {\n            return value;\n        }\n        if (typeof value === 'number') {\n            value = ChainIdLookup.get(value);\n            if (!value) {\n                throw new Error('Unknown chain id alias');\n            }\n        }\n        return super.from(value);\n    }\n    get chainVariant() {\n        const name = this.chainName;\n        if (name !== ChainName.UNKNOWN) {\n            return ChainIdVariant.from(['chain_alias', name]);\n        }\n        return ChainIdVariant.from(this);\n    }\n    get chainName() {\n        const cid = this.hexString;\n        for (const [n, id] of ChainIdLookup) {\n            if (id === cid) {\n                return n;\n            }\n        }\n        return ChainName.UNKNOWN;\n    }\n};\nChainId = __decorate([\n    TypeAlias('chain_id')\n], ChainId);\nlet ChainAlias = class ChainAlias extends UInt8 {\n};\nChainAlias = __decorate([\n    TypeAlias('chain_alias')\n], ChainAlias);\nlet ChainIdVariant = class ChainIdVariant extends Variant {\n    get chainId() {\n        if (this.value instanceof ChainId) {\n            return this.value;\n        }\n        return ChainId.from(this.value.value);\n    }\n};\nChainIdVariant = __decorate([\n    Variant.type('variant_id', [ChainAlias, ChainId])\n], ChainIdVariant);\nconst ChainIdLookup = new Map([\n    [ChainName.EOS, 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906'],\n    [ChainName.TELOS, '4667b205c6838ef70ff7988f6e8257e8be0e1284a2f59699054a018f743b1d11'],\n    [ChainName.JUNGLE, 'e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473'],\n    [ChainName.KYLIN, '5fff1dae8dc8e2fc4d5b23b2c7665c97f9e9d8edf2b6485a86ba311c25639191'],\n    [ChainName.WORBLI, '73647cde120091e0a4b85bced2f3cfdb3041e266cbbe95cee59b73235a1b3b6f'],\n    [ChainName.BOS, 'd5a3d18fbb3c084e3b1f3fa98c21014b5f3db536cc15d08f9f6479517c6a3d86'],\n    [ChainName.MEETONE, 'cfe6486a83bad4962f232d48003b1824ab5665c36778141034d75e57b956e422'],\n    [ChainName.INSIGHTS, 'b042025541e25a472bffde2d62edd457b7e70cee943412b1ea0f044f88591664'],\n    [ChainName.BEOS, 'b912d19a6abd2b1b05611ae5be473355d64d95aeff0c09bedc8c166cd6468fe4'],\n    [ChainName.WAX, '1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4'],\n    [ChainName.PROTON, '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0'],\n    [ChainName.FIO, '21dcae42c0182200e93f954a074011f9048a7624c6fe81d3c9541a614a88bd1c'],\n]);\n\n/** SigningRequest ABI and typedefs. */\nvar RequestFlags_1;\nlet AccountName = class AccountName extends Name {\n};\nAccountName = __decorate([\n    TypeAlias('account_name')\n], AccountName);\nlet PermissionName = class PermissionName extends Name {\n};\nPermissionName = __decorate([\n    TypeAlias('permission_name')\n], PermissionName);\nlet IdentityV2 = class IdentityV2 extends Struct {\n};\n__decorate([\n    Struct.field(PermissionLevel, { optional: true })\n], IdentityV2.prototype, \"permission\", void 0);\nIdentityV2 = __decorate([\n    Struct.type('identity')\n], IdentityV2);\nlet IdentityV3 = class IdentityV3 extends Struct {\n};\n__decorate([\n    Struct.field('name')\n], IdentityV3.prototype, \"scope\", void 0);\n__decorate([\n    Struct.field(PermissionLevel, { optional: true })\n], IdentityV3.prototype, \"permission\", void 0);\nIdentityV3 = __decorate([\n    Struct.type('identity')\n], IdentityV3);\nlet RequestVariantV2 = class RequestVariantV2 extends Variant {\n};\nRequestVariantV2 = __decorate([\n    Variant.type('variant_req', [Action, { type: Action, array: true }, Transaction, IdentityV2])\n], RequestVariantV2);\nlet RequestVariantV3 = class RequestVariantV3 extends Variant {\n};\nRequestVariantV3 = __decorate([\n    Variant.type('variant_req', [Action, { type: Action, array: true }, Transaction, IdentityV3])\n], RequestVariantV3);\nlet RequestFlags = RequestFlags_1 = class RequestFlags extends UInt8 {\n    get broadcast() {\n        return (this.value & RequestFlags_1.broadcast) !== 0;\n    }\n    set broadcast(enabled) {\n        this.setFlag(RequestFlags_1.broadcast, enabled);\n    }\n    get background() {\n        return (this.value & RequestFlags_1.background) !== 0;\n    }\n    set background(enabled) {\n        this.setFlag(RequestFlags_1.background, enabled);\n    }\n    setFlag(flag, enabled) {\n        if (enabled) {\n            this.value |= flag;\n        }\n        else {\n            this.value &= ~flag;\n        }\n    }\n};\nRequestFlags.broadcast = 1 << 0;\nRequestFlags.background = 1 << 1;\nRequestFlags = RequestFlags_1 = __decorate([\n    TypeAlias('request_flags')\n], RequestFlags);\nlet InfoPair = class InfoPair extends Struct {\n};\n__decorate([\n    Struct.field('string')\n], InfoPair.prototype, \"key\", void 0);\n__decorate([\n    Struct.field('bytes')\n], InfoPair.prototype, \"value\", void 0);\nInfoPair = __decorate([\n    Struct.type('info_pair')\n], InfoPair);\nlet RequestDataV2 = class RequestDataV2 extends Struct {\n};\n__decorate([\n    Struct.field(ChainIdVariant)\n], RequestDataV2.prototype, \"chain_id\", void 0);\n__decorate([\n    Struct.field(RequestVariantV2)\n], RequestDataV2.prototype, \"req\", void 0);\n__decorate([\n    Struct.field(RequestFlags)\n], RequestDataV2.prototype, \"flags\", void 0);\n__decorate([\n    Struct.field('string')\n], RequestDataV2.prototype, \"callback\", void 0);\n__decorate([\n    Struct.field(InfoPair, { array: true })\n], RequestDataV2.prototype, \"info\", void 0);\nRequestDataV2 = __decorate([\n    Struct.type('signing_request')\n], RequestDataV2);\nlet RequestDataV3 = class RequestDataV3 extends Struct {\n};\n__decorate([\n    Struct.field(ChainIdVariant)\n], RequestDataV3.prototype, \"chain_id\", void 0);\n__decorate([\n    Struct.field(RequestVariantV3)\n], RequestDataV3.prototype, \"req\", void 0);\n__decorate([\n    Struct.field(RequestFlags)\n], RequestDataV3.prototype, \"flags\", void 0);\n__decorate([\n    Struct.field('string')\n], RequestDataV3.prototype, \"callback\", void 0);\n__decorate([\n    Struct.field(InfoPair, { array: true })\n], RequestDataV3.prototype, \"info\", void 0);\nRequestDataV3 = __decorate([\n    Struct.type('signing_request')\n], RequestDataV3);\nlet RequestSignature = class RequestSignature extends Struct {\n};\n__decorate([\n    Struct.field('name')\n], RequestSignature.prototype, \"signer\", void 0);\n__decorate([\n    Struct.field('signature')\n], RequestSignature.prototype, \"signature\", void 0);\nRequestSignature = __decorate([\n    Struct.type('request_signature')\n], RequestSignature);\n\nvar IdentityProof_1;\nlet IdentityProof = IdentityProof_1 = class IdentityProof extends Struct {\n    static from(value) {\n        if (isInstanceOf(value, IdentityProof_1)) {\n            return value;\n        }\n        else if (typeof value === 'string') {\n            return IdentityProof_1.fromString(value);\n        }\n        else {\n            return super.from(value);\n        }\n    }\n    /**\n     * Create a new instance from an EOSIO authorization header string.\n     * \"EOSIO <base64payload>\"\n     */\n    static fromString(string) {\n        const parts = string.split(' ');\n        if (parts.length !== 2 || parts[0] !== 'EOSIO') {\n            throw new Error('Invalid IdentityProof string');\n        }\n        const data = decode(parts[1]);\n        return Serializer.decode({ data, type: IdentityProof_1 });\n    }\n    /** Create a new instance from a callback payload. */\n    static fromPayload(payload, options = {}) {\n        const request = SigningRequest.from(payload.req, options);\n        if (!(request.version >= 3 && request.isIdentity())) {\n            throw new Error('Not an identity request');\n        }\n        return this.from({\n            chainId: payload.cid || request.getChainId(),\n            scope: request.getIdentityScope(),\n            expiration: payload.ex,\n            signer: { actor: payload.sa, permission: payload.sp },\n            signature: payload.sig,\n        });\n    }\n    /**\n     * Transaction this proof resolves to.\n     * @internal\n     */\n    get transaction() {\n        const action = Action.from({\n            account: '',\n            name: 'identity',\n            authorization: [this.signer],\n            data: IdentityV3.from({ scope: this.scope, permission: this.signer }),\n        });\n        return Transaction.from({\n            ref_block_num: 0,\n            ref_block_prefix: 0,\n            expiration: this.expiration,\n            actions: [action],\n        });\n    }\n    /**\n     * Recover the public key that signed this proof.\n     */\n    recover() {\n        return this.signature.recoverDigest(this.transaction.signingDigest(this.chainId));\n    }\n    /**\n     * Verify that given authority signed this proof.\n     * @param auth The accounts signing authority.\n     * @param currentTime Time to verify expiry against, if unset will use system time.\n     */\n    verify(auth, currentTime) {\n        const now = TimePointSec.from(currentTime || new Date()).toMilliseconds();\n        return (now < this.expiration.toMilliseconds() &&\n            Authority.from(auth).hasPermission(this.recover()));\n    }\n    /**\n     * Encode the proof to an `EOSIO` auth header string.\n     */\n    toString() {\n        const data = Serializer.encode({ object: this });\n        return `EOSIO ${encode(data.array, false)}`;\n    }\n};\n__decorate([\n    Struct.field(ChainId)\n], IdentityProof.prototype, \"chainId\", void 0);\n__decorate([\n    Struct.field(Name)\n], IdentityProof.prototype, \"scope\", void 0);\n__decorate([\n    Struct.field(TimePointSec)\n], IdentityProof.prototype, \"expiration\", void 0);\n__decorate([\n    Struct.field(PermissionLevel)\n], IdentityProof.prototype, \"signer\", void 0);\n__decorate([\n    Struct.field(Signature)\n], IdentityProof.prototype, \"signature\", void 0);\nIdentityProof = IdentityProof_1 = __decorate([\n    Struct.type('identity_proof')\n], IdentityProof);\n\n/**\n * EOSIO Signing Request (ESR).\n */\n/** Current supported protocol version, backwards compatible with version 2. */\nconst ProtocolVersion = 3;\n/**\n * The placeholder name: `............1` aka `uint64(1)`.\n * If used in action data will be resolved to current signer.\n * If used in as an authorization permission will be resolved to\n * the signers permission level.\n *\n * Example action:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"............1\", permission: \"............1\"}],\n *   data: {\n *     from: \"............1\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n * When signed by `foo@active` would resolve to:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"foo\", permission: \"active\"}],\n *   data: {\n *     from: \"foo\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n */\nconst PlaceholderName = Name.from('............1'); // aka uint64(1)\n/** Placeholder that will resolve to signer permission name. */\nconst PlaceholderPermission = Name.from('............2'); // aka uint64(2)\nconst PlaceholderAuth = PermissionLevel.from({\n    actor: PlaceholderName,\n    permission: PlaceholderPermission,\n});\nclass SigningRequest {\n    /**\n     * Create a new signing request.\n     * Normally not used directly, see the `create` and `from` class methods.\n     */\n    constructor(version, data, zlib, abiProvider, signature) {\n        if (data.flags.broadcast && data.req.variantName === 'identity') {\n            throw new Error('Invalid request (identity request cannot be broadcast)');\n        }\n        this.version = version;\n        this.data = data;\n        this.zlib = zlib;\n        this.abiProvider = abiProvider;\n        this.signature = signature;\n    }\n    /** Return the identity ABI for given version. */\n    static identityAbi(version) {\n        const abi = Serializer.synthesize(this.identityType(version));\n        abi.actions = [{ name: 'identity', type: 'identity', ricardian_contract: '' }];\n        return abi;\n    }\n    /** Return the ABISerializableType identity type for given version. */\n    static identityType(version) {\n        return version === 2 ? IdentityV2 : IdentityV3;\n    }\n    /** Return the ABISerializableType storage type for given version. */\n    static storageType(version) {\n        return version === 2 ? RequestDataV2 : RequestDataV3;\n    }\n    /** Create a new signing request. */\n    static async create(args, options = {}) {\n        let actions;\n        if (args.action) {\n            actions = [args.action];\n        }\n        else if (args.actions) {\n            actions = args.actions;\n        }\n        else if (args.transaction) {\n            actions = args.transaction.actions || [];\n        }\n        else {\n            actions = [];\n        }\n        const requiredAbis = actions\n            .filter((action) => !Bytes.isBytes(action.data) &&\n            action.data.constructor.abiName === undefined)\n            .map((action) => Name.from(action.account));\n        const abis = {};\n        if (requiredAbis.length > 0) {\n            const provider = options.abiProvider;\n            if (!provider) {\n                throw new Error('Missing abi provider');\n            }\n            const accountAbis = await Promise.all(requiredAbis.map((account) => provider.getAbi(account)));\n            for (const [idx, abi] of accountAbis.entries()) {\n                abis[requiredAbis[idx].toString()] = abi;\n            }\n        }\n        return this.createSync(args, options, abis);\n    }\n    /**\n     * Synchronously create a new signing request.\n     * @throws If an un-encoded action with no abi def is encountered.\n     */\n    static createSync(args, options = {}, abis = {}) {\n        let version = 2;\n        const data = {};\n        const encode = (action) => encodeAction(action, abis);\n        // multi-chain requests requires version 3\n        if (args.chainId === null) {\n            version = 3;\n        }\n        // set the request data\n        if (args.identity !== undefined) {\n            if (args.identity.scope) {\n                version = 3;\n            }\n            data.req = ['identity', this.identityType(version).from(args.identity)];\n        }\n        else if (args.action && !args.actions && !args.transaction) {\n            data.req = ['action', encode(args.action)];\n        }\n        else if (args.actions && !args.action && !args.transaction) {\n            if (args.actions.length === 1) {\n                data.req = ['action', encode(args.actions[0])];\n            }\n            else {\n                data.req = ['action[]', args.actions.map(encode)];\n            }\n        }\n        else if (args.transaction && !args.action && !args.actions) {\n            const tx = args.transaction;\n            // set default values if missing\n            if (tx.expiration === undefined) {\n                tx.expiration = '1970-01-01T00:00:00.000';\n            }\n            if (tx.ref_block_num === undefined) {\n                tx.ref_block_num = 0;\n            }\n            if (tx.ref_block_prefix === undefined) {\n                tx.ref_block_prefix = 0;\n            }\n            if (tx.context_free_actions === undefined) {\n                tx.context_free_actions = [];\n            }\n            if (tx.transaction_extensions === undefined) {\n                tx.transaction_extensions = [];\n            }\n            if (tx.delay_sec === undefined) {\n                tx.delay_sec = 0;\n            }\n            if (tx.max_cpu_usage_ms === undefined) {\n                tx.max_cpu_usage_ms = 0;\n            }\n            if (tx.max_net_usage_words === undefined) {\n                tx.max_net_usage_words = 0;\n            }\n            if (tx.actions === undefined) {\n                tx.actions = [];\n            }\n            if (tx.context_free_actions === undefined) {\n                tx.context_free_actions = [];\n            }\n            // encode actions if needed\n            tx.actions = tx.actions.map(encode);\n            data.req = ['transaction', tx];\n        }\n        else {\n            throw new TypeError('Invalid arguments: Must have exactly one of action, actions or transaction');\n        }\n        // set the chain id\n        if (args.chainId === null) {\n            data.chain_id = ChainIdVariant.from(['chain_alias', 0]);\n        }\n        else {\n            data.chain_id = ChainId.from(args.chainId || ChainName.EOS).chainVariant;\n        }\n        // request flags and callback\n        const flags = RequestFlags.from(0);\n        let callback = '';\n        flags.broadcast = args.broadcast !== undefined ? args.broadcast : data.req[0] !== 'identity';\n        if (typeof args.callback === 'string') {\n            callback = args.callback;\n        }\n        else if (typeof args.callback === 'object') {\n            callback = args.callback.url;\n            flags.background = args.callback.background || false;\n        }\n        data.flags = flags;\n        data.callback = callback;\n        // info pairs\n        data.info = [];\n        if (typeof args.info === 'object') {\n            for (const key in args.info) {\n                const isOwn = Object.prototype.hasOwnProperty.call(args.info, key);\n                if (isOwn) {\n                    let value = args.info[key];\n                    if (typeof value === 'string') {\n                        value = Bytes.from(value, 'utf8');\n                    }\n                    else if (!(value instanceof Bytes)) {\n                        value = Serializer.encode({ object: value });\n                    }\n                    data.info.push({ key, value });\n                }\n            }\n        }\n        if (args.chainIds && args.chainId === null) {\n            const ids = args.chainIds.map((id) => ChainId.from(id).chainVariant);\n            data.info.push({\n                key: 'chain_ids',\n                value: Serializer.encode({ object: ids, type: { type: ChainIdVariant, array: true } }),\n            });\n        }\n        const req = new SigningRequest(version, this.storageType(version).from(data), options.zlib, options.abiProvider);\n        // sign the request if given a signature provider\n        if (options.signatureProvider) {\n            req.sign(options.signatureProvider);\n        }\n        return req;\n    }\n    /** Creates an identity request. */\n    static identity(args, options = {}) {\n        let permission = {\n            actor: args.account || PlaceholderName,\n            permission: args.permission || PlaceholderPermission,\n        };\n        if (permission.actor === PlaceholderName &&\n            permission.permission === PlaceholderPermission) {\n            permission = undefined;\n        }\n        return this.createSync({\n            ...args,\n            identity: {\n                permission,\n                scope: args.scope,\n            },\n            broadcast: false,\n        }, options);\n    }\n    /**\n     * Create a request from a chain id and serialized transaction.\n     * @param chainId The chain id where the transaction is valid.\n     * @param serializedTransaction The serialized transaction.\n     * @param options Creation options.\n     */\n    static fromTransaction(chainId, serializedTransaction, options = {}) {\n        const id = ChainId.from(chainId);\n        serializedTransaction = Bytes.from(serializedTransaction);\n        const encoder = new ABIEncoder();\n        encoder.writeByte(2); // header\n        encoder.writeArray(Serializer.encode({ object: id.chainVariant }).array);\n        encoder.writeByte(2); // transaction variant\n        encoder.writeArray(Bytes.from(serializedTransaction).array);\n        encoder.writeByte(RequestFlags.broadcast);\n        encoder.writeByte(0); // callback\n        encoder.writeByte(0); // info\n        return SigningRequest.fromData(encoder.getData(), options);\n    }\n    /** Creates a signing request from encoded `esr:` uri string. */\n    static from(uri, options = {}) {\n        if (typeof uri !== 'string') {\n            throw new Error('Invalid request uri');\n        }\n        const [scheme, path] = uri.split(':');\n        if (scheme !== 'esr' && scheme !== 'web+esr') {\n            throw new Error('Invalid scheme');\n        }\n        const data = decode(path.startsWith('//') ? path.slice(2) : path);\n        return SigningRequest.fromData(data, options);\n    }\n    static fromData(data, options = {}) {\n        data = Bytes.from(data);\n        const header = data.array[0];\n        const version = header & ~(1 << 7);\n        if (version !== 2 && version !== 3) {\n            throw new Error('Unsupported protocol version');\n        }\n        let payload = data.droppingFirst(1);\n        if ((header & (1 << 7)) !== 0) {\n            if (!options.zlib) {\n                throw new Error('Compressed URI needs zlib');\n            }\n            payload = Bytes.from(options.zlib.inflateRaw(payload.array));\n        }\n        const decoder = new ABIDecoder(payload.array);\n        const req = Serializer.decode({ data: decoder, type: this.storageType(version) });\n        let sig;\n        if (decoder.canRead()) {\n            sig = Serializer.decode({ data: decoder, type: RequestSignature });\n        }\n        return new SigningRequest(version, req, options.zlib, options.abiProvider, sig);\n    }\n    /**\n     * Sign the request, mutating.\n     * @param signatureProvider The signature provider that provides a signature for the signer.\n     */\n    sign(signatureProvider) {\n        const message = this.getSignatureDigest();\n        this.signature = RequestSignature.from(signatureProvider.sign(message));\n    }\n    /**\n     * Get the signature digest for this request.\n     */\n    getSignatureDigest() {\n        // protocol version + utf8 \"request\"\n        const prefix = [this.version, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74];\n        return Checksum256.hash(Bytes.from(prefix).appending(this.getData()));\n    }\n    /**\n     * Set the signature data for this request, mutating.\n     * @param signer Account name of signer.\n     * @param signature The signature string.\n     */\n    setSignature(signer, signature) {\n        this.signature = RequestSignature.from({ signer, signature });\n    }\n    /**\n     * Set the request callback, mutating.\n     * @param url Where the callback should be sent.\n     * @param background Whether the callback should be sent in the background.\n     */\n    setCallback(url, background) {\n        this.data.callback = url;\n        this.data.flags.background = background;\n    }\n    /**\n     * Set broadcast flag.\n     * @param broadcast Whether the transaction should be broadcast by receiver.\n     */\n    setBroadcast(broadcast) {\n        this.data.flags.broadcast = broadcast;\n    }\n    /**\n     * Encode this request into an `esr:` uri.\n     * @argument compress Whether to compress the request data using zlib,\n     *                    defaults to true if omitted and zlib is present;\n     *                    otherwise false.\n     * @argument slashes Whether add slashes after the protocol scheme, i.e. `esr://`.\n     *                   Defaults to true.\n     * @returns An esr uri string.\n     */\n    encode(compress, slashes) {\n        const shouldCompress = compress !== undefined ? compress : this.zlib !== undefined;\n        if (shouldCompress && this.zlib === undefined) {\n            throw new Error('Need zlib to compress');\n        }\n        let header = this.version;\n        const data = this.getData();\n        const sigData = this.getSignatureData();\n        let array = new Uint8Array(data.byteLength + sigData.byteLength);\n        array.set(data, 0);\n        array.set(sigData, data.byteLength);\n        if (shouldCompress) {\n            const deflated = this.zlib.deflateRaw(array);\n            if (array.byteLength > deflated.byteLength) {\n                header |= 1 << 7;\n                array = deflated;\n            }\n        }\n        const out = new Uint8Array(1 + array.byteLength);\n        out[0] = header;\n        out.set(array, 1);\n        let scheme = 'esr:';\n        if (slashes !== false) {\n            scheme += '//';\n        }\n        return scheme + encode(out);\n    }\n    /** Get the request data without header or signature. */\n    getData() {\n        return Serializer.encode({ object: this.data }).array;\n    }\n    /** Get signature data, returns an empty array if request is not signed. */\n    getSignatureData() {\n        if (!this.signature) {\n            return new Uint8Array(0);\n        }\n        return Serializer.encode({ object: this.signature }).array;\n    }\n    /** ABI definitions required to resolve request. */\n    getRequiredAbis() {\n        return this.getRawActions()\n            .filter((action) => !isIdentity(action))\n            .map((action) => action.account)\n            .filter((value, index, self) => self.indexOf(value) === index);\n    }\n    /** Whether TaPoS values are required to resolve request. */\n    requiresTapos() {\n        const tx = this.getRawTransaction();\n        return !this.isIdentity() && !hasTapos(tx);\n    }\n    /** Resolve required ABI definitions. */\n    async fetchAbis(abiProvider) {\n        const required = this.getRequiredAbis();\n        if (required.length > 0) {\n            const provider = abiProvider || this.abiProvider;\n            if (!provider) {\n                throw new Error('Missing ABI provider');\n            }\n            const abis = new Map();\n            await Promise.all(required.map(async (account) => {\n                abis.set(account.toString(), ABI.from(await provider.getAbi(account)));\n            }));\n            return abis;\n        }\n        else {\n            return new Map();\n        }\n    }\n    /**\n     * Decode raw actions actions to object representations.\n     * @param abis ABI defenitions required to decode all actions.\n     * @param signer Placeholders in actions will be resolved to signer if set.\n     */\n    resolveActions(abis, signer) {\n        return this.getRawActions().map((rawAction) => {\n            let abi;\n            if (isIdentity(rawAction)) {\n                abi = this.constructor.identityAbi(this.version);\n            }\n            else {\n                const rawAbi = abis.get(rawAction.account.toString());\n                if (!rawAbi) {\n                    throw new Error(`Missing ABI definition for ${rawAction.account}`);\n                }\n                abi = ABI.from(rawAbi);\n            }\n            const type = abi.getActionType(rawAction.name);\n            if (!type) {\n                throw new Error(`Missing type for action ${rawAction.account}:${rawAction.name} in ABI`);\n            }\n            let data = rawAction.decodeData(abi);\n            let authorization = rawAction.authorization;\n            if (signer) {\n                const signerPerm = PermissionLevel.from(signer);\n                const resolve = (value) => {\n                    if (value instanceof Name) {\n                        if (value.equals(PlaceholderName)) {\n                            return signerPerm.actor;\n                        }\n                        else if (value.equals(PlaceholderPermission)) {\n                            return signerPerm.permission;\n                        }\n                        else {\n                            return value;\n                        }\n                    }\n                    else if (Array.isArray(value)) {\n                        return value.map(resolve);\n                    }\n                    else if (typeof value === 'object' && value !== null) {\n                        for (const key of Object.keys(value)) {\n                            value[key] = resolve(value[key]);\n                        }\n                        return value;\n                    }\n                    else {\n                        return value;\n                    }\n                };\n                data = resolve(data);\n                authorization = authorization.map((auth) => {\n                    let { actor, permission } = auth;\n                    if (actor.equals(PlaceholderName)) {\n                        actor = signerPerm.actor;\n                    }\n                    if (permission.equals(PlaceholderPermission)) {\n                        permission = signerPerm.permission;\n                    }\n                    // backwards compatibility, actor placeholder will also resolve to permission when used in auth\n                    if (permission.equals(PlaceholderName)) {\n                        permission = signerPerm.permission;\n                    }\n                    return PermissionLevel.from({ actor, permission });\n                });\n            }\n            return {\n                ...rawAction,\n                authorization,\n                data,\n            };\n        });\n    }\n    resolveTransaction(abis, signer, ctx = {}) {\n        const tx = this.getRawTransaction();\n        if (!this.isIdentity() && !hasTapos(tx)) {\n            if (ctx.expiration !== undefined &&\n                ctx.ref_block_num !== undefined &&\n                ctx.ref_block_prefix !== undefined) {\n                tx.expiration = TimePointSec.from(ctx.expiration);\n                tx.ref_block_num = UInt16.from(ctx.ref_block_num);\n                tx.ref_block_prefix = UInt32.from(ctx.ref_block_prefix);\n            }\n            else if (ctx.block_num !== undefined &&\n                ctx.ref_block_prefix !== undefined &&\n                ctx.timestamp !== undefined) {\n                tx.expiration = expirationTime(ctx.timestamp, ctx.expire_seconds);\n                tx.ref_block_num = UInt16.from(ctx.block_num);\n                tx.ref_block_prefix = UInt32.from(ctx.ref_block_prefix);\n            }\n            else {\n                throw new Error('Invalid transaction context, need either a reference block or explicit TaPoS values');\n            }\n        }\n        else if (this.isIdentity() && this.version > 2) {\n            // From ESR version 3 all identity requests have expiration\n            tx.expiration = ctx.expiration\n                ? TimePointSec.from(ctx.expiration)\n                : expirationTime(ctx.timestamp, ctx.expire_seconds);\n        }\n        const actions = this.resolveActions(abis, signer);\n        // TODO: resolve context free actions\n        const context_free_actions = tx.context_free_actions;\n        return { ...tx, context_free_actions, actions };\n    }\n    resolve(abis, signer, ctx = {}) {\n        const tx = this.resolveTransaction(abis, signer, ctx);\n        const actions = tx.actions.map((action) => {\n            let abi;\n            if (isIdentity(action)) {\n                abi = this.constructor.identityAbi(this.version);\n            }\n            else {\n                abi = abis.get(action.account.toString());\n            }\n            if (!abi) {\n                throw new Error(`Missing ABI definition for ${action.account}`);\n            }\n            const type = abi.getActionType(action.name);\n            const data = Serializer.encode({ object: action.data, type, abi });\n            return Action.from({ ...action, data });\n        });\n        const transaction = Transaction.from({ ...tx, actions });\n        let chainId;\n        if (this.isMultiChain()) {\n            if (!ctx.chainId) {\n                throw new Error('Missing chosen chain ID for multi-chain request');\n            }\n            chainId = ChainId.from(ctx.chainId);\n            const ids = this.getChainIds();\n            if (ids && !ids.some((id) => chainId.equals(id))) {\n                throw new Error('Trying to resolve for chain ID not defined in request');\n            }\n        }\n        else {\n            chainId = this.getChainId();\n        }\n        return new ResolvedSigningRequest(this, PermissionLevel.from(signer), transaction, tx, chainId);\n    }\n    /**\n     * Get the id of the chain where this request is valid.\n     * @returns The 32-byte chain id as hex encoded string.\n     */\n    getChainId() {\n        return this.data.chain_id.chainId;\n    }\n    /**\n     * Chain IDs this request is valid for, only valid for multi chain requests. Value of `null` when `isMultiChain` is true denotes any chain.\n     */\n    getChainIds() {\n        if (!this.isMultiChain()) {\n            return null;\n        }\n        const ids = this.getInfoKey('chain_ids', { type: ChainIdVariant, array: true });\n        if (ids) {\n            return ids.map((id) => id.chainId);\n        }\n        return null;\n    }\n    /**\n     * Set chain IDs this request is valid for, only considered for multi chain requests.\n     */\n    setChainIds(ids) {\n        const value = ids.map((id) => ChainId.from(id).chainVariant);\n        this.setInfoKey('chain_ids', value, { type: ChainIdVariant, array: true });\n    }\n    /**\n     * True if chainId is set to chain alias `0` which indicates that the request is valid for any chain.\n     */\n    isMultiChain() {\n        return (this.data.chain_id.variantIdx === 0 &&\n            this.data.chain_id.value.value === ChainName.UNKNOWN);\n    }\n    /** Return the actions in this request with action data encoded. */\n    getRawActions() {\n        const req = this.data.req;\n        switch (req.variantName) {\n            case 'action':\n                return [req.value];\n            case 'action[]':\n                return req.value;\n            case 'identity': {\n                if (this.version === 2) {\n                    const id = req.value;\n                    let data = '0101000000000000000200000000000000'; // placeholder permission\n                    let authorization = [PlaceholderAuth];\n                    if (id.permission) {\n                        data = Serializer.encode({ object: id });\n                        authorization = [id.permission];\n                    }\n                    return [\n                        Action.from({\n                            account: '',\n                            name: 'identity',\n                            authorization,\n                            data,\n                        }),\n                    ];\n                }\n                else {\n                    // eslint-disable-next-line prefer-const\n                    let { scope, permission } = req.value;\n                    if (!permission) {\n                        permission = PlaceholderAuth;\n                    }\n                    const data = Serializer.encode({ object: { scope, permission }, type: IdentityV3 });\n                    return [\n                        Action.from({\n                            account: '',\n                            name: 'identity',\n                            authorization: [permission],\n                            data,\n                        }),\n                    ];\n                }\n            }\n            case 'transaction':\n                return req.value.actions;\n            default:\n                throw new Error('Invalid signing request data');\n        }\n    }\n    /** Unresolved transaction. */\n    getRawTransaction() {\n        const req = this.data.req;\n        switch (req.variantName) {\n            case 'transaction':\n                return Transaction.from({ ...req.value });\n            case 'action':\n            case 'action[]':\n            case 'identity':\n                return Transaction.from({\n                    actions: this.getRawActions(),\n                    context_free_actions: [],\n                    transaction_extensions: [],\n                    expiration: '1970-01-01T00:00:00.000',\n                    ref_block_num: 0,\n                    ref_block_prefix: 0,\n                    max_cpu_usage_ms: 0,\n                    max_net_usage_words: 0,\n                    delay_sec: 0,\n                });\n            default:\n                throw new Error('Invalid signing request data');\n        }\n    }\n    /** Whether the request is an identity request. */\n    isIdentity() {\n        return this.data.req.variantName === 'identity';\n    }\n    /** Whether the request should be broadcast by signer. */\n    shouldBroadcast() {\n        if (this.isIdentity()) {\n            return false;\n        }\n        return this.data.flags.broadcast;\n    }\n    /**\n     * Present if the request is an identity request and requests a specific account.\n     * @note This returns `nil` unless a specific identity has been requested,\n     *       use `isIdentity` to check id requests.\n     */\n    getIdentity() {\n        if (!this.isIdentity()) {\n            return null;\n        }\n        const id = this.data.req.value;\n        if (id.permission && !id.permission.actor.equals(PlaceholderName)) {\n            return id.permission.actor;\n        }\n        return null;\n    }\n    /**\n     * Present if the request is an identity request and requests a specific permission.\n     * @note This returns `nil` unless a specific permission has been requested,\n     *       use `isIdentity` to check id requests.\n     */\n    getIdentityPermission() {\n        if (!this.isIdentity()) {\n            return null;\n        }\n        const id = this.data.req.value;\n        if (id.permission && !id.permission.permission.equals(PlaceholderPermission)) {\n            return id.permission.permission;\n        }\n        return null;\n    }\n    /**\n     * Present if the request is an identity request and requests a specific permission.\n     * @note This returns `nil` unless a specific permission has been requested,\n     *       use `isIdentity` to check id requests.\n     */\n    getIdentityScope() {\n        if (!this.isIdentity() || this.version <= 2) {\n            return null;\n        }\n        const id = this.data.req.value;\n        return id.scope;\n    }\n    /** Get raw info dict */\n    getRawInfo() {\n        const rv = {};\n        for (const { key, value } of this.data.info) {\n            rv[key] = value;\n        }\n        return rv;\n    }\n    getRawInfoKey(key) {\n        const pair = this.data.info.find((pair) => pair.key === key);\n        if (pair) {\n            return pair.value;\n        }\n    }\n    setRawInfoKey(key, value) {\n        let pair = this.data.info.find((pair) => pair.key === key);\n        if (!pair) {\n            pair = InfoPair.from({ key, value });\n            this.data.info.push(pair);\n        }\n        else {\n            pair.value = Bytes.from(value);\n        }\n    }\n    /** Set a metadata key. */\n    setInfoKey(key, object, type) {\n        let data;\n        if (typeof object === 'string' && !type) {\n            // match old behavior where strings encode to raw utf8 as opposed to\n            // eosio-abi encoded strings (varuint32 length prefix + utf8 bytes)\n            data = Bytes.from(object, 'utf8');\n        }\n        else {\n            data = Serializer.encode({ object, type });\n        }\n        this.setRawInfoKey(key, data);\n    }\n    getInfoKey(key, type) {\n        const data = this.getRawInfoKey(key);\n        if (data) {\n            if (type) {\n                return Serializer.decode({ data, type });\n            }\n            else {\n                // assume utf8 string if no type is given\n                return data.utf8String;\n            }\n        }\n    }\n    /** Return a deep copy of this request. */\n    clone() {\n        let signature;\n        if (this.signature) {\n            signature = RequestSignature.from(JSON.parse(JSON.stringify(this.signature)));\n        }\n        const RequestData = this.constructor.storageType(this.version);\n        const data = RequestData.from(JSON.parse(JSON.stringify(this.data)));\n        return new SigningRequest(this.version, data, this.zlib, this.abiProvider, signature);\n    }\n    // Convenience methods.\n    toString() {\n        return this.encode();\n    }\n    toJSON() {\n        return this.encode();\n    }\n}\nclass ResolvedSigningRequest {\n    constructor(request, signer, transaction, resolvedTransaction, chainId) {\n        this.request = request;\n        this.signer = signer;\n        this.transaction = transaction;\n        this.resolvedTransaction = resolvedTransaction;\n        this.chainId = chainId;\n    }\n    /** Recreate a resolved request from a callback payload. */\n    static async fromPayload(payload, options = {}) {\n        const request = SigningRequest.from(payload.req, options);\n        const abis = await request.fetchAbis();\n        return request.resolve(abis, { actor: payload.sa, permission: payload.sp }, {\n            ref_block_num: payload.rbn,\n            ref_block_prefix: payload.rid,\n            expiration: payload.ex,\n            chainId: payload.cid || request.getChainId(),\n        });\n    }\n    get serializedTransaction() {\n        return Serializer.encode({ object: this.transaction }).array;\n    }\n    get signingDigest() {\n        return this.transaction.signingDigest(this.chainId);\n    }\n    getCallback(signatures, blockNum) {\n        const { callback, flags } = this.request.data;\n        if (!callback || callback.length === 0) {\n            return null;\n        }\n        if (!signatures || signatures.length === 0) {\n            throw new Error('Must have at least one signature to resolve callback');\n        }\n        const sigs = signatures.map((sig) => Signature.from(sig));\n        const payload = {\n            sig: String(sigs[0]),\n            tx: String(this.transaction.id),\n            rbn: String(this.transaction.ref_block_num),\n            rid: String(this.transaction.ref_block_prefix),\n            ex: String(this.transaction.expiration),\n            req: this.request.encode(),\n            sa: String(this.signer.actor),\n            sp: String(this.signer.permission),\n            cid: String(this.chainId),\n        };\n        for (const [n, sig] of sigs.slice(1).entries()) {\n            payload[`sig${n}`] = String(sig);\n        }\n        if (blockNum) {\n            payload.bn = String(UInt32.from(blockNum));\n        }\n        const url = callback.replace(/({{([a-z0-9]+)}})/g, (_1, _2, m) => {\n            return payload[m] || '';\n        });\n        return {\n            background: flags.background,\n            payload,\n            url,\n        };\n    }\n    getIdentityProof(signature) {\n        if (!this.request.isIdentity()) {\n            throw new Error('Not a identity request');\n        }\n        return IdentityProof.from({\n            chainId: this.chainId,\n            scope: this.request.getIdentityScope(),\n            expiration: this.transaction.expiration,\n            signer: this.signer,\n            signature,\n        });\n    }\n}\nfunction encodeAction(action, abis) {\n    if (Bytes.isBytes(action.data) || action.data.constructor.abiName !== undefined) {\n        return Action.from(action);\n    }\n    const abi = abis[String(Name.from(action.account))];\n    if (!abi) {\n        throw new Error(`Missing ABI for ${action.account}`);\n    }\n    return Action.from(action, abi);\n}\nfunction isIdentity(action) {\n    const account = Name.from(action.account);\n    const name = Name.from(action.name);\n    return account.rawValue.equals(0) && name.equals('identity');\n}\nfunction hasTapos(tx) {\n    return !(tx.expiration.value.value === 0 &&\n        tx.ref_block_num.value === 0 &&\n        tx.ref_block_prefix.value === 0);\n}\nfunction expirationTime(timestamp, expireSeconds = 60) {\n    const ts = TimePointSec.from(timestamp || new Date());\n    const exp = UInt32.from(expireSeconds);\n    return TimePointSec.fromMilliseconds(ts.toMilliseconds() + exp.value * 1000);\n}\n\nexport { AccountName, base64u as Base64u, ChainAlias, ChainId, ChainIdVariant, ChainName, IdentityProof, IdentityV2, IdentityV3, InfoPair, PermissionName, PlaceholderAuth, PlaceholderName, PlaceholderPermission, ProtocolVersion, RequestDataV2, RequestDataV3, RequestFlags, RequestSignature, RequestVariantV2, RequestVariantV3, ResolvedSigningRequest, SigningRequest };\n//# sourceMappingURL=esr.m.js.map\n"]},"metadata":{},"sourceType":"module"}