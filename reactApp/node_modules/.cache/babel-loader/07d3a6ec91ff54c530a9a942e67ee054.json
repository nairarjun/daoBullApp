{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Signature = void 0;\n\nvar BN = require(\"bn.js\");\n\nvar eosjs_numeric_1 = require(\"./eosjs-numeric\");\n\nvar eosjs_key_conversions_1 = require(\"./eosjs-key-conversions\");\n/** Represents/stores a Signature and provides easy conversion for use with `elliptic` lib */\n\n\nvar Signature =\n/** @class */\nfunction () {\n  function Signature(signature, ec) {\n    this.signature = signature;\n    this.ec = ec;\n  }\n  /** Instantiate Signature from an EOSIO-format Signature */\n\n\n  Signature.fromString = function (sig, ec) {\n    var signature = eosjs_numeric_1.stringToSignature(sig);\n\n    if (!ec) {\n      ec = eosjs_key_conversions_1.constructElliptic(signature.type);\n    }\n\n    return new Signature(signature, ec);\n  };\n  /** Instantiate Signature from an `elliptic`-format Signature */\n\n\n  Signature.fromElliptic = function (ellipticSig, keyType, ec) {\n    var r = ellipticSig.r.toArray('be', 32);\n    var s = ellipticSig.s.toArray('be', 32);\n    var eosioRecoveryParam;\n\n    if (keyType === eosjs_numeric_1.KeyType.k1 || keyType === eosjs_numeric_1.KeyType.r1) {\n      eosioRecoveryParam = ellipticSig.recoveryParam + 27;\n\n      if (ellipticSig.recoveryParam <= 3) {\n        eosioRecoveryParam += 4;\n      }\n    } else if (keyType === eosjs_numeric_1.KeyType.wa) {\n      eosioRecoveryParam = ellipticSig.recoveryParam;\n    }\n\n    var sigData = new Uint8Array([eosioRecoveryParam].concat(r, s));\n\n    if (!ec) {\n      ec = eosjs_key_conversions_1.constructElliptic(keyType);\n    }\n\n    return new Signature({\n      type: keyType,\n      data: sigData\n    }, ec);\n  };\n  /** Export Signature as `elliptic`-format Signature\n   * NOTE: This isn't an actual elliptic-format Signature, as ec.Signature is not exported by the library.\n   * That's also why the return type is `any`.  We're *actually* returning an object with the 3 params\n   * not an ec.Signature.\n   * Further NOTE: @types/elliptic shows ec.Signature as exported; it is *not*.  Hence the `any`.\n   */\n\n\n  Signature.prototype.toElliptic = function () {\n    var lengthOfR = 32;\n    var lengthOfS = 32;\n    var r = new BN(this.signature.data.slice(1, lengthOfR + 1));\n    var s = new BN(this.signature.data.slice(lengthOfR + 1, lengthOfR + lengthOfS + 1));\n    var ellipticRecoveryBitField;\n\n    if (this.signature.type === eosjs_numeric_1.KeyType.k1 || this.signature.type === eosjs_numeric_1.KeyType.r1) {\n      ellipticRecoveryBitField = this.signature.data[0] - 27;\n\n      if (ellipticRecoveryBitField > 3) {\n        ellipticRecoveryBitField -= 4;\n      }\n    } else if (this.signature.type === eosjs_numeric_1.KeyType.wa) {\n      ellipticRecoveryBitField = this.signature.data[0];\n    }\n\n    var recoveryParam = ellipticRecoveryBitField & 3;\n    return {\n      r: r,\n      s: s,\n      recoveryParam: recoveryParam\n    };\n  };\n  /** Export Signature as EOSIO-format Signature */\n\n\n  Signature.prototype.toString = function () {\n    return eosjs_numeric_1.signatureToString(this.signature);\n  };\n  /** Export Signature in binary format */\n\n\n  Signature.prototype.toBinary = function () {\n    return this.signature.data;\n  };\n  /** Get key type from signature */\n\n\n  Signature.prototype.getType = function () {\n    return this.signature.type;\n  };\n  /** Verify a signature with a message or hashed message digest and public key */\n\n\n  Signature.prototype.verify = function (data, publicKey, shouldHash, encoding) {\n    if (shouldHash === void 0) {\n      shouldHash = true;\n    }\n\n    if (encoding === void 0) {\n      encoding = 'utf8';\n    }\n\n    if (shouldHash) {\n      if (typeof data === 'string') {\n        data = Buffer.from(data, encoding);\n      }\n\n      data = this.ec.hash().update(data).digest();\n    }\n\n    var ellipticSignature = this.toElliptic();\n    var ellipticPublicKey = publicKey.toElliptic();\n    return this.ec.verify(data, ellipticSignature, ellipticPublicKey, encoding);\n  };\n  /** Recover a public key from a message or hashed message digest and signature */\n\n\n  Signature.prototype.recover = function (data, shouldHash, encoding) {\n    if (shouldHash === void 0) {\n      shouldHash = true;\n    }\n\n    if (encoding === void 0) {\n      encoding = 'utf8';\n    }\n\n    if (shouldHash) {\n      if (typeof data === 'string') {\n        data = Buffer.from(data, encoding);\n      }\n\n      data = this.ec.hash().update(data).digest();\n    }\n\n    var ellipticSignature = this.toElliptic();\n    var recoveredPublicKey = this.ec.recoverPubKey(data, ellipticSignature, ellipticSignature.recoveryParam, encoding);\n    var ellipticKPub = this.ec.keyFromPublic(recoveredPublicKey);\n    return eosjs_key_conversions_1.PublicKey.fromElliptic(ellipticKPub, this.getType(), this.ec);\n  };\n\n  return Signature;\n}();\n\nexports.Signature = Signature;","map":{"version":3,"sources":["../src/Signature.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Signature = void 0;\nvar BN = require(\"bn.js\");\nvar eosjs_numeric_1 = require(\"./eosjs-numeric\");\nvar eosjs_key_conversions_1 = require(\"./eosjs-key-conversions\");\n/** Represents/stores a Signature and provides easy conversion for use with `elliptic` lib */\nvar Signature = /** @class */ (function () {\n    function Signature(signature, ec) {\n        this.signature = signature;\n        this.ec = ec;\n    }\n    /** Instantiate Signature from an EOSIO-format Signature */\n    Signature.fromString = function (sig, ec) {\n        var signature = eosjs_numeric_1.stringToSignature(sig);\n        if (!ec) {\n            ec = eosjs_key_conversions_1.constructElliptic(signature.type);\n        }\n        return new Signature(signature, ec);\n    };\n    /** Instantiate Signature from an `elliptic`-format Signature */\n    Signature.fromElliptic = function (ellipticSig, keyType, ec) {\n        var r = ellipticSig.r.toArray('be', 32);\n        var s = ellipticSig.s.toArray('be', 32);\n        var eosioRecoveryParam;\n        if (keyType === eosjs_numeric_1.KeyType.k1 || keyType === eosjs_numeric_1.KeyType.r1) {\n            eosioRecoveryParam = ellipticSig.recoveryParam + 27;\n            if (ellipticSig.recoveryParam <= 3) {\n                eosioRecoveryParam += 4;\n            }\n        }\n        else if (keyType === eosjs_numeric_1.KeyType.wa) {\n            eosioRecoveryParam = ellipticSig.recoveryParam;\n        }\n        var sigData = new Uint8Array([eosioRecoveryParam].concat(r, s));\n        if (!ec) {\n            ec = eosjs_key_conversions_1.constructElliptic(keyType);\n        }\n        return new Signature({\n            type: keyType,\n            data: sigData,\n        }, ec);\n    };\n    /** Export Signature as `elliptic`-format Signature\n     * NOTE: This isn't an actual elliptic-format Signature, as ec.Signature is not exported by the library.\n     * That's also why the return type is `any`.  We're *actually* returning an object with the 3 params\n     * not an ec.Signature.\n     * Further NOTE: @types/elliptic shows ec.Signature as exported; it is *not*.  Hence the `any`.\n     */\n    Signature.prototype.toElliptic = function () {\n        var lengthOfR = 32;\n        var lengthOfS = 32;\n        var r = new BN(this.signature.data.slice(1, lengthOfR + 1));\n        var s = new BN(this.signature.data.slice(lengthOfR + 1, lengthOfR + lengthOfS + 1));\n        var ellipticRecoveryBitField;\n        if (this.signature.type === eosjs_numeric_1.KeyType.k1 || this.signature.type === eosjs_numeric_1.KeyType.r1) {\n            ellipticRecoveryBitField = this.signature.data[0] - 27;\n            if (ellipticRecoveryBitField > 3) {\n                ellipticRecoveryBitField -= 4;\n            }\n        }\n        else if (this.signature.type === eosjs_numeric_1.KeyType.wa) {\n            ellipticRecoveryBitField = this.signature.data[0];\n        }\n        var recoveryParam = ellipticRecoveryBitField & 3;\n        return { r: r, s: s, recoveryParam: recoveryParam };\n    };\n    /** Export Signature as EOSIO-format Signature */\n    Signature.prototype.toString = function () {\n        return eosjs_numeric_1.signatureToString(this.signature);\n    };\n    /** Export Signature in binary format */\n    Signature.prototype.toBinary = function () {\n        return this.signature.data;\n    };\n    /** Get key type from signature */\n    Signature.prototype.getType = function () {\n        return this.signature.type;\n    };\n    /** Verify a signature with a message or hashed message digest and public key */\n    Signature.prototype.verify = function (data, publicKey, shouldHash, encoding) {\n        if (shouldHash === void 0) { shouldHash = true; }\n        if (encoding === void 0) { encoding = 'utf8'; }\n        if (shouldHash) {\n            if (typeof data === 'string') {\n                data = Buffer.from(data, encoding);\n            }\n            data = this.ec.hash().update(data).digest();\n        }\n        var ellipticSignature = this.toElliptic();\n        var ellipticPublicKey = publicKey.toElliptic();\n        return this.ec.verify(data, ellipticSignature, ellipticPublicKey, encoding);\n    };\n    /** Recover a public key from a message or hashed message digest and signature */\n    Signature.prototype.recover = function (data, shouldHash, encoding) {\n        if (shouldHash === void 0) { shouldHash = true; }\n        if (encoding === void 0) { encoding = 'utf8'; }\n        if (shouldHash) {\n            if (typeof data === 'string') {\n                data = Buffer.from(data, encoding);\n            }\n            data = this.ec.hash().update(data).digest();\n        }\n        var ellipticSignature = this.toElliptic();\n        var recoveredPublicKey = this.ec.recoverPubKey(data, ellipticSignature, ellipticSignature.recoveryParam, encoding);\n        var ellipticKPub = this.ec.keyFromPublic(recoveredPublicKey);\n        return eosjs_key_conversions_1.PublicKey.fromElliptic(ellipticKPub, this.getType(), this.ec);\n    };\n    return Signature;\n}());\nexports.Signature = Signature;\n//# sourceMappingURL=Signature.js.map"]},"metadata":{},"sourceType":"script"}