{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PrivateKey = void 0;\n\nvar eosjs_numeric_1 = require(\"./eosjs-numeric\");\n\nvar eosjs_key_conversions_1 = require(\"./eosjs-key-conversions\");\n/** Represents/stores a private key and provides easy conversion for use with `elliptic` lib */\n\n\nvar PrivateKey =\n/** @class */\nfunction () {\n  function PrivateKey(key, ec) {\n    this.key = key;\n    this.ec = ec;\n  }\n  /** Instantiate private key from an `elliptic`-format private key */\n\n\n  PrivateKey.fromElliptic = function (privKey, keyType, ec) {\n    if (!ec) {\n      ec = eosjs_key_conversions_1.constructElliptic(keyType);\n    }\n\n    return new PrivateKey({\n      type: keyType,\n      data: privKey.getPrivate().toArrayLike(Buffer, 'be', 32)\n    }, ec);\n  };\n  /** Instantiate private key from an EOSIO-format private key */\n\n\n  PrivateKey.fromString = function (keyString, ec) {\n    var privateKey = eosjs_numeric_1.stringToPrivateKey(keyString);\n\n    if (!ec) {\n      ec = eosjs_key_conversions_1.constructElliptic(privateKey.type);\n    }\n\n    return new PrivateKey(privateKey, ec);\n  };\n  /** Export private key as `elliptic`-format private key */\n\n\n  PrivateKey.prototype.toElliptic = function () {\n    return this.ec.keyFromPrivate(this.key.data);\n  };\n\n  PrivateKey.prototype.toLegacyString = function () {\n    return eosjs_numeric_1.privateKeyToLegacyString(this.key);\n  };\n  /** Export private key as EOSIO-format private key */\n\n\n  PrivateKey.prototype.toString = function () {\n    return eosjs_numeric_1.privateKeyToString(this.key);\n  };\n  /** Get key type from key */\n\n\n  PrivateKey.prototype.getType = function () {\n    return this.key.type;\n  };\n  /** Retrieve the public key from a private key */\n\n\n  PrivateKey.prototype.getPublicKey = function () {\n    var ellipticPrivateKey = this.toElliptic();\n    return eosjs_key_conversions_1.PublicKey.fromElliptic(ellipticPrivateKey, this.getType(), this.ec);\n  };\n  /** Sign a message or hashed message digest with private key */\n\n\n  PrivateKey.prototype.sign = function (data, shouldHash, encoding) {\n    var _this = this;\n\n    if (shouldHash === void 0) {\n      shouldHash = true;\n    }\n\n    if (encoding === void 0) {\n      encoding = 'utf8';\n    }\n\n    if (shouldHash) {\n      if (typeof data === 'string') {\n        data = Buffer.from(data, encoding);\n      }\n\n      data = this.ec.hash().update(data).digest();\n    }\n\n    var tries = 0;\n    var signature;\n\n    var isCanonical = function (sigData) {\n      return !(sigData[1] & 0x80) && !(sigData[1] === 0 && !(sigData[2] & 0x80)) && !(sigData[33] & 0x80) && !(sigData[33] === 0 && !(sigData[34] & 0x80));\n    };\n\n    var constructSignature = function (options) {\n      var ellipticPrivateKey = _this.toElliptic();\n\n      var ellipticSignature = ellipticPrivateKey.sign(data, options);\n      return eosjs_key_conversions_1.Signature.fromElliptic(ellipticSignature, _this.getType(), _this.ec);\n    };\n\n    if (this.key.type === eosjs_numeric_1.KeyType.k1) {\n      do {\n        signature = constructSignature({\n          canonical: true,\n          pers: [++tries]\n        });\n      } while (!isCanonical(signature.toBinary()));\n    } else {\n      signature = constructSignature({\n        canonical: true\n      });\n    }\n\n    return signature;\n  };\n  /** Validate a private key */\n\n\n  PrivateKey.prototype.isValid = function () {\n    try {\n      var ellipticPrivateKey = this.toElliptic();\n      var validationObj = ellipticPrivateKey.validate();\n      return validationObj.result;\n    } catch (_a) {\n      return false;\n    }\n  };\n\n  return PrivateKey;\n}();\n\nexports.PrivateKey = PrivateKey;","map":{"version":3,"sources":["../src/PrivateKey.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PrivateKey = void 0;\nvar eosjs_numeric_1 = require(\"./eosjs-numeric\");\nvar eosjs_key_conversions_1 = require(\"./eosjs-key-conversions\");\n/** Represents/stores a private key and provides easy conversion for use with `elliptic` lib */\nvar PrivateKey = /** @class */ (function () {\n    function PrivateKey(key, ec) {\n        this.key = key;\n        this.ec = ec;\n    }\n    /** Instantiate private key from an `elliptic`-format private key */\n    PrivateKey.fromElliptic = function (privKey, keyType, ec) {\n        if (!ec) {\n            ec = eosjs_key_conversions_1.constructElliptic(keyType);\n        }\n        return new PrivateKey({\n            type: keyType,\n            data: privKey.getPrivate().toArrayLike(Buffer, 'be', 32),\n        }, ec);\n    };\n    /** Instantiate private key from an EOSIO-format private key */\n    PrivateKey.fromString = function (keyString, ec) {\n        var privateKey = eosjs_numeric_1.stringToPrivateKey(keyString);\n        if (!ec) {\n            ec = eosjs_key_conversions_1.constructElliptic(privateKey.type);\n        }\n        return new PrivateKey(privateKey, ec);\n    };\n    /** Export private key as `elliptic`-format private key */\n    PrivateKey.prototype.toElliptic = function () {\n        return this.ec.keyFromPrivate(this.key.data);\n    };\n    PrivateKey.prototype.toLegacyString = function () {\n        return eosjs_numeric_1.privateKeyToLegacyString(this.key);\n    };\n    /** Export private key as EOSIO-format private key */\n    PrivateKey.prototype.toString = function () {\n        return eosjs_numeric_1.privateKeyToString(this.key);\n    };\n    /** Get key type from key */\n    PrivateKey.prototype.getType = function () {\n        return this.key.type;\n    };\n    /** Retrieve the public key from a private key */\n    PrivateKey.prototype.getPublicKey = function () {\n        var ellipticPrivateKey = this.toElliptic();\n        return eosjs_key_conversions_1.PublicKey.fromElliptic(ellipticPrivateKey, this.getType(), this.ec);\n    };\n    /** Sign a message or hashed message digest with private key */\n    PrivateKey.prototype.sign = function (data, shouldHash, encoding) {\n        var _this = this;\n        if (shouldHash === void 0) { shouldHash = true; }\n        if (encoding === void 0) { encoding = 'utf8'; }\n        if (shouldHash) {\n            if (typeof data === 'string') {\n                data = Buffer.from(data, encoding);\n            }\n            data = this.ec.hash().update(data).digest();\n        }\n        var tries = 0;\n        var signature;\n        var isCanonical = function (sigData) {\n            return !(sigData[1] & 0x80) && !(sigData[1] === 0 && !(sigData[2] & 0x80))\n                && !(sigData[33] & 0x80) && !(sigData[33] === 0 && !(sigData[34] & 0x80));\n        };\n        var constructSignature = function (options) {\n            var ellipticPrivateKey = _this.toElliptic();\n            var ellipticSignature = ellipticPrivateKey.sign(data, options);\n            return eosjs_key_conversions_1.Signature.fromElliptic(ellipticSignature, _this.getType(), _this.ec);\n        };\n        if (this.key.type === eosjs_numeric_1.KeyType.k1) {\n            do {\n                signature = constructSignature({ canonical: true, pers: [++tries] });\n            } while (!isCanonical(signature.toBinary()));\n        }\n        else {\n            signature = constructSignature({ canonical: true });\n        }\n        return signature;\n    };\n    /** Validate a private key */\n    PrivateKey.prototype.isValid = function () {\n        try {\n            var ellipticPrivateKey = this.toElliptic();\n            var validationObj = ellipticPrivateKey.validate();\n            return validationObj.result;\n        }\n        catch (_a) {\n            return false;\n        }\n    };\n    return PrivateKey;\n}());\nexports.PrivateKey = PrivateKey;\n//# sourceMappingURL=PrivateKey.js.map"]},"metadata":{},"sourceType":"script"}