{"ast":null,"code":"import _objectSpread from \"/home/turbo/devel/MyGame/contracts/decentralize-io-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _regeneratorRuntime from \"/home/turbo/devel/MyGame/contracts/decentralize-io-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/turbo/devel/MyGame/contracts/decentralize-io-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"/home/turbo/devel/MyGame/contracts/decentralize-io-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"/home/turbo/devel/MyGame/contracts/decentralize-io-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/home/turbo/devel/MyGame/contracts/decentralize-io-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/turbo/devel/MyGame/contracts/decentralize-io-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/home/turbo/devel/MyGame/contracts/decentralize-io-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/home/turbo/devel/MyGame/contracts/decentralize-io-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/turbo/devel/MyGame/contracts/decentralize-io-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/turbo/devel/MyGame/contracts/decentralize-io-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\n * EOSIO Signing Request v2.2.0\n * https://github.com/greymass/eosio-signing-request\n *\n * @license\n * Copyright © 2021 Greymass Inc.\n * \n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the “Software”), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n * \n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n * \n * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR\n * INTENDED FOR USE IN THE DESIGN, CONSTRUCTION, OPERATION OR\n * MAINTENANCE OF ANY MILITARY FACILITY.\n */\nimport { Checksum256, TypeAlias, UInt8, Variant, Name, Struct, PermissionLevel, Action, Transaction, isInstanceOf, Serializer, TimePointSec, Authority, Signature, Bytes, ABIEncoder, ABIDecoder, ABI, UInt16, UInt32 } from '@greymass/eosio';\nimport { __decorate } from 'tslib';\n/**\n * Base64u - URL-Safe Base64 variant no padding.\n * Based on https://gist.github.com/jonleighton/958841\n */\n\nvar baseCharset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nvar lookup = new Uint8Array(256);\n\nfor (var i = 0; i < 62; i++) {\n  lookup[baseCharset.charCodeAt(i)] = i;\n} // support both urlsafe and standard base64\n\n\nlookup[43] = lookup[45] = 62;\nlookup[47] = lookup[95] = 63;\n\nfunction _encode(data) {\n  var urlSafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var byteLength = data.byteLength;\n  var byteRemainder = byteLength % 3;\n  var mainLength = byteLength - byteRemainder;\n  var charset = baseCharset + (urlSafe ? '-_' : '+/');\n  var parts = [];\n  var a;\n  var b;\n  var c;\n  var d;\n  var chunk; // Main loop deals with bytes in chunks of 3\n\n  for (var _i = 0; _i < mainLength; _i += 3) {\n    // Combine the three bytes into a single integer\n    chunk = data[_i] << 16 | data[_i + 1] << 8 | data[_i + 2]; // Use bitmasks to extract 6-bit segments from the triplet\n\n    a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\n\n    b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\n\n    c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\n\n    d = chunk & 63; // 63       =  2^6 - 1\n    // Convert the raw binary segments to the appropriate ASCII encoding\n\n    parts.push(charset[a] + charset[b] + charset[c] + charset[d]);\n  } // Deal with the remaining bytes\n\n\n  if (byteRemainder === 1) {\n    chunk = data[mainLength];\n    a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\n    // Set the 4 least significant bits to zero\n\n    b = (chunk & 3) << 4; // 3   = 2^2 - 1\n\n    parts.push(charset[a] + charset[b]);\n  } else if (byteRemainder === 2) {\n    chunk = data[mainLength] << 8 | data[mainLength + 1];\n    a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\n\n    b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\n    // Set the 2 least significant bits to zero\n\n    c = (chunk & 15) << 2; // 15    = 2^4 - 1\n\n    parts.push(charset[a] + charset[b] + charset[c]);\n  }\n\n  return parts.join('');\n}\n\nfunction decode(input) {\n  var byteLength = input.length * 0.75;\n  var data = new Uint8Array(byteLength);\n  var a;\n  var b;\n  var c;\n  var d;\n  var p = 0;\n\n  for (var _i2 = 0; _i2 < input.length; _i2 += 4) {\n    a = lookup[input.charCodeAt(_i2)];\n    b = lookup[input.charCodeAt(_i2 + 1)];\n    c = lookup[input.charCodeAt(_i2 + 2)];\n    d = lookup[input.charCodeAt(_i2 + 3)];\n    data[p++] = a << 2 | b >> 4;\n    data[p++] = (b & 15) << 4 | c >> 2;\n    data[p++] = (c & 3) << 6 | d & 63;\n  }\n\n  return data;\n}\n\nvar base64u = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  encode: _encode,\n  decode: decode\n});\n/** Chain ID aliases. */\n\nvar ChainName;\n\n(function (ChainName) {\n  ChainName[ChainName[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  ChainName[ChainName[\"EOS\"] = 1] = \"EOS\";\n  ChainName[ChainName[\"TELOS\"] = 2] = \"TELOS\";\n  ChainName[ChainName[\"JUNGLE\"] = 3] = \"JUNGLE\";\n  ChainName[ChainName[\"KYLIN\"] = 4] = \"KYLIN\";\n  ChainName[ChainName[\"WORBLI\"] = 5] = \"WORBLI\";\n  ChainName[ChainName[\"BOS\"] = 6] = \"BOS\";\n  ChainName[ChainName[\"MEETONE\"] = 7] = \"MEETONE\";\n  ChainName[ChainName[\"INSIGHTS\"] = 8] = \"INSIGHTS\";\n  ChainName[ChainName[\"BEOS\"] = 9] = \"BEOS\";\n  ChainName[ChainName[\"WAX\"] = 10] = \"WAX\";\n  ChainName[ChainName[\"PROTON\"] = 11] = \"PROTON\";\n  ChainName[ChainName[\"FIO\"] = 12] = \"FIO\";\n})(ChainName || (ChainName = {}));\n\nvar ChainId = /*#__PURE__*/function (_Checksum) {\n  _inherits(ChainId, _Checksum);\n\n  var _super = _createSuper(ChainId);\n\n  function ChainId() {\n    _classCallCheck(this, ChainId);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ChainId, [{\n    key: \"chainVariant\",\n    get: function get() {\n      var name = this.chainName;\n\n      if (name !== ChainName.UNKNOWN) {\n        return ChainIdVariant.from(['chain_alias', name]);\n      }\n\n      return ChainIdVariant.from(this);\n    }\n  }, {\n    key: \"chainName\",\n    get: function get() {\n      var cid = this.hexString;\n\n      var _iterator = _createForOfIteratorHelper(ChainIdLookup),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              n = _step$value[0],\n              id = _step$value[1];\n\n          if (id === cid) {\n            return n;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return ChainName.UNKNOWN;\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      if (value instanceof this) {\n        return value;\n      }\n\n      if (typeof value === 'number') {\n        value = ChainIdLookup.get(value);\n\n        if (!value) {\n          throw new Error('Unknown chain id alias');\n        }\n      }\n\n      return _get(_getPrototypeOf(ChainId), \"from\", this).call(this, value);\n    }\n  }]);\n\n  return ChainId;\n}(Checksum256);\n\nChainId = __decorate([TypeAlias('chain_id')], ChainId);\n\nvar ChainAlias = /*#__PURE__*/function (_UInt) {\n  _inherits(ChainAlias, _UInt);\n\n  var _super2 = _createSuper(ChainAlias);\n\n  function ChainAlias() {\n    _classCallCheck(this, ChainAlias);\n\n    return _super2.apply(this, arguments);\n  }\n\n  return ChainAlias;\n}(UInt8);\n\nChainAlias = __decorate([TypeAlias('chain_alias')], ChainAlias);\n\nvar ChainIdVariant = /*#__PURE__*/function (_Variant) {\n  _inherits(ChainIdVariant, _Variant);\n\n  var _super3 = _createSuper(ChainIdVariant);\n\n  function ChainIdVariant() {\n    _classCallCheck(this, ChainIdVariant);\n\n    return _super3.apply(this, arguments);\n  }\n\n  _createClass(ChainIdVariant, [{\n    key: \"chainId\",\n    get: function get() {\n      if (this.value instanceof ChainId) {\n        return this.value;\n      }\n\n      return ChainId.from(this.value.value);\n    }\n  }]);\n\n  return ChainIdVariant;\n}(Variant);\n\nChainIdVariant = __decorate([Variant.type('variant_id', [ChainAlias, ChainId])], ChainIdVariant);\nvar ChainIdLookup = new Map([[ChainName.EOS, 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906'], [ChainName.TELOS, '4667b205c6838ef70ff7988f6e8257e8be0e1284a2f59699054a018f743b1d11'], [ChainName.JUNGLE, 'e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473'], [ChainName.KYLIN, '5fff1dae8dc8e2fc4d5b23b2c7665c97f9e9d8edf2b6485a86ba311c25639191'], [ChainName.WORBLI, '73647cde120091e0a4b85bced2f3cfdb3041e266cbbe95cee59b73235a1b3b6f'], [ChainName.BOS, 'd5a3d18fbb3c084e3b1f3fa98c21014b5f3db536cc15d08f9f6479517c6a3d86'], [ChainName.MEETONE, 'cfe6486a83bad4962f232d48003b1824ab5665c36778141034d75e57b956e422'], [ChainName.INSIGHTS, 'b042025541e25a472bffde2d62edd457b7e70cee943412b1ea0f044f88591664'], [ChainName.BEOS, 'b912d19a6abd2b1b05611ae5be473355d64d95aeff0c09bedc8c166cd6468fe4'], [ChainName.WAX, '1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4'], [ChainName.PROTON, '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0'], [ChainName.FIO, '21dcae42c0182200e93f954a074011f9048a7624c6fe81d3c9541a614a88bd1c']]);\n/** SigningRequest ABI and typedefs. */\n\nvar RequestFlags_1;\n\nvar AccountName = /*#__PURE__*/function (_Name) {\n  _inherits(AccountName, _Name);\n\n  var _super4 = _createSuper(AccountName);\n\n  function AccountName() {\n    _classCallCheck(this, AccountName);\n\n    return _super4.apply(this, arguments);\n  }\n\n  return AccountName;\n}(Name);\n\nAccountName = __decorate([TypeAlias('account_name')], AccountName);\n\nvar PermissionName = /*#__PURE__*/function (_Name2) {\n  _inherits(PermissionName, _Name2);\n\n  var _super5 = _createSuper(PermissionName);\n\n  function PermissionName() {\n    _classCallCheck(this, PermissionName);\n\n    return _super5.apply(this, arguments);\n  }\n\n  return PermissionName;\n}(Name);\n\nPermissionName = __decorate([TypeAlias('permission_name')], PermissionName);\n\nvar IdentityV2 = /*#__PURE__*/function (_Struct) {\n  _inherits(IdentityV2, _Struct);\n\n  var _super6 = _createSuper(IdentityV2);\n\n  function IdentityV2() {\n    _classCallCheck(this, IdentityV2);\n\n    return _super6.apply(this, arguments);\n  }\n\n  return IdentityV2;\n}(Struct);\n\n__decorate([Struct.field(PermissionLevel, {\n  optional: true\n})], IdentityV2.prototype, \"permission\", void 0);\n\nIdentityV2 = __decorate([Struct.type('identity')], IdentityV2);\n\nvar IdentityV3 = /*#__PURE__*/function (_Struct2) {\n  _inherits(IdentityV3, _Struct2);\n\n  var _super7 = _createSuper(IdentityV3);\n\n  function IdentityV3() {\n    _classCallCheck(this, IdentityV3);\n\n    return _super7.apply(this, arguments);\n  }\n\n  return IdentityV3;\n}(Struct);\n\n__decorate([Struct.field('name')], IdentityV3.prototype, \"scope\", void 0);\n\n__decorate([Struct.field(PermissionLevel, {\n  optional: true\n})], IdentityV3.prototype, \"permission\", void 0);\n\nIdentityV3 = __decorate([Struct.type('identity')], IdentityV3);\n\nvar RequestVariantV2 = /*#__PURE__*/function (_Variant2) {\n  _inherits(RequestVariantV2, _Variant2);\n\n  var _super8 = _createSuper(RequestVariantV2);\n\n  function RequestVariantV2() {\n    _classCallCheck(this, RequestVariantV2);\n\n    return _super8.apply(this, arguments);\n  }\n\n  return RequestVariantV2;\n}(Variant);\n\nRequestVariantV2 = __decorate([Variant.type('variant_req', [Action, {\n  type: Action,\n  array: true\n}, Transaction, IdentityV2])], RequestVariantV2);\n\nvar RequestVariantV3 = /*#__PURE__*/function (_Variant3) {\n  _inherits(RequestVariantV3, _Variant3);\n\n  var _super9 = _createSuper(RequestVariantV3);\n\n  function RequestVariantV3() {\n    _classCallCheck(this, RequestVariantV3);\n\n    return _super9.apply(this, arguments);\n  }\n\n  return RequestVariantV3;\n}(Variant);\n\nRequestVariantV3 = __decorate([Variant.type('variant_req', [Action, {\n  type: Action,\n  array: true\n}, Transaction, IdentityV3])], RequestVariantV3);\n\nvar RequestFlags = RequestFlags_1 = /*#__PURE__*/function (_UInt2) {\n  _inherits(RequestFlags, _UInt2);\n\n  var _super10 = _createSuper(RequestFlags);\n\n  function RequestFlags() {\n    _classCallCheck(this, RequestFlags);\n\n    return _super10.apply(this, arguments);\n  }\n\n  _createClass(RequestFlags, [{\n    key: \"broadcast\",\n    get: function get() {\n      return (this.value & RequestFlags_1.broadcast) !== 0;\n    },\n    set: function set(enabled) {\n      this.setFlag(RequestFlags_1.broadcast, enabled);\n    }\n  }, {\n    key: \"background\",\n    get: function get() {\n      return (this.value & RequestFlags_1.background) !== 0;\n    },\n    set: function set(enabled) {\n      this.setFlag(RequestFlags_1.background, enabled);\n    }\n  }, {\n    key: \"setFlag\",\n    value: function setFlag(flag, enabled) {\n      if (enabled) {\n        this.value |= flag;\n      } else {\n        this.value &= ~flag;\n      }\n    }\n  }]);\n\n  return RequestFlags;\n}(UInt8);\n\nRequestFlags.broadcast = 1 << 0;\nRequestFlags.background = 1 << 1;\nRequestFlags = RequestFlags_1 = __decorate([TypeAlias('request_flags')], RequestFlags);\n\nvar InfoPair = /*#__PURE__*/function (_Struct3) {\n  _inherits(InfoPair, _Struct3);\n\n  var _super11 = _createSuper(InfoPair);\n\n  function InfoPair() {\n    _classCallCheck(this, InfoPair);\n\n    return _super11.apply(this, arguments);\n  }\n\n  return InfoPair;\n}(Struct);\n\n__decorate([Struct.field('string')], InfoPair.prototype, \"key\", void 0);\n\n__decorate([Struct.field('bytes')], InfoPair.prototype, \"value\", void 0);\n\nInfoPair = __decorate([Struct.type('info_pair')], InfoPair);\n\nvar RequestDataV2 = /*#__PURE__*/function (_Struct4) {\n  _inherits(RequestDataV2, _Struct4);\n\n  var _super12 = _createSuper(RequestDataV2);\n\n  function RequestDataV2() {\n    _classCallCheck(this, RequestDataV2);\n\n    return _super12.apply(this, arguments);\n  }\n\n  return RequestDataV2;\n}(Struct);\n\n__decorate([Struct.field(ChainIdVariant)], RequestDataV2.prototype, \"chain_id\", void 0);\n\n__decorate([Struct.field(RequestVariantV2)], RequestDataV2.prototype, \"req\", void 0);\n\n__decorate([Struct.field(RequestFlags)], RequestDataV2.prototype, \"flags\", void 0);\n\n__decorate([Struct.field('string')], RequestDataV2.prototype, \"callback\", void 0);\n\n__decorate([Struct.field(InfoPair, {\n  array: true\n})], RequestDataV2.prototype, \"info\", void 0);\n\nRequestDataV2 = __decorate([Struct.type('signing_request')], RequestDataV2);\n\nvar RequestDataV3 = /*#__PURE__*/function (_Struct5) {\n  _inherits(RequestDataV3, _Struct5);\n\n  var _super13 = _createSuper(RequestDataV3);\n\n  function RequestDataV3() {\n    _classCallCheck(this, RequestDataV3);\n\n    return _super13.apply(this, arguments);\n  }\n\n  return RequestDataV3;\n}(Struct);\n\n__decorate([Struct.field(ChainIdVariant)], RequestDataV3.prototype, \"chain_id\", void 0);\n\n__decorate([Struct.field(RequestVariantV3)], RequestDataV3.prototype, \"req\", void 0);\n\n__decorate([Struct.field(RequestFlags)], RequestDataV3.prototype, \"flags\", void 0);\n\n__decorate([Struct.field('string')], RequestDataV3.prototype, \"callback\", void 0);\n\n__decorate([Struct.field(InfoPair, {\n  array: true\n})], RequestDataV3.prototype, \"info\", void 0);\n\nRequestDataV3 = __decorate([Struct.type('signing_request')], RequestDataV3);\n\nvar RequestSignature = /*#__PURE__*/function (_Struct6) {\n  _inherits(RequestSignature, _Struct6);\n\n  var _super14 = _createSuper(RequestSignature);\n\n  function RequestSignature() {\n    _classCallCheck(this, RequestSignature);\n\n    return _super14.apply(this, arguments);\n  }\n\n  return RequestSignature;\n}(Struct);\n\n__decorate([Struct.field('name')], RequestSignature.prototype, \"signer\", void 0);\n\n__decorate([Struct.field('signature')], RequestSignature.prototype, \"signature\", void 0);\n\nRequestSignature = __decorate([Struct.type('request_signature')], RequestSignature);\nvar IdentityProof_1;\n\nvar IdentityProof = IdentityProof_1 = /*#__PURE__*/function (_Struct7) {\n  _inherits(IdentityProof, _Struct7);\n\n  var _super15 = _createSuper(IdentityProof);\n\n  function IdentityProof() {\n    _classCallCheck(this, IdentityProof);\n\n    return _super15.apply(this, arguments);\n  }\n\n  _createClass(IdentityProof, [{\n    key: \"transaction\",\n    get:\n    /**\n     * Transaction this proof resolves to.\n     * @internal\n     */\n    function get() {\n      var action = Action.from({\n        account: '',\n        name: 'identity',\n        authorization: [this.signer],\n        data: IdentityV3.from({\n          scope: this.scope,\n          permission: this.signer\n        })\n      });\n      return Transaction.from({\n        ref_block_num: 0,\n        ref_block_prefix: 0,\n        expiration: this.expiration,\n        actions: [action]\n      });\n    }\n    /**\n     * Recover the public key that signed this proof.\n     */\n\n  }, {\n    key: \"recover\",\n    value: function recover() {\n      return this.signature.recoverDigest(this.transaction.signingDigest(this.chainId));\n    }\n    /**\n     * Verify that given authority signed this proof.\n     * @param auth The accounts signing authority.\n     * @param currentTime Time to verify expiry against, if unset will use system time.\n     */\n\n  }, {\n    key: \"verify\",\n    value: function verify(auth, currentTime) {\n      var now = TimePointSec.from(currentTime || new Date()).toMilliseconds();\n      return now < this.expiration.toMilliseconds() && Authority.from(auth).hasPermission(this.recover());\n    }\n    /**\n     * Encode the proof to an `EOSIO` auth header string.\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var data = Serializer.encode({\n        object: this\n      });\n      return \"EOSIO \".concat(_encode(data.array, false));\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      if (isInstanceOf(value, IdentityProof_1)) {\n        return value;\n      } else if (typeof value === 'string') {\n        return IdentityProof_1.fromString(value);\n      } else {\n        return _get(_getPrototypeOf(IdentityProof), \"from\", this).call(this, value);\n      }\n    }\n    /**\n     * Create a new instance from an EOSIO authorization header string.\n     * \"EOSIO <base64payload>\"\n     */\n\n  }, {\n    key: \"fromString\",\n    value: function fromString(string) {\n      var parts = string.split(' ');\n\n      if (parts.length !== 2 || parts[0] !== 'EOSIO') {\n        throw new Error('Invalid IdentityProof string');\n      }\n\n      var data = decode(parts[1]);\n      return Serializer.decode({\n        data: data,\n        type: IdentityProof_1\n      });\n    }\n    /** Create a new instance from a callback payload. */\n\n  }, {\n    key: \"fromPayload\",\n    value: function fromPayload(payload) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var request = SigningRequest.from(payload.req, options);\n\n      if (!(request.version >= 3 && request.isIdentity())) {\n        throw new Error('Not an identity request');\n      }\n\n      return this.from({\n        chainId: payload.cid || request.getChainId(),\n        scope: request.getIdentityScope(),\n        expiration: payload.ex,\n        signer: {\n          actor: payload.sa,\n          permission: payload.sp\n        },\n        signature: payload.sig\n      });\n    }\n  }]);\n\n  return IdentityProof;\n}(Struct);\n\n__decorate([Struct.field(ChainId)], IdentityProof.prototype, \"chainId\", void 0);\n\n__decorate([Struct.field(Name)], IdentityProof.prototype, \"scope\", void 0);\n\n__decorate([Struct.field(TimePointSec)], IdentityProof.prototype, \"expiration\", void 0);\n\n__decorate([Struct.field(PermissionLevel)], IdentityProof.prototype, \"signer\", void 0);\n\n__decorate([Struct.field(Signature)], IdentityProof.prototype, \"signature\", void 0);\n\nIdentityProof = IdentityProof_1 = __decorate([Struct.type('identity_proof')], IdentityProof);\n/**\n * EOSIO Signing Request (ESR).\n */\n\n/** Current supported protocol version, backwards compatible with version 2. */\n\nvar ProtocolVersion = 3;\n/**\n * The placeholder name: `............1` aka `uint64(1)`.\n * If used in action data will be resolved to current signer.\n * If used in as an authorization permission will be resolved to\n * the signers permission level.\n *\n * Example action:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"............1\", permission: \"............1\"}],\n *   data: {\n *     from: \"............1\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n * When signed by `foo@active` would resolve to:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"foo\", permission: \"active\"}],\n *   data: {\n *     from: \"foo\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n */\n\nvar PlaceholderName = Name.from('............1'); // aka uint64(1)\n\n/** Placeholder that will resolve to signer permission name. */\n\nvar PlaceholderPermission = Name.from('............2'); // aka uint64(2)\n\nvar PlaceholderAuth = PermissionLevel.from({\n  actor: PlaceholderName,\n  permission: PlaceholderPermission\n});\n\nvar SigningRequest = /*#__PURE__*/function () {\n  /**\n   * Create a new signing request.\n   * Normally not used directly, see the `create` and `from` class methods.\n   */\n  function SigningRequest(version, data, zlib, abiProvider, signature) {\n    _classCallCheck(this, SigningRequest);\n\n    if (data.flags.broadcast && data.req.variantName === 'identity') {\n      throw new Error('Invalid request (identity request cannot be broadcast)');\n    }\n\n    this.version = version;\n    this.data = data;\n    this.zlib = zlib;\n    this.abiProvider = abiProvider;\n    this.signature = signature;\n  }\n  /** Return the identity ABI for given version. */\n\n\n  _createClass(SigningRequest, [{\n    key: \"sign\",\n    value:\n    /**\n     * Sign the request, mutating.\n     * @param signatureProvider The signature provider that provides a signature for the signer.\n     */\n    function sign(signatureProvider) {\n      var message = this.getSignatureDigest();\n      this.signature = RequestSignature.from(signatureProvider.sign(message));\n    }\n    /**\n     * Get the signature digest for this request.\n     */\n\n  }, {\n    key: \"getSignatureDigest\",\n    value: function getSignatureDigest() {\n      // protocol version + utf8 \"request\"\n      var prefix = [this.version, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74];\n      return Checksum256.hash(Bytes.from(prefix).appending(this.getData()));\n    }\n    /**\n     * Set the signature data for this request, mutating.\n     * @param signer Account name of signer.\n     * @param signature The signature string.\n     */\n\n  }, {\n    key: \"setSignature\",\n    value: function setSignature(signer, signature) {\n      this.signature = RequestSignature.from({\n        signer: signer,\n        signature: signature\n      });\n    }\n    /**\n     * Set the request callback, mutating.\n     * @param url Where the callback should be sent.\n     * @param background Whether the callback should be sent in the background.\n     */\n\n  }, {\n    key: \"setCallback\",\n    value: function setCallback(url, background) {\n      this.data.callback = url;\n      this.data.flags.background = background;\n    }\n    /**\n     * Set broadcast flag.\n     * @param broadcast Whether the transaction should be broadcast by receiver.\n     */\n\n  }, {\n    key: \"setBroadcast\",\n    value: function setBroadcast(broadcast) {\n      this.data.flags.broadcast = broadcast;\n    }\n    /**\n     * Encode this request into an `esr:` uri.\n     * @argument compress Whether to compress the request data using zlib,\n     *                    defaults to true if omitted and zlib is present;\n     *                    otherwise false.\n     * @argument slashes Whether add slashes after the protocol scheme, i.e. `esr://`.\n     *                   Defaults to true.\n     * @returns An esr uri string.\n     */\n\n  }, {\n    key: \"encode\",\n    value: function encode(compress, slashes) {\n      var shouldCompress = compress !== undefined ? compress : this.zlib !== undefined;\n\n      if (shouldCompress && this.zlib === undefined) {\n        throw new Error('Need zlib to compress');\n      }\n\n      var header = this.version;\n      var data = this.getData();\n      var sigData = this.getSignatureData();\n      var array = new Uint8Array(data.byteLength + sigData.byteLength);\n      array.set(data, 0);\n      array.set(sigData, data.byteLength);\n\n      if (shouldCompress) {\n        var deflated = this.zlib.deflateRaw(array);\n\n        if (array.byteLength > deflated.byteLength) {\n          header |= 1 << 7;\n          array = deflated;\n        }\n      }\n\n      var out = new Uint8Array(1 + array.byteLength);\n      out[0] = header;\n      out.set(array, 1);\n      var scheme = 'esr:';\n\n      if (slashes !== false) {\n        scheme += '//';\n      }\n\n      return scheme + _encode(out);\n    }\n    /** Get the request data without header or signature. */\n\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      return Serializer.encode({\n        object: this.data\n      }).array;\n    }\n    /** Get signature data, returns an empty array if request is not signed. */\n\n  }, {\n    key: \"getSignatureData\",\n    value: function getSignatureData() {\n      if (!this.signature) {\n        return new Uint8Array(0);\n      }\n\n      return Serializer.encode({\n        object: this.signature\n      }).array;\n    }\n    /** ABI definitions required to resolve request. */\n\n  }, {\n    key: \"getRequiredAbis\",\n    value: function getRequiredAbis() {\n      return this.getRawActions().filter(function (action) {\n        return !isIdentity(action);\n      }).map(function (action) {\n        return action.account;\n      }).filter(function (value, index, self) {\n        return self.indexOf(value) === index;\n      });\n    }\n    /** Whether TaPoS values are required to resolve request. */\n\n  }, {\n    key: \"requiresTapos\",\n    value: function requiresTapos() {\n      var tx = this.getRawTransaction();\n      return !this.isIdentity() && !hasTapos(tx);\n    }\n    /** Resolve required ABI definitions. */\n\n  }, {\n    key: \"fetchAbis\",\n    value: function () {\n      var _fetchAbis = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(abiProvider) {\n        var required, provider, abis;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                required = this.getRequiredAbis();\n\n                if (!(required.length > 0)) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                provider = abiProvider || this.abiProvider;\n\n                if (provider) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                throw new Error('Missing ABI provider');\n\n              case 5:\n                abis = new Map();\n                _context2.next = 8;\n                return Promise.all(required.map( /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(account) {\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _context.t0 = abis;\n                            _context.t1 = account.toString();\n                            _context.t2 = ABI;\n                            _context.next = 5;\n                            return provider.getAbi(account);\n\n                          case 5:\n                            _context.t3 = _context.sent;\n                            _context.t4 = _context.t2.from.call(_context.t2, _context.t3);\n\n                            _context.t0.set.call(_context.t0, _context.t1, _context.t4);\n\n                          case 8:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function (_x2) {\n                    return _ref.apply(this, arguments);\n                  };\n                }()));\n\n              case 8:\n                return _context2.abrupt(\"return\", abis);\n\n              case 11:\n                return _context2.abrupt(\"return\", new Map());\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function fetchAbis(_x) {\n        return _fetchAbis.apply(this, arguments);\n      }\n\n      return fetchAbis;\n    }()\n    /**\n     * Decode raw actions actions to object representations.\n     * @param abis ABI defenitions required to decode all actions.\n     * @param signer Placeholders in actions will be resolved to signer if set.\n     */\n\n  }, {\n    key: \"resolveActions\",\n    value: function resolveActions(abis, signer) {\n      var _this = this;\n\n      return this.getRawActions().map(function (rawAction) {\n        var abi;\n\n        if (isIdentity(rawAction)) {\n          abi = _this.constructor.identityAbi(_this.version);\n        } else {\n          var rawAbi = abis.get(rawAction.account.toString());\n\n          if (!rawAbi) {\n            throw new Error(\"Missing ABI definition for \".concat(rawAction.account));\n          }\n\n          abi = ABI.from(rawAbi);\n        }\n\n        var type = abi.getActionType(rawAction.name);\n\n        if (!type) {\n          throw new Error(\"Missing type for action \".concat(rawAction.account, \":\").concat(rawAction.name, \" in ABI\"));\n        }\n\n        var data = rawAction.decodeData(abi);\n        var authorization = rawAction.authorization;\n\n        if (signer) {\n          var signerPerm = PermissionLevel.from(signer);\n\n          var resolve = function resolve(value) {\n            if (value instanceof Name) {\n              if (value.equals(PlaceholderName)) {\n                return signerPerm.actor;\n              } else if (value.equals(PlaceholderPermission)) {\n                return signerPerm.permission;\n              } else {\n                return value;\n              }\n            } else if (Array.isArray(value)) {\n              return value.map(resolve);\n            } else if (typeof value === 'object' && value !== null) {\n              for (var _i3 = 0, _Object$keys = Object.keys(value); _i3 < _Object$keys.length; _i3++) {\n                var key = _Object$keys[_i3];\n                value[key] = resolve(value[key]);\n              }\n\n              return value;\n            } else {\n              return value;\n            }\n          };\n\n          data = resolve(data);\n          authorization = authorization.map(function (auth) {\n            var actor = auth.actor,\n                permission = auth.permission;\n\n            if (actor.equals(PlaceholderName)) {\n              actor = signerPerm.actor;\n            }\n\n            if (permission.equals(PlaceholderPermission)) {\n              permission = signerPerm.permission;\n            } // backwards compatibility, actor placeholder will also resolve to permission when used in auth\n\n\n            if (permission.equals(PlaceholderName)) {\n              permission = signerPerm.permission;\n            }\n\n            return PermissionLevel.from({\n              actor: actor,\n              permission: permission\n            });\n          });\n        }\n\n        return _objectSpread(_objectSpread({}, rawAction), {}, {\n          authorization: authorization,\n          data: data\n        });\n      });\n    }\n  }, {\n    key: \"resolveTransaction\",\n    value: function resolveTransaction(abis, signer) {\n      var ctx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var tx = this.getRawTransaction();\n\n      if (!this.isIdentity() && !hasTapos(tx)) {\n        if (ctx.expiration !== undefined && ctx.ref_block_num !== undefined && ctx.ref_block_prefix !== undefined) {\n          tx.expiration = TimePointSec.from(ctx.expiration);\n          tx.ref_block_num = UInt16.from(ctx.ref_block_num);\n          tx.ref_block_prefix = UInt32.from(ctx.ref_block_prefix);\n        } else if (ctx.block_num !== undefined && ctx.ref_block_prefix !== undefined && ctx.timestamp !== undefined) {\n          tx.expiration = expirationTime(ctx.timestamp, ctx.expire_seconds);\n          tx.ref_block_num = UInt16.from(ctx.block_num);\n          tx.ref_block_prefix = UInt32.from(ctx.ref_block_prefix);\n        } else {\n          throw new Error('Invalid transaction context, need either a reference block or explicit TaPoS values');\n        }\n      } else if (this.isIdentity() && this.version > 2) {\n        // From ESR version 3 all identity requests have expiration\n        tx.expiration = ctx.expiration ? TimePointSec.from(ctx.expiration) : expirationTime(ctx.timestamp, ctx.expire_seconds);\n      }\n\n      var actions = this.resolveActions(abis, signer); // TODO: resolve context free actions\n\n      var context_free_actions = tx.context_free_actions;\n      return _objectSpread(_objectSpread({}, tx), {}, {\n        context_free_actions: context_free_actions,\n        actions: actions\n      });\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(abis, signer) {\n      var _this2 = this;\n\n      var ctx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var tx = this.resolveTransaction(abis, signer, ctx);\n      var actions = tx.actions.map(function (action) {\n        var abi;\n\n        if (isIdentity(action)) {\n          abi = _this2.constructor.identityAbi(_this2.version);\n        } else {\n          abi = abis.get(action.account.toString());\n        }\n\n        if (!abi) {\n          throw new Error(\"Missing ABI definition for \".concat(action.account));\n        }\n\n        var type = abi.getActionType(action.name);\n        var data = Serializer.encode({\n          object: action.data,\n          type: type,\n          abi: abi\n        });\n        return Action.from(_objectSpread(_objectSpread({}, action), {}, {\n          data: data\n        }));\n      });\n      var transaction = Transaction.from(_objectSpread(_objectSpread({}, tx), {}, {\n        actions: actions\n      }));\n      var chainId;\n\n      if (this.isMultiChain()) {\n        if (!ctx.chainId) {\n          throw new Error('Missing chosen chain ID for multi-chain request');\n        }\n\n        chainId = ChainId.from(ctx.chainId);\n        var ids = this.getChainIds();\n\n        if (ids && !ids.some(function (id) {\n          return chainId.equals(id);\n        })) {\n          throw new Error('Trying to resolve for chain ID not defined in request');\n        }\n      } else {\n        chainId = this.getChainId();\n      }\n\n      return new ResolvedSigningRequest(this, PermissionLevel.from(signer), transaction, tx, chainId);\n    }\n    /**\n     * Get the id of the chain where this request is valid.\n     * @returns The 32-byte chain id as hex encoded string.\n     */\n\n  }, {\n    key: \"getChainId\",\n    value: function getChainId() {\n      return this.data.chain_id.chainId;\n    }\n    /**\n     * Chain IDs this request is valid for, only valid for multi chain requests. Value of `null` when `isMultiChain` is true denotes any chain.\n     */\n\n  }, {\n    key: \"getChainIds\",\n    value: function getChainIds() {\n      if (!this.isMultiChain()) {\n        return null;\n      }\n\n      var ids = this.getInfoKey('chain_ids', {\n        type: ChainIdVariant,\n        array: true\n      });\n\n      if (ids) {\n        return ids.map(function (id) {\n          return id.chainId;\n        });\n      }\n\n      return null;\n    }\n    /**\n     * Set chain IDs this request is valid for, only considered for multi chain requests.\n     */\n\n  }, {\n    key: \"setChainIds\",\n    value: function setChainIds(ids) {\n      var value = ids.map(function (id) {\n        return ChainId.from(id).chainVariant;\n      });\n      this.setInfoKey('chain_ids', value, {\n        type: ChainIdVariant,\n        array: true\n      });\n    }\n    /**\n     * True if chainId is set to chain alias `0` which indicates that the request is valid for any chain.\n     */\n\n  }, {\n    key: \"isMultiChain\",\n    value: function isMultiChain() {\n      return this.data.chain_id.variantIdx === 0 && this.data.chain_id.value.value === ChainName.UNKNOWN;\n    }\n    /** Return the actions in this request with action data encoded. */\n\n  }, {\n    key: \"getRawActions\",\n    value: function getRawActions() {\n      var req = this.data.req;\n\n      switch (req.variantName) {\n        case 'action':\n          return [req.value];\n\n        case 'action[]':\n          return req.value;\n\n        case 'identity':\n          {\n            if (this.version === 2) {\n              var id = req.value;\n              var data = '0101000000000000000200000000000000'; // placeholder permission\n\n              var authorization = [PlaceholderAuth];\n\n              if (id.permission) {\n                data = Serializer.encode({\n                  object: id\n                });\n                authorization = [id.permission];\n              }\n\n              return [Action.from({\n                account: '',\n                name: 'identity',\n                authorization: authorization,\n                data: data\n              })];\n            } else {\n              // eslint-disable-next-line prefer-const\n              var _req$value = req.value,\n                  scope = _req$value.scope,\n                  permission = _req$value.permission;\n\n              if (!permission) {\n                permission = PlaceholderAuth;\n              }\n\n              var _data = Serializer.encode({\n                object: {\n                  scope: scope,\n                  permission: permission\n                },\n                type: IdentityV3\n              });\n\n              return [Action.from({\n                account: '',\n                name: 'identity',\n                authorization: [permission],\n                data: _data\n              })];\n            }\n          }\n\n        case 'transaction':\n          return req.value.actions;\n\n        default:\n          throw new Error('Invalid signing request data');\n      }\n    }\n    /** Unresolved transaction. */\n\n  }, {\n    key: \"getRawTransaction\",\n    value: function getRawTransaction() {\n      var req = this.data.req;\n\n      switch (req.variantName) {\n        case 'transaction':\n          return Transaction.from(_objectSpread({}, req.value));\n\n        case 'action':\n        case 'action[]':\n        case 'identity':\n          return Transaction.from({\n            actions: this.getRawActions(),\n            context_free_actions: [],\n            transaction_extensions: [],\n            expiration: '1970-01-01T00:00:00.000',\n            ref_block_num: 0,\n            ref_block_prefix: 0,\n            max_cpu_usage_ms: 0,\n            max_net_usage_words: 0,\n            delay_sec: 0\n          });\n\n        default:\n          throw new Error('Invalid signing request data');\n      }\n    }\n    /** Whether the request is an identity request. */\n\n  }, {\n    key: \"isIdentity\",\n    value: function isIdentity() {\n      return this.data.req.variantName === 'identity';\n    }\n    /** Whether the request should be broadcast by signer. */\n\n  }, {\n    key: \"shouldBroadcast\",\n    value: function shouldBroadcast() {\n      if (this.isIdentity()) {\n        return false;\n      }\n\n      return this.data.flags.broadcast;\n    }\n    /**\n     * Present if the request is an identity request and requests a specific account.\n     * @note This returns `nil` unless a specific identity has been requested,\n     *       use `isIdentity` to check id requests.\n     */\n\n  }, {\n    key: \"getIdentity\",\n    value: function getIdentity() {\n      if (!this.isIdentity()) {\n        return null;\n      }\n\n      var id = this.data.req.value;\n\n      if (id.permission && !id.permission.actor.equals(PlaceholderName)) {\n        return id.permission.actor;\n      }\n\n      return null;\n    }\n    /**\n     * Present if the request is an identity request and requests a specific permission.\n     * @note This returns `nil` unless a specific permission has been requested,\n     *       use `isIdentity` to check id requests.\n     */\n\n  }, {\n    key: \"getIdentityPermission\",\n    value: function getIdentityPermission() {\n      if (!this.isIdentity()) {\n        return null;\n      }\n\n      var id = this.data.req.value;\n\n      if (id.permission && !id.permission.permission.equals(PlaceholderPermission)) {\n        return id.permission.permission;\n      }\n\n      return null;\n    }\n    /**\n     * Present if the request is an identity request and requests a specific permission.\n     * @note This returns `nil` unless a specific permission has been requested,\n     *       use `isIdentity` to check id requests.\n     */\n\n  }, {\n    key: \"getIdentityScope\",\n    value: function getIdentityScope() {\n      if (!this.isIdentity() || this.version <= 2) {\n        return null;\n      }\n\n      var id = this.data.req.value;\n      return id.scope;\n    }\n    /** Get raw info dict */\n\n  }, {\n    key: \"getRawInfo\",\n    value: function getRawInfo() {\n      var rv = {};\n\n      var _iterator2 = _createForOfIteratorHelper(this.data.info),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _step2.value,\n              key = _step2$value.key,\n              value = _step2$value.value;\n          rv[key] = value;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return rv;\n    }\n  }, {\n    key: \"getRawInfoKey\",\n    value: function getRawInfoKey(key) {\n      var pair = this.data.info.find(function (pair) {\n        return pair.key === key;\n      });\n\n      if (pair) {\n        return pair.value;\n      }\n    }\n  }, {\n    key: \"setRawInfoKey\",\n    value: function setRawInfoKey(key, value) {\n      var pair = this.data.info.find(function (pair) {\n        return pair.key === key;\n      });\n\n      if (!pair) {\n        pair = InfoPair.from({\n          key: key,\n          value: value\n        });\n        this.data.info.push(pair);\n      } else {\n        pair.value = Bytes.from(value);\n      }\n    }\n    /** Set a metadata key. */\n\n  }, {\n    key: \"setInfoKey\",\n    value: function setInfoKey(key, object, type) {\n      var data;\n\n      if (typeof object === 'string' && !type) {\n        // match old behavior where strings encode to raw utf8 as opposed to\n        // eosio-abi encoded strings (varuint32 length prefix + utf8 bytes)\n        data = Bytes.from(object, 'utf8');\n      } else {\n        data = Serializer.encode({\n          object: object,\n          type: type\n        });\n      }\n\n      this.setRawInfoKey(key, data);\n    }\n  }, {\n    key: \"getInfoKey\",\n    value: function getInfoKey(key, type) {\n      var data = this.getRawInfoKey(key);\n\n      if (data) {\n        if (type) {\n          return Serializer.decode({\n            data: data,\n            type: type\n          });\n        } else {\n          // assume utf8 string if no type is given\n          return data.utf8String;\n        }\n      }\n    }\n    /** Return a deep copy of this request. */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var signature;\n\n      if (this.signature) {\n        signature = RequestSignature.from(JSON.parse(JSON.stringify(this.signature)));\n      }\n\n      var RequestData = this.constructor.storageType(this.version);\n      var data = RequestData.from(JSON.parse(JSON.stringify(this.data)));\n      return new SigningRequest(this.version, data, this.zlib, this.abiProvider, signature);\n    } // Convenience methods.\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.encode();\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.encode();\n    }\n  }], [{\n    key: \"identityAbi\",\n    value: function identityAbi(version) {\n      var abi = Serializer.synthesize(this.identityType(version));\n      abi.actions = [{\n        name: 'identity',\n        type: 'identity',\n        ricardian_contract: ''\n      }];\n      return abi;\n    }\n    /** Return the ABISerializableType identity type for given version. */\n\n  }, {\n    key: \"identityType\",\n    value: function identityType(version) {\n      return version === 2 ? IdentityV2 : IdentityV3;\n    }\n    /** Return the ABISerializableType storage type for given version. */\n\n  }, {\n    key: \"storageType\",\n    value: function storageType(version) {\n      return version === 2 ? RequestDataV2 : RequestDataV3;\n    }\n    /** Create a new signing request. */\n\n  }, {\n    key: \"create\",\n    value: function () {\n      var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(args) {\n        var options,\n            actions,\n            requiredAbis,\n            abis,\n            provider,\n            accountAbis,\n            _iterator3,\n            _step3,\n            _step3$value,\n            idx,\n            abi,\n            _args3 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n\n                if (args.action) {\n                  actions = [args.action];\n                } else if (args.actions) {\n                  actions = args.actions;\n                } else if (args.transaction) {\n                  actions = args.transaction.actions || [];\n                } else {\n                  actions = [];\n                }\n\n                requiredAbis = actions.filter(function (action) {\n                  return !Bytes.isBytes(action.data) && action.data.constructor.abiName === undefined;\n                }).map(function (action) {\n                  return Name.from(action.account);\n                });\n                abis = {};\n\n                if (!(requiredAbis.length > 0)) {\n                  _context3.next = 13;\n                  break;\n                }\n\n                provider = options.abiProvider;\n\n                if (provider) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                throw new Error('Missing abi provider');\n\n              case 8:\n                _context3.next = 10;\n                return Promise.all(requiredAbis.map(function (account) {\n                  return provider.getAbi(account);\n                }));\n\n              case 10:\n                accountAbis = _context3.sent;\n                _iterator3 = _createForOfIteratorHelper(accountAbis.entries());\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    _step3$value = _slicedToArray(_step3.value, 2), idx = _step3$value[0], abi = _step3$value[1];\n                    abis[requiredAbis[idx].toString()] = abi;\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n              case 13:\n                return _context3.abrupt(\"return\", this.createSync(args, options, abis));\n\n              case 14:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function create(_x3) {\n        return _create.apply(this, arguments);\n      }\n\n      return create;\n    }()\n    /**\n     * Synchronously create a new signing request.\n     * @throws If an un-encoded action with no abi def is encountered.\n     */\n\n  }, {\n    key: \"createSync\",\n    value: function createSync(args) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var abis = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var version = 2;\n      var data = {};\n\n      var encode = function encode(action) {\n        return encodeAction(action, abis);\n      }; // multi-chain requests requires version 3\n\n\n      if (args.chainId === null) {\n        version = 3;\n      } // set the request data\n\n\n      if (args.identity !== undefined) {\n        if (args.identity.scope) {\n          version = 3;\n        }\n\n        data.req = ['identity', this.identityType(version).from(args.identity)];\n      } else if (args.action && !args.actions && !args.transaction) {\n        data.req = ['action', encode(args.action)];\n      } else if (args.actions && !args.action && !args.transaction) {\n        if (args.actions.length === 1) {\n          data.req = ['action', encode(args.actions[0])];\n        } else {\n          data.req = ['action[]', args.actions.map(encode)];\n        }\n      } else if (args.transaction && !args.action && !args.actions) {\n        var tx = args.transaction; // set default values if missing\n\n        if (tx.expiration === undefined) {\n          tx.expiration = '1970-01-01T00:00:00.000';\n        }\n\n        if (tx.ref_block_num === undefined) {\n          tx.ref_block_num = 0;\n        }\n\n        if (tx.ref_block_prefix === undefined) {\n          tx.ref_block_prefix = 0;\n        }\n\n        if (tx.context_free_actions === undefined) {\n          tx.context_free_actions = [];\n        }\n\n        if (tx.transaction_extensions === undefined) {\n          tx.transaction_extensions = [];\n        }\n\n        if (tx.delay_sec === undefined) {\n          tx.delay_sec = 0;\n        }\n\n        if (tx.max_cpu_usage_ms === undefined) {\n          tx.max_cpu_usage_ms = 0;\n        }\n\n        if (tx.max_net_usage_words === undefined) {\n          tx.max_net_usage_words = 0;\n        }\n\n        if (tx.actions === undefined) {\n          tx.actions = [];\n        }\n\n        if (tx.context_free_actions === undefined) {\n          tx.context_free_actions = [];\n        } // encode actions if needed\n\n\n        tx.actions = tx.actions.map(encode);\n        data.req = ['transaction', tx];\n      } else {\n        throw new TypeError('Invalid arguments: Must have exactly one of action, actions or transaction');\n      } // set the chain id\n\n\n      if (args.chainId === null) {\n        data.chain_id = ChainIdVariant.from(['chain_alias', 0]);\n      } else {\n        data.chain_id = ChainId.from(args.chainId || ChainName.EOS).chainVariant;\n      } // request flags and callback\n\n\n      var flags = RequestFlags.from(0);\n      var callback = '';\n      flags.broadcast = args.broadcast !== undefined ? args.broadcast : data.req[0] !== 'identity';\n\n      if (typeof args.callback === 'string') {\n        callback = args.callback;\n      } else if (typeof args.callback === 'object') {\n        callback = args.callback.url;\n        flags.background = args.callback.background || false;\n      }\n\n      data.flags = flags;\n      data.callback = callback; // info pairs\n\n      data.info = [];\n\n      if (typeof args.info === 'object') {\n        for (var key in args.info) {\n          var isOwn = Object.prototype.hasOwnProperty.call(args.info, key);\n\n          if (isOwn) {\n            var value = args.info[key];\n\n            if (typeof value === 'string') {\n              value = Bytes.from(value, 'utf8');\n            } else if (!(value instanceof Bytes)) {\n              value = Serializer.encode({\n                object: value\n              });\n            }\n\n            data.info.push({\n              key: key,\n              value: value\n            });\n          }\n        }\n      }\n\n      if (args.chainIds && args.chainId === null) {\n        var ids = args.chainIds.map(function (id) {\n          return ChainId.from(id).chainVariant;\n        });\n        data.info.push({\n          key: 'chain_ids',\n          value: Serializer.encode({\n            object: ids,\n            type: {\n              type: ChainIdVariant,\n              array: true\n            }\n          })\n        });\n      }\n\n      var req = new SigningRequest(version, this.storageType(version).from(data), options.zlib, options.abiProvider); // sign the request if given a signature provider\n\n      if (options.signatureProvider) {\n        req.sign(options.signatureProvider);\n      }\n\n      return req;\n    }\n    /** Creates an identity request. */\n\n  }, {\n    key: \"identity\",\n    value: function identity(args) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var permission = {\n        actor: args.account || PlaceholderName,\n        permission: args.permission || PlaceholderPermission\n      };\n\n      if (permission.actor === PlaceholderName && permission.permission === PlaceholderPermission) {\n        permission = undefined;\n      }\n\n      return this.createSync(_objectSpread(_objectSpread({}, args), {}, {\n        identity: {\n          permission: permission,\n          scope: args.scope\n        },\n        broadcast: false\n      }), options);\n    }\n    /**\n     * Create a request from a chain id and serialized transaction.\n     * @param chainId The chain id where the transaction is valid.\n     * @param serializedTransaction The serialized transaction.\n     * @param options Creation options.\n     */\n\n  }, {\n    key: \"fromTransaction\",\n    value: function fromTransaction(chainId, serializedTransaction) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var id = ChainId.from(chainId);\n      serializedTransaction = Bytes.from(serializedTransaction);\n      var encoder = new ABIEncoder();\n      encoder.writeByte(2); // header\n\n      encoder.writeArray(Serializer.encode({\n        object: id.chainVariant\n      }).array);\n      encoder.writeByte(2); // transaction variant\n\n      encoder.writeArray(Bytes.from(serializedTransaction).array);\n      encoder.writeByte(RequestFlags.broadcast);\n      encoder.writeByte(0); // callback\n\n      encoder.writeByte(0); // info\n\n      return SigningRequest.fromData(encoder.getData(), options);\n    }\n    /** Creates a signing request from encoded `esr:` uri string. */\n\n  }, {\n    key: \"from\",\n    value: function from(uri) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (typeof uri !== 'string') {\n        throw new Error('Invalid request uri');\n      }\n\n      var _uri$split = uri.split(':'),\n          _uri$split2 = _slicedToArray(_uri$split, 2),\n          scheme = _uri$split2[0],\n          path = _uri$split2[1];\n\n      if (scheme !== 'esr' && scheme !== 'web+esr') {\n        throw new Error('Invalid scheme');\n      }\n\n      var data = decode(path.startsWith('//') ? path.slice(2) : path);\n      return SigningRequest.fromData(data, options);\n    }\n  }, {\n    key: \"fromData\",\n    value: function fromData(data) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      data = Bytes.from(data);\n      var header = data.array[0];\n      var version = header & ~(1 << 7);\n\n      if (version !== 2 && version !== 3) {\n        throw new Error('Unsupported protocol version');\n      }\n\n      var payload = data.droppingFirst(1);\n\n      if ((header & 1 << 7) !== 0) {\n        if (!options.zlib) {\n          throw new Error('Compressed URI needs zlib');\n        }\n\n        payload = Bytes.from(options.zlib.inflateRaw(payload.array));\n      }\n\n      var decoder = new ABIDecoder(payload.array);\n      var req = Serializer.decode({\n        data: decoder,\n        type: this.storageType(version)\n      });\n      var sig;\n\n      if (decoder.canRead()) {\n        sig = Serializer.decode({\n          data: decoder,\n          type: RequestSignature\n        });\n      }\n\n      return new SigningRequest(version, req, options.zlib, options.abiProvider, sig);\n    }\n  }]);\n\n  return SigningRequest;\n}();\n\nvar ResolvedSigningRequest = /*#__PURE__*/function () {\n  function ResolvedSigningRequest(request, signer, transaction, resolvedTransaction, chainId) {\n    _classCallCheck(this, ResolvedSigningRequest);\n\n    this.request = request;\n    this.signer = signer;\n    this.transaction = transaction;\n    this.resolvedTransaction = resolvedTransaction;\n    this.chainId = chainId;\n  }\n  /** Recreate a resolved request from a callback payload. */\n\n\n  _createClass(ResolvedSigningRequest, [{\n    key: \"serializedTransaction\",\n    get: function get() {\n      return Serializer.encode({\n        object: this.transaction\n      }).array;\n    }\n  }, {\n    key: \"signingDigest\",\n    get: function get() {\n      return this.transaction.signingDigest(this.chainId);\n    }\n  }, {\n    key: \"getCallback\",\n    value: function getCallback(signatures, blockNum) {\n      var _this$request$data = this.request.data,\n          callback = _this$request$data.callback,\n          flags = _this$request$data.flags;\n\n      if (!callback || callback.length === 0) {\n        return null;\n      }\n\n      if (!signatures || signatures.length === 0) {\n        throw new Error('Must have at least one signature to resolve callback');\n      }\n\n      var sigs = signatures.map(function (sig) {\n        return Signature.from(sig);\n      });\n      var payload = {\n        sig: String(sigs[0]),\n        tx: String(this.transaction.id),\n        rbn: String(this.transaction.ref_block_num),\n        rid: String(this.transaction.ref_block_prefix),\n        ex: String(this.transaction.expiration),\n        req: this.request.encode(),\n        sa: String(this.signer.actor),\n        sp: String(this.signer.permission),\n        cid: String(this.chainId)\n      };\n\n      var _iterator4 = _createForOfIteratorHelper(sigs.slice(1).entries()),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _step4$value = _slicedToArray(_step4.value, 2),\n              n = _step4$value[0],\n              sig = _step4$value[1];\n\n          payload[\"sig\".concat(n)] = String(sig);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      if (blockNum) {\n        payload.bn = String(UInt32.from(blockNum));\n      }\n\n      var url = callback.replace(/({{([a-z0-9]+)}})/g, function (_1, _2, m) {\n        return payload[m] || '';\n      });\n      return {\n        background: flags.background,\n        payload: payload,\n        url: url\n      };\n    }\n  }, {\n    key: \"getIdentityProof\",\n    value: function getIdentityProof(signature) {\n      if (!this.request.isIdentity()) {\n        throw new Error('Not a identity request');\n      }\n\n      return IdentityProof.from({\n        chainId: this.chainId,\n        scope: this.request.getIdentityScope(),\n        expiration: this.transaction.expiration,\n        signer: this.signer,\n        signature: signature\n      });\n    }\n  }], [{\n    key: \"fromPayload\",\n    value: function () {\n      var _fromPayload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(payload) {\n        var options,\n            request,\n            abis,\n            _args4 = arguments;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                options = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n                request = SigningRequest.from(payload.req, options);\n                _context4.next = 4;\n                return request.fetchAbis();\n\n              case 4:\n                abis = _context4.sent;\n                return _context4.abrupt(\"return\", request.resolve(abis, {\n                  actor: payload.sa,\n                  permission: payload.sp\n                }, {\n                  ref_block_num: payload.rbn,\n                  ref_block_prefix: payload.rid,\n                  expiration: payload.ex,\n                  chainId: payload.cid || request.getChainId()\n                }));\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function fromPayload(_x4) {\n        return _fromPayload.apply(this, arguments);\n      }\n\n      return fromPayload;\n    }()\n  }]);\n\n  return ResolvedSigningRequest;\n}();\n\nfunction encodeAction(action, abis) {\n  if (Bytes.isBytes(action.data) || action.data.constructor.abiName !== undefined) {\n    return Action.from(action);\n  }\n\n  var abi = abis[String(Name.from(action.account))];\n\n  if (!abi) {\n    throw new Error(\"Missing ABI for \".concat(action.account));\n  }\n\n  return Action.from(action, abi);\n}\n\nfunction isIdentity(action) {\n  var account = Name.from(action.account);\n  var name = Name.from(action.name);\n  return account.rawValue.equals(0) && name.equals('identity');\n}\n\nfunction hasTapos(tx) {\n  return !(tx.expiration.value.value === 0 && tx.ref_block_num.value === 0 && tx.ref_block_prefix.value === 0);\n}\n\nfunction expirationTime(timestamp) {\n  var expireSeconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60;\n  var ts = TimePointSec.from(timestamp || new Date());\n  var exp = UInt32.from(expireSeconds);\n  return TimePointSec.fromMilliseconds(ts.toMilliseconds() + exp.value * 1000);\n}\n\nexport { AccountName, base64u as Base64u, ChainAlias, ChainId, ChainIdVariant, ChainName, IdentityProof, IdentityV2, IdentityV3, InfoPair, PermissionName, PlaceholderAuth, PlaceholderName, PlaceholderPermission, ProtocolVersion, RequestDataV2, RequestDataV3, RequestFlags, RequestSignature, RequestVariantV2, RequestVariantV3, ResolvedSigningRequest, SigningRequest };","map":{"version":3,"sources":["../src/base64u.ts","../src/chain-id.ts","../src/abi.ts","../src/identity-proof.ts","../src/signing-request.ts"],"names":["Base64u.decode","Base64u.encode","base64u.decode","base64u.encode"],"mappings":"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","sourcesContent":["/**\n * EOSIO Signing Request v2.2.0\n * https://github.com/greymass/eosio-signing-request\n *\n * @license\n * Copyright © 2021 Greymass Inc.\n * \n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the “Software”), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n * \n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n * \n * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR\n * INTENDED FOR USE IN THE DESIGN, CONSTRUCTION, OPERATION OR\n * MAINTENANCE OF ANY MILITARY FACILITY.\n */\nimport { Checksum256, TypeAlias, UInt8, Variant, Name, Struct, PermissionLevel, Action, Transaction, isInstanceOf, Serializer, TimePointSec, Authority, Signature, Bytes, ABIEncoder, ABIDecoder, ABI, UInt16, UInt32 } from '@greymass/eosio';\nimport { __decorate } from 'tslib';\n\n/**\n * Base64u - URL-Safe Base64 variant no padding.\n * Based on https://gist.github.com/jonleighton/958841\n */\nconst baseCharset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nconst lookup = new Uint8Array(256);\nfor (let i = 0; i < 62; i++) {\n    lookup[baseCharset.charCodeAt(i)] = i;\n}\n// support both urlsafe and standard base64\nlookup[43] = lookup[45] = 62;\nlookup[47] = lookup[95] = 63;\nfunction encode(data, urlSafe = true) {\n    const byteLength = data.byteLength;\n    const byteRemainder = byteLength % 3;\n    const mainLength = byteLength - byteRemainder;\n    const charset = baseCharset + (urlSafe ? '-_' : '+/');\n    const parts = [];\n    let a;\n    let b;\n    let c;\n    let d;\n    let chunk;\n    // Main loop deals with bytes in chunks of 3\n    for (let i = 0; i < mainLength; i += 3) {\n        // Combine the three bytes into a single integer\n        chunk = (data[i] << 16) | (data[i + 1] << 8) | data[i + 2];\n        // Use bitmasks to extract 6-bit segments from the triplet\n        a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\n        b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\n        c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\n        d = chunk & 63; // 63       =  2^6 - 1\n        // Convert the raw binary segments to the appropriate ASCII encoding\n        parts.push(charset[a] + charset[b] + charset[c] + charset[d]);\n    }\n    // Deal with the remaining bytes\n    if (byteRemainder === 1) {\n        chunk = data[mainLength];\n        a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\n        // Set the 4 least significant bits to zero\n        b = (chunk & 3) << 4; // 3   = 2^2 - 1\n        parts.push(charset[a] + charset[b]);\n    }\n    else if (byteRemainder === 2) {\n        chunk = (data[mainLength] << 8) | data[mainLength + 1];\n        a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\n        b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\n        // Set the 2 least significant bits to zero\n        c = (chunk & 15) << 2; // 15    = 2^4 - 1\n        parts.push(charset[a] + charset[b] + charset[c]);\n    }\n    return parts.join('');\n}\nfunction decode(input) {\n    const byteLength = input.length * 0.75;\n    const data = new Uint8Array(byteLength);\n    let a;\n    let b;\n    let c;\n    let d;\n    let p = 0;\n    for (let i = 0; i < input.length; i += 4) {\n        a = lookup[input.charCodeAt(i)];\n        b = lookup[input.charCodeAt(i + 1)];\n        c = lookup[input.charCodeAt(i + 2)];\n        d = lookup[input.charCodeAt(i + 3)];\n        data[p++] = (a << 2) | (b >> 4);\n        data[p++] = ((b & 15) << 4) | (c >> 2);\n        data[p++] = ((c & 3) << 6) | (d & 63);\n    }\n    return data;\n}\n\nvar base64u = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    encode: encode,\n    decode: decode\n});\n\n/** Chain ID aliases. */\nvar ChainName;\n(function (ChainName) {\n    ChainName[ChainName[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    ChainName[ChainName[\"EOS\"] = 1] = \"EOS\";\n    ChainName[ChainName[\"TELOS\"] = 2] = \"TELOS\";\n    ChainName[ChainName[\"JUNGLE\"] = 3] = \"JUNGLE\";\n    ChainName[ChainName[\"KYLIN\"] = 4] = \"KYLIN\";\n    ChainName[ChainName[\"WORBLI\"] = 5] = \"WORBLI\";\n    ChainName[ChainName[\"BOS\"] = 6] = \"BOS\";\n    ChainName[ChainName[\"MEETONE\"] = 7] = \"MEETONE\";\n    ChainName[ChainName[\"INSIGHTS\"] = 8] = \"INSIGHTS\";\n    ChainName[ChainName[\"BEOS\"] = 9] = \"BEOS\";\n    ChainName[ChainName[\"WAX\"] = 10] = \"WAX\";\n    ChainName[ChainName[\"PROTON\"] = 11] = \"PROTON\";\n    ChainName[ChainName[\"FIO\"] = 12] = \"FIO\";\n})(ChainName || (ChainName = {}));\nlet ChainId = class ChainId extends Checksum256 {\n    static from(value) {\n        if (value instanceof this) {\n            return value;\n        }\n        if (typeof value === 'number') {\n            value = ChainIdLookup.get(value);\n            if (!value) {\n                throw new Error('Unknown chain id alias');\n            }\n        }\n        return super.from(value);\n    }\n    get chainVariant() {\n        const name = this.chainName;\n        if (name !== ChainName.UNKNOWN) {\n            return ChainIdVariant.from(['chain_alias', name]);\n        }\n        return ChainIdVariant.from(this);\n    }\n    get chainName() {\n        const cid = this.hexString;\n        for (const [n, id] of ChainIdLookup) {\n            if (id === cid) {\n                return n;\n            }\n        }\n        return ChainName.UNKNOWN;\n    }\n};\nChainId = __decorate([\n    TypeAlias('chain_id')\n], ChainId);\nlet ChainAlias = class ChainAlias extends UInt8 {\n};\nChainAlias = __decorate([\n    TypeAlias('chain_alias')\n], ChainAlias);\nlet ChainIdVariant = class ChainIdVariant extends Variant {\n    get chainId() {\n        if (this.value instanceof ChainId) {\n            return this.value;\n        }\n        return ChainId.from(this.value.value);\n    }\n};\nChainIdVariant = __decorate([\n    Variant.type('variant_id', [ChainAlias, ChainId])\n], ChainIdVariant);\nconst ChainIdLookup = new Map([\n    [ChainName.EOS, 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906'],\n    [ChainName.TELOS, '4667b205c6838ef70ff7988f6e8257e8be0e1284a2f59699054a018f743b1d11'],\n    [ChainName.JUNGLE, 'e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473'],\n    [ChainName.KYLIN, '5fff1dae8dc8e2fc4d5b23b2c7665c97f9e9d8edf2b6485a86ba311c25639191'],\n    [ChainName.WORBLI, '73647cde120091e0a4b85bced2f3cfdb3041e266cbbe95cee59b73235a1b3b6f'],\n    [ChainName.BOS, 'd5a3d18fbb3c084e3b1f3fa98c21014b5f3db536cc15d08f9f6479517c6a3d86'],\n    [ChainName.MEETONE, 'cfe6486a83bad4962f232d48003b1824ab5665c36778141034d75e57b956e422'],\n    [ChainName.INSIGHTS, 'b042025541e25a472bffde2d62edd457b7e70cee943412b1ea0f044f88591664'],\n    [ChainName.BEOS, 'b912d19a6abd2b1b05611ae5be473355d64d95aeff0c09bedc8c166cd6468fe4'],\n    [ChainName.WAX, '1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4'],\n    [ChainName.PROTON, '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0'],\n    [ChainName.FIO, '21dcae42c0182200e93f954a074011f9048a7624c6fe81d3c9541a614a88bd1c'],\n]);\n\n/** SigningRequest ABI and typedefs. */\nvar RequestFlags_1;\nlet AccountName = class AccountName extends Name {\n};\nAccountName = __decorate([\n    TypeAlias('account_name')\n], AccountName);\nlet PermissionName = class PermissionName extends Name {\n};\nPermissionName = __decorate([\n    TypeAlias('permission_name')\n], PermissionName);\nlet IdentityV2 = class IdentityV2 extends Struct {\n};\n__decorate([\n    Struct.field(PermissionLevel, { optional: true })\n], IdentityV2.prototype, \"permission\", void 0);\nIdentityV2 = __decorate([\n    Struct.type('identity')\n], IdentityV2);\nlet IdentityV3 = class IdentityV3 extends Struct {\n};\n__decorate([\n    Struct.field('name')\n], IdentityV3.prototype, \"scope\", void 0);\n__decorate([\n    Struct.field(PermissionLevel, { optional: true })\n], IdentityV3.prototype, \"permission\", void 0);\nIdentityV3 = __decorate([\n    Struct.type('identity')\n], IdentityV3);\nlet RequestVariantV2 = class RequestVariantV2 extends Variant {\n};\nRequestVariantV2 = __decorate([\n    Variant.type('variant_req', [Action, { type: Action, array: true }, Transaction, IdentityV2])\n], RequestVariantV2);\nlet RequestVariantV3 = class RequestVariantV3 extends Variant {\n};\nRequestVariantV3 = __decorate([\n    Variant.type('variant_req', [Action, { type: Action, array: true }, Transaction, IdentityV3])\n], RequestVariantV3);\nlet RequestFlags = RequestFlags_1 = class RequestFlags extends UInt8 {\n    get broadcast() {\n        return (this.value & RequestFlags_1.broadcast) !== 0;\n    }\n    set broadcast(enabled) {\n        this.setFlag(RequestFlags_1.broadcast, enabled);\n    }\n    get background() {\n        return (this.value & RequestFlags_1.background) !== 0;\n    }\n    set background(enabled) {\n        this.setFlag(RequestFlags_1.background, enabled);\n    }\n    setFlag(flag, enabled) {\n        if (enabled) {\n            this.value |= flag;\n        }\n        else {\n            this.value &= ~flag;\n        }\n    }\n};\nRequestFlags.broadcast = 1 << 0;\nRequestFlags.background = 1 << 1;\nRequestFlags = RequestFlags_1 = __decorate([\n    TypeAlias('request_flags')\n], RequestFlags);\nlet InfoPair = class InfoPair extends Struct {\n};\n__decorate([\n    Struct.field('string')\n], InfoPair.prototype, \"key\", void 0);\n__decorate([\n    Struct.field('bytes')\n], InfoPair.prototype, \"value\", void 0);\nInfoPair = __decorate([\n    Struct.type('info_pair')\n], InfoPair);\nlet RequestDataV2 = class RequestDataV2 extends Struct {\n};\n__decorate([\n    Struct.field(ChainIdVariant)\n], RequestDataV2.prototype, \"chain_id\", void 0);\n__decorate([\n    Struct.field(RequestVariantV2)\n], RequestDataV2.prototype, \"req\", void 0);\n__decorate([\n    Struct.field(RequestFlags)\n], RequestDataV2.prototype, \"flags\", void 0);\n__decorate([\n    Struct.field('string')\n], RequestDataV2.prototype, \"callback\", void 0);\n__decorate([\n    Struct.field(InfoPair, { array: true })\n], RequestDataV2.prototype, \"info\", void 0);\nRequestDataV2 = __decorate([\n    Struct.type('signing_request')\n], RequestDataV2);\nlet RequestDataV3 = class RequestDataV3 extends Struct {\n};\n__decorate([\n    Struct.field(ChainIdVariant)\n], RequestDataV3.prototype, \"chain_id\", void 0);\n__decorate([\n    Struct.field(RequestVariantV3)\n], RequestDataV3.prototype, \"req\", void 0);\n__decorate([\n    Struct.field(RequestFlags)\n], RequestDataV3.prototype, \"flags\", void 0);\n__decorate([\n    Struct.field('string')\n], RequestDataV3.prototype, \"callback\", void 0);\n__decorate([\n    Struct.field(InfoPair, { array: true })\n], RequestDataV3.prototype, \"info\", void 0);\nRequestDataV3 = __decorate([\n    Struct.type('signing_request')\n], RequestDataV3);\nlet RequestSignature = class RequestSignature extends Struct {\n};\n__decorate([\n    Struct.field('name')\n], RequestSignature.prototype, \"signer\", void 0);\n__decorate([\n    Struct.field('signature')\n], RequestSignature.prototype, \"signature\", void 0);\nRequestSignature = __decorate([\n    Struct.type('request_signature')\n], RequestSignature);\n\nvar IdentityProof_1;\nlet IdentityProof = IdentityProof_1 = class IdentityProof extends Struct {\n    static from(value) {\n        if (isInstanceOf(value, IdentityProof_1)) {\n            return value;\n        }\n        else if (typeof value === 'string') {\n            return IdentityProof_1.fromString(value);\n        }\n        else {\n            return super.from(value);\n        }\n    }\n    /**\n     * Create a new instance from an EOSIO authorization header string.\n     * \"EOSIO <base64payload>\"\n     */\n    static fromString(string) {\n        const parts = string.split(' ');\n        if (parts.length !== 2 || parts[0] !== 'EOSIO') {\n            throw new Error('Invalid IdentityProof string');\n        }\n        const data = decode(parts[1]);\n        return Serializer.decode({ data, type: IdentityProof_1 });\n    }\n    /** Create a new instance from a callback payload. */\n    static fromPayload(payload, options = {}) {\n        const request = SigningRequest.from(payload.req, options);\n        if (!(request.version >= 3 && request.isIdentity())) {\n            throw new Error('Not an identity request');\n        }\n        return this.from({\n            chainId: payload.cid || request.getChainId(),\n            scope: request.getIdentityScope(),\n            expiration: payload.ex,\n            signer: { actor: payload.sa, permission: payload.sp },\n            signature: payload.sig,\n        });\n    }\n    /**\n     * Transaction this proof resolves to.\n     * @internal\n     */\n    get transaction() {\n        const action = Action.from({\n            account: '',\n            name: 'identity',\n            authorization: [this.signer],\n            data: IdentityV3.from({ scope: this.scope, permission: this.signer }),\n        });\n        return Transaction.from({\n            ref_block_num: 0,\n            ref_block_prefix: 0,\n            expiration: this.expiration,\n            actions: [action],\n        });\n    }\n    /**\n     * Recover the public key that signed this proof.\n     */\n    recover() {\n        return this.signature.recoverDigest(this.transaction.signingDigest(this.chainId));\n    }\n    /**\n     * Verify that given authority signed this proof.\n     * @param auth The accounts signing authority.\n     * @param currentTime Time to verify expiry against, if unset will use system time.\n     */\n    verify(auth, currentTime) {\n        const now = TimePointSec.from(currentTime || new Date()).toMilliseconds();\n        return (now < this.expiration.toMilliseconds() &&\n            Authority.from(auth).hasPermission(this.recover()));\n    }\n    /**\n     * Encode the proof to an `EOSIO` auth header string.\n     */\n    toString() {\n        const data = Serializer.encode({ object: this });\n        return `EOSIO ${encode(data.array, false)}`;\n    }\n};\n__decorate([\n    Struct.field(ChainId)\n], IdentityProof.prototype, \"chainId\", void 0);\n__decorate([\n    Struct.field(Name)\n], IdentityProof.prototype, \"scope\", void 0);\n__decorate([\n    Struct.field(TimePointSec)\n], IdentityProof.prototype, \"expiration\", void 0);\n__decorate([\n    Struct.field(PermissionLevel)\n], IdentityProof.prototype, \"signer\", void 0);\n__decorate([\n    Struct.field(Signature)\n], IdentityProof.prototype, \"signature\", void 0);\nIdentityProof = IdentityProof_1 = __decorate([\n    Struct.type('identity_proof')\n], IdentityProof);\n\n/**\n * EOSIO Signing Request (ESR).\n */\n/** Current supported protocol version, backwards compatible with version 2. */\nconst ProtocolVersion = 3;\n/**\n * The placeholder name: `............1` aka `uint64(1)`.\n * If used in action data will be resolved to current signer.\n * If used in as an authorization permission will be resolved to\n * the signers permission level.\n *\n * Example action:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"............1\", permission: \"............1\"}],\n *   data: {\n *     from: \"............1\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n * When signed by `foo@active` would resolve to:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"foo\", permission: \"active\"}],\n *   data: {\n *     from: \"foo\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n */\nconst PlaceholderName = Name.from('............1'); // aka uint64(1)\n/** Placeholder that will resolve to signer permission name. */\nconst PlaceholderPermission = Name.from('............2'); // aka uint64(2)\nconst PlaceholderAuth = PermissionLevel.from({\n    actor: PlaceholderName,\n    permission: PlaceholderPermission,\n});\nclass SigningRequest {\n    /**\n     * Create a new signing request.\n     * Normally not used directly, see the `create` and `from` class methods.\n     */\n    constructor(version, data, zlib, abiProvider, signature) {\n        if (data.flags.broadcast && data.req.variantName === 'identity') {\n            throw new Error('Invalid request (identity request cannot be broadcast)');\n        }\n        this.version = version;\n        this.data = data;\n        this.zlib = zlib;\n        this.abiProvider = abiProvider;\n        this.signature = signature;\n    }\n    /** Return the identity ABI for given version. */\n    static identityAbi(version) {\n        const abi = Serializer.synthesize(this.identityType(version));\n        abi.actions = [{ name: 'identity', type: 'identity', ricardian_contract: '' }];\n        return abi;\n    }\n    /** Return the ABISerializableType identity type for given version. */\n    static identityType(version) {\n        return version === 2 ? IdentityV2 : IdentityV3;\n    }\n    /** Return the ABISerializableType storage type for given version. */\n    static storageType(version) {\n        return version === 2 ? RequestDataV2 : RequestDataV3;\n    }\n    /** Create a new signing request. */\n    static async create(args, options = {}) {\n        let actions;\n        if (args.action) {\n            actions = [args.action];\n        }\n        else if (args.actions) {\n            actions = args.actions;\n        }\n        else if (args.transaction) {\n            actions = args.transaction.actions || [];\n        }\n        else {\n            actions = [];\n        }\n        const requiredAbis = actions\n            .filter((action) => !Bytes.isBytes(action.data) &&\n            action.data.constructor.abiName === undefined)\n            .map((action) => Name.from(action.account));\n        const abis = {};\n        if (requiredAbis.length > 0) {\n            const provider = options.abiProvider;\n            if (!provider) {\n                throw new Error('Missing abi provider');\n            }\n            const accountAbis = await Promise.all(requiredAbis.map((account) => provider.getAbi(account)));\n            for (const [idx, abi] of accountAbis.entries()) {\n                abis[requiredAbis[idx].toString()] = abi;\n            }\n        }\n        return this.createSync(args, options, abis);\n    }\n    /**\n     * Synchronously create a new signing request.\n     * @throws If an un-encoded action with no abi def is encountered.\n     */\n    static createSync(args, options = {}, abis = {}) {\n        let version = 2;\n        const data = {};\n        const encode = (action) => encodeAction(action, abis);\n        // multi-chain requests requires version 3\n        if (args.chainId === null) {\n            version = 3;\n        }\n        // set the request data\n        if (args.identity !== undefined) {\n            if (args.identity.scope) {\n                version = 3;\n            }\n            data.req = ['identity', this.identityType(version).from(args.identity)];\n        }\n        else if (args.action && !args.actions && !args.transaction) {\n            data.req = ['action', encode(args.action)];\n        }\n        else if (args.actions && !args.action && !args.transaction) {\n            if (args.actions.length === 1) {\n                data.req = ['action', encode(args.actions[0])];\n            }\n            else {\n                data.req = ['action[]', args.actions.map(encode)];\n            }\n        }\n        else if (args.transaction && !args.action && !args.actions) {\n            const tx = args.transaction;\n            // set default values if missing\n            if (tx.expiration === undefined) {\n                tx.expiration = '1970-01-01T00:00:00.000';\n            }\n            if (tx.ref_block_num === undefined) {\n                tx.ref_block_num = 0;\n            }\n            if (tx.ref_block_prefix === undefined) {\n                tx.ref_block_prefix = 0;\n            }\n            if (tx.context_free_actions === undefined) {\n                tx.context_free_actions = [];\n            }\n            if (tx.transaction_extensions === undefined) {\n                tx.transaction_extensions = [];\n            }\n            if (tx.delay_sec === undefined) {\n                tx.delay_sec = 0;\n            }\n            if (tx.max_cpu_usage_ms === undefined) {\n                tx.max_cpu_usage_ms = 0;\n            }\n            if (tx.max_net_usage_words === undefined) {\n                tx.max_net_usage_words = 0;\n            }\n            if (tx.actions === undefined) {\n                tx.actions = [];\n            }\n            if (tx.context_free_actions === undefined) {\n                tx.context_free_actions = [];\n            }\n            // encode actions if needed\n            tx.actions = tx.actions.map(encode);\n            data.req = ['transaction', tx];\n        }\n        else {\n            throw new TypeError('Invalid arguments: Must have exactly one of action, actions or transaction');\n        }\n        // set the chain id\n        if (args.chainId === null) {\n            data.chain_id = ChainIdVariant.from(['chain_alias', 0]);\n        }\n        else {\n            data.chain_id = ChainId.from(args.chainId || ChainName.EOS).chainVariant;\n        }\n        // request flags and callback\n        const flags = RequestFlags.from(0);\n        let callback = '';\n        flags.broadcast = args.broadcast !== undefined ? args.broadcast : data.req[0] !== 'identity';\n        if (typeof args.callback === 'string') {\n            callback = args.callback;\n        }\n        else if (typeof args.callback === 'object') {\n            callback = args.callback.url;\n            flags.background = args.callback.background || false;\n        }\n        data.flags = flags;\n        data.callback = callback;\n        // info pairs\n        data.info = [];\n        if (typeof args.info === 'object') {\n            for (const key in args.info) {\n                const isOwn = Object.prototype.hasOwnProperty.call(args.info, key);\n                if (isOwn) {\n                    let value = args.info[key];\n                    if (typeof value === 'string') {\n                        value = Bytes.from(value, 'utf8');\n                    }\n                    else if (!(value instanceof Bytes)) {\n                        value = Serializer.encode({ object: value });\n                    }\n                    data.info.push({ key, value });\n                }\n            }\n        }\n        if (args.chainIds && args.chainId === null) {\n            const ids = args.chainIds.map((id) => ChainId.from(id).chainVariant);\n            data.info.push({\n                key: 'chain_ids',\n                value: Serializer.encode({ object: ids, type: { type: ChainIdVariant, array: true } }),\n            });\n        }\n        const req = new SigningRequest(version, this.storageType(version).from(data), options.zlib, options.abiProvider);\n        // sign the request if given a signature provider\n        if (options.signatureProvider) {\n            req.sign(options.signatureProvider);\n        }\n        return req;\n    }\n    /** Creates an identity request. */\n    static identity(args, options = {}) {\n        let permission = {\n            actor: args.account || PlaceholderName,\n            permission: args.permission || PlaceholderPermission,\n        };\n        if (permission.actor === PlaceholderName &&\n            permission.permission === PlaceholderPermission) {\n            permission = undefined;\n        }\n        return this.createSync({\n            ...args,\n            identity: {\n                permission,\n                scope: args.scope,\n            },\n            broadcast: false,\n        }, options);\n    }\n    /**\n     * Create a request from a chain id and serialized transaction.\n     * @param chainId The chain id where the transaction is valid.\n     * @param serializedTransaction The serialized transaction.\n     * @param options Creation options.\n     */\n    static fromTransaction(chainId, serializedTransaction, options = {}) {\n        const id = ChainId.from(chainId);\n        serializedTransaction = Bytes.from(serializedTransaction);\n        const encoder = new ABIEncoder();\n        encoder.writeByte(2); // header\n        encoder.writeArray(Serializer.encode({ object: id.chainVariant }).array);\n        encoder.writeByte(2); // transaction variant\n        encoder.writeArray(Bytes.from(serializedTransaction).array);\n        encoder.writeByte(RequestFlags.broadcast);\n        encoder.writeByte(0); // callback\n        encoder.writeByte(0); // info\n        return SigningRequest.fromData(encoder.getData(), options);\n    }\n    /** Creates a signing request from encoded `esr:` uri string. */\n    static from(uri, options = {}) {\n        if (typeof uri !== 'string') {\n            throw new Error('Invalid request uri');\n        }\n        const [scheme, path] = uri.split(':');\n        if (scheme !== 'esr' && scheme !== 'web+esr') {\n            throw new Error('Invalid scheme');\n        }\n        const data = decode(path.startsWith('//') ? path.slice(2) : path);\n        return SigningRequest.fromData(data, options);\n    }\n    static fromData(data, options = {}) {\n        data = Bytes.from(data);\n        const header = data.array[0];\n        const version = header & ~(1 << 7);\n        if (version !== 2 && version !== 3) {\n            throw new Error('Unsupported protocol version');\n        }\n        let payload = data.droppingFirst(1);\n        if ((header & (1 << 7)) !== 0) {\n            if (!options.zlib) {\n                throw new Error('Compressed URI needs zlib');\n            }\n            payload = Bytes.from(options.zlib.inflateRaw(payload.array));\n        }\n        const decoder = new ABIDecoder(payload.array);\n        const req = Serializer.decode({ data: decoder, type: this.storageType(version) });\n        let sig;\n        if (decoder.canRead()) {\n            sig = Serializer.decode({ data: decoder, type: RequestSignature });\n        }\n        return new SigningRequest(version, req, options.zlib, options.abiProvider, sig);\n    }\n    /**\n     * Sign the request, mutating.\n     * @param signatureProvider The signature provider that provides a signature for the signer.\n     */\n    sign(signatureProvider) {\n        const message = this.getSignatureDigest();\n        this.signature = RequestSignature.from(signatureProvider.sign(message));\n    }\n    /**\n     * Get the signature digest for this request.\n     */\n    getSignatureDigest() {\n        // protocol version + utf8 \"request\"\n        const prefix = [this.version, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74];\n        return Checksum256.hash(Bytes.from(prefix).appending(this.getData()));\n    }\n    /**\n     * Set the signature data for this request, mutating.\n     * @param signer Account name of signer.\n     * @param signature The signature string.\n     */\n    setSignature(signer, signature) {\n        this.signature = RequestSignature.from({ signer, signature });\n    }\n    /**\n     * Set the request callback, mutating.\n     * @param url Where the callback should be sent.\n     * @param background Whether the callback should be sent in the background.\n     */\n    setCallback(url, background) {\n        this.data.callback = url;\n        this.data.flags.background = background;\n    }\n    /**\n     * Set broadcast flag.\n     * @param broadcast Whether the transaction should be broadcast by receiver.\n     */\n    setBroadcast(broadcast) {\n        this.data.flags.broadcast = broadcast;\n    }\n    /**\n     * Encode this request into an `esr:` uri.\n     * @argument compress Whether to compress the request data using zlib,\n     *                    defaults to true if omitted and zlib is present;\n     *                    otherwise false.\n     * @argument slashes Whether add slashes after the protocol scheme, i.e. `esr://`.\n     *                   Defaults to true.\n     * @returns An esr uri string.\n     */\n    encode(compress, slashes) {\n        const shouldCompress = compress !== undefined ? compress : this.zlib !== undefined;\n        if (shouldCompress && this.zlib === undefined) {\n            throw new Error('Need zlib to compress');\n        }\n        let header = this.version;\n        const data = this.getData();\n        const sigData = this.getSignatureData();\n        let array = new Uint8Array(data.byteLength + sigData.byteLength);\n        array.set(data, 0);\n        array.set(sigData, data.byteLength);\n        if (shouldCompress) {\n            const deflated = this.zlib.deflateRaw(array);\n            if (array.byteLength > deflated.byteLength) {\n                header |= 1 << 7;\n                array = deflated;\n            }\n        }\n        const out = new Uint8Array(1 + array.byteLength);\n        out[0] = header;\n        out.set(array, 1);\n        let scheme = 'esr:';\n        if (slashes !== false) {\n            scheme += '//';\n        }\n        return scheme + encode(out);\n    }\n    /** Get the request data without header or signature. */\n    getData() {\n        return Serializer.encode({ object: this.data }).array;\n    }\n    /** Get signature data, returns an empty array if request is not signed. */\n    getSignatureData() {\n        if (!this.signature) {\n            return new Uint8Array(0);\n        }\n        return Serializer.encode({ object: this.signature }).array;\n    }\n    /** ABI definitions required to resolve request. */\n    getRequiredAbis() {\n        return this.getRawActions()\n            .filter((action) => !isIdentity(action))\n            .map((action) => action.account)\n            .filter((value, index, self) => self.indexOf(value) === index);\n    }\n    /** Whether TaPoS values are required to resolve request. */\n    requiresTapos() {\n        const tx = this.getRawTransaction();\n        return !this.isIdentity() && !hasTapos(tx);\n    }\n    /** Resolve required ABI definitions. */\n    async fetchAbis(abiProvider) {\n        const required = this.getRequiredAbis();\n        if (required.length > 0) {\n            const provider = abiProvider || this.abiProvider;\n            if (!provider) {\n                throw new Error('Missing ABI provider');\n            }\n            const abis = new Map();\n            await Promise.all(required.map(async (account) => {\n                abis.set(account.toString(), ABI.from(await provider.getAbi(account)));\n            }));\n            return abis;\n        }\n        else {\n            return new Map();\n        }\n    }\n    /**\n     * Decode raw actions actions to object representations.\n     * @param abis ABI defenitions required to decode all actions.\n     * @param signer Placeholders in actions will be resolved to signer if set.\n     */\n    resolveActions(abis, signer) {\n        return this.getRawActions().map((rawAction) => {\n            let abi;\n            if (isIdentity(rawAction)) {\n                abi = this.constructor.identityAbi(this.version);\n            }\n            else {\n                const rawAbi = abis.get(rawAction.account.toString());\n                if (!rawAbi) {\n                    throw new Error(`Missing ABI definition for ${rawAction.account}`);\n                }\n                abi = ABI.from(rawAbi);\n            }\n            const type = abi.getActionType(rawAction.name);\n            if (!type) {\n                throw new Error(`Missing type for action ${rawAction.account}:${rawAction.name} in ABI`);\n            }\n            let data = rawAction.decodeData(abi);\n            let authorization = rawAction.authorization;\n            if (signer) {\n                const signerPerm = PermissionLevel.from(signer);\n                const resolve = (value) => {\n                    if (value instanceof Name) {\n                        if (value.equals(PlaceholderName)) {\n                            return signerPerm.actor;\n                        }\n                        else if (value.equals(PlaceholderPermission)) {\n                            return signerPerm.permission;\n                        }\n                        else {\n                            return value;\n                        }\n                    }\n                    else if (Array.isArray(value)) {\n                        return value.map(resolve);\n                    }\n                    else if (typeof value === 'object' && value !== null) {\n                        for (const key of Object.keys(value)) {\n                            value[key] = resolve(value[key]);\n                        }\n                        return value;\n                    }\n                    else {\n                        return value;\n                    }\n                };\n                data = resolve(data);\n                authorization = authorization.map((auth) => {\n                    let { actor, permission } = auth;\n                    if (actor.equals(PlaceholderName)) {\n                        actor = signerPerm.actor;\n                    }\n                    if (permission.equals(PlaceholderPermission)) {\n                        permission = signerPerm.permission;\n                    }\n                    // backwards compatibility, actor placeholder will also resolve to permission when used in auth\n                    if (permission.equals(PlaceholderName)) {\n                        permission = signerPerm.permission;\n                    }\n                    return PermissionLevel.from({ actor, permission });\n                });\n            }\n            return {\n                ...rawAction,\n                authorization,\n                data,\n            };\n        });\n    }\n    resolveTransaction(abis, signer, ctx = {}) {\n        const tx = this.getRawTransaction();\n        if (!this.isIdentity() && !hasTapos(tx)) {\n            if (ctx.expiration !== undefined &&\n                ctx.ref_block_num !== undefined &&\n                ctx.ref_block_prefix !== undefined) {\n                tx.expiration = TimePointSec.from(ctx.expiration);\n                tx.ref_block_num = UInt16.from(ctx.ref_block_num);\n                tx.ref_block_prefix = UInt32.from(ctx.ref_block_prefix);\n            }\n            else if (ctx.block_num !== undefined &&\n                ctx.ref_block_prefix !== undefined &&\n                ctx.timestamp !== undefined) {\n                tx.expiration = expirationTime(ctx.timestamp, ctx.expire_seconds);\n                tx.ref_block_num = UInt16.from(ctx.block_num);\n                tx.ref_block_prefix = UInt32.from(ctx.ref_block_prefix);\n            }\n            else {\n                throw new Error('Invalid transaction context, need either a reference block or explicit TaPoS values');\n            }\n        }\n        else if (this.isIdentity() && this.version > 2) {\n            // From ESR version 3 all identity requests have expiration\n            tx.expiration = ctx.expiration\n                ? TimePointSec.from(ctx.expiration)\n                : expirationTime(ctx.timestamp, ctx.expire_seconds);\n        }\n        const actions = this.resolveActions(abis, signer);\n        // TODO: resolve context free actions\n        const context_free_actions = tx.context_free_actions;\n        return { ...tx, context_free_actions, actions };\n    }\n    resolve(abis, signer, ctx = {}) {\n        const tx = this.resolveTransaction(abis, signer, ctx);\n        const actions = tx.actions.map((action) => {\n            let abi;\n            if (isIdentity(action)) {\n                abi = this.constructor.identityAbi(this.version);\n            }\n            else {\n                abi = abis.get(action.account.toString());\n            }\n            if (!abi) {\n                throw new Error(`Missing ABI definition for ${action.account}`);\n            }\n            const type = abi.getActionType(action.name);\n            const data = Serializer.encode({ object: action.data, type, abi });\n            return Action.from({ ...action, data });\n        });\n        const transaction = Transaction.from({ ...tx, actions });\n        let chainId;\n        if (this.isMultiChain()) {\n            if (!ctx.chainId) {\n                throw new Error('Missing chosen chain ID for multi-chain request');\n            }\n            chainId = ChainId.from(ctx.chainId);\n            const ids = this.getChainIds();\n            if (ids && !ids.some((id) => chainId.equals(id))) {\n                throw new Error('Trying to resolve for chain ID not defined in request');\n            }\n        }\n        else {\n            chainId = this.getChainId();\n        }\n        return new ResolvedSigningRequest(this, PermissionLevel.from(signer), transaction, tx, chainId);\n    }\n    /**\n     * Get the id of the chain where this request is valid.\n     * @returns The 32-byte chain id as hex encoded string.\n     */\n    getChainId() {\n        return this.data.chain_id.chainId;\n    }\n    /**\n     * Chain IDs this request is valid for, only valid for multi chain requests. Value of `null` when `isMultiChain` is true denotes any chain.\n     */\n    getChainIds() {\n        if (!this.isMultiChain()) {\n            return null;\n        }\n        const ids = this.getInfoKey('chain_ids', { type: ChainIdVariant, array: true });\n        if (ids) {\n            return ids.map((id) => id.chainId);\n        }\n        return null;\n    }\n    /**\n     * Set chain IDs this request is valid for, only considered for multi chain requests.\n     */\n    setChainIds(ids) {\n        const value = ids.map((id) => ChainId.from(id).chainVariant);\n        this.setInfoKey('chain_ids', value, { type: ChainIdVariant, array: true });\n    }\n    /**\n     * True if chainId is set to chain alias `0` which indicates that the request is valid for any chain.\n     */\n    isMultiChain() {\n        return (this.data.chain_id.variantIdx === 0 &&\n            this.data.chain_id.value.value === ChainName.UNKNOWN);\n    }\n    /** Return the actions in this request with action data encoded. */\n    getRawActions() {\n        const req = this.data.req;\n        switch (req.variantName) {\n            case 'action':\n                return [req.value];\n            case 'action[]':\n                return req.value;\n            case 'identity': {\n                if (this.version === 2) {\n                    const id = req.value;\n                    let data = '0101000000000000000200000000000000'; // placeholder permission\n                    let authorization = [PlaceholderAuth];\n                    if (id.permission) {\n                        data = Serializer.encode({ object: id });\n                        authorization = [id.permission];\n                    }\n                    return [\n                        Action.from({\n                            account: '',\n                            name: 'identity',\n                            authorization,\n                            data,\n                        }),\n                    ];\n                }\n                else {\n                    // eslint-disable-next-line prefer-const\n                    let { scope, permission } = req.value;\n                    if (!permission) {\n                        permission = PlaceholderAuth;\n                    }\n                    const data = Serializer.encode({ object: { scope, permission }, type: IdentityV3 });\n                    return [\n                        Action.from({\n                            account: '',\n                            name: 'identity',\n                            authorization: [permission],\n                            data,\n                        }),\n                    ];\n                }\n            }\n            case 'transaction':\n                return req.value.actions;\n            default:\n                throw new Error('Invalid signing request data');\n        }\n    }\n    /** Unresolved transaction. */\n    getRawTransaction() {\n        const req = this.data.req;\n        switch (req.variantName) {\n            case 'transaction':\n                return Transaction.from({ ...req.value });\n            case 'action':\n            case 'action[]':\n            case 'identity':\n                return Transaction.from({\n                    actions: this.getRawActions(),\n                    context_free_actions: [],\n                    transaction_extensions: [],\n                    expiration: '1970-01-01T00:00:00.000',\n                    ref_block_num: 0,\n                    ref_block_prefix: 0,\n                    max_cpu_usage_ms: 0,\n                    max_net_usage_words: 0,\n                    delay_sec: 0,\n                });\n            default:\n                throw new Error('Invalid signing request data');\n        }\n    }\n    /** Whether the request is an identity request. */\n    isIdentity() {\n        return this.data.req.variantName === 'identity';\n    }\n    /** Whether the request should be broadcast by signer. */\n    shouldBroadcast() {\n        if (this.isIdentity()) {\n            return false;\n        }\n        return this.data.flags.broadcast;\n    }\n    /**\n     * Present if the request is an identity request and requests a specific account.\n     * @note This returns `nil` unless a specific identity has been requested,\n     *       use `isIdentity` to check id requests.\n     */\n    getIdentity() {\n        if (!this.isIdentity()) {\n            return null;\n        }\n        const id = this.data.req.value;\n        if (id.permission && !id.permission.actor.equals(PlaceholderName)) {\n            return id.permission.actor;\n        }\n        return null;\n    }\n    /**\n     * Present if the request is an identity request and requests a specific permission.\n     * @note This returns `nil` unless a specific permission has been requested,\n     *       use `isIdentity` to check id requests.\n     */\n    getIdentityPermission() {\n        if (!this.isIdentity()) {\n            return null;\n        }\n        const id = this.data.req.value;\n        if (id.permission && !id.permission.permission.equals(PlaceholderPermission)) {\n            return id.permission.permission;\n        }\n        return null;\n    }\n    /**\n     * Present if the request is an identity request and requests a specific permission.\n     * @note This returns `nil` unless a specific permission has been requested,\n     *       use `isIdentity` to check id requests.\n     */\n    getIdentityScope() {\n        if (!this.isIdentity() || this.version <= 2) {\n            return null;\n        }\n        const id = this.data.req.value;\n        return id.scope;\n    }\n    /** Get raw info dict */\n    getRawInfo() {\n        const rv = {};\n        for (const { key, value } of this.data.info) {\n            rv[key] = value;\n        }\n        return rv;\n    }\n    getRawInfoKey(key) {\n        const pair = this.data.info.find((pair) => pair.key === key);\n        if (pair) {\n            return pair.value;\n        }\n    }\n    setRawInfoKey(key, value) {\n        let pair = this.data.info.find((pair) => pair.key === key);\n        if (!pair) {\n            pair = InfoPair.from({ key, value });\n            this.data.info.push(pair);\n        }\n        else {\n            pair.value = Bytes.from(value);\n        }\n    }\n    /** Set a metadata key. */\n    setInfoKey(key, object, type) {\n        let data;\n        if (typeof object === 'string' && !type) {\n            // match old behavior where strings encode to raw utf8 as opposed to\n            // eosio-abi encoded strings (varuint32 length prefix + utf8 bytes)\n            data = Bytes.from(object, 'utf8');\n        }\n        else {\n            data = Serializer.encode({ object, type });\n        }\n        this.setRawInfoKey(key, data);\n    }\n    getInfoKey(key, type) {\n        const data = this.getRawInfoKey(key);\n        if (data) {\n            if (type) {\n                return Serializer.decode({ data, type });\n            }\n            else {\n                // assume utf8 string if no type is given\n                return data.utf8String;\n            }\n        }\n    }\n    /** Return a deep copy of this request. */\n    clone() {\n        let signature;\n        if (this.signature) {\n            signature = RequestSignature.from(JSON.parse(JSON.stringify(this.signature)));\n        }\n        const RequestData = this.constructor.storageType(this.version);\n        const data = RequestData.from(JSON.parse(JSON.stringify(this.data)));\n        return new SigningRequest(this.version, data, this.zlib, this.abiProvider, signature);\n    }\n    // Convenience methods.\n    toString() {\n        return this.encode();\n    }\n    toJSON() {\n        return this.encode();\n    }\n}\nclass ResolvedSigningRequest {\n    constructor(request, signer, transaction, resolvedTransaction, chainId) {\n        this.request = request;\n        this.signer = signer;\n        this.transaction = transaction;\n        this.resolvedTransaction = resolvedTransaction;\n        this.chainId = chainId;\n    }\n    /** Recreate a resolved request from a callback payload. */\n    static async fromPayload(payload, options = {}) {\n        const request = SigningRequest.from(payload.req, options);\n        const abis = await request.fetchAbis();\n        return request.resolve(abis, { actor: payload.sa, permission: payload.sp }, {\n            ref_block_num: payload.rbn,\n            ref_block_prefix: payload.rid,\n            expiration: payload.ex,\n            chainId: payload.cid || request.getChainId(),\n        });\n    }\n    get serializedTransaction() {\n        return Serializer.encode({ object: this.transaction }).array;\n    }\n    get signingDigest() {\n        return this.transaction.signingDigest(this.chainId);\n    }\n    getCallback(signatures, blockNum) {\n        const { callback, flags } = this.request.data;\n        if (!callback || callback.length === 0) {\n            return null;\n        }\n        if (!signatures || signatures.length === 0) {\n            throw new Error('Must have at least one signature to resolve callback');\n        }\n        const sigs = signatures.map((sig) => Signature.from(sig));\n        const payload = {\n            sig: String(sigs[0]),\n            tx: String(this.transaction.id),\n            rbn: String(this.transaction.ref_block_num),\n            rid: String(this.transaction.ref_block_prefix),\n            ex: String(this.transaction.expiration),\n            req: this.request.encode(),\n            sa: String(this.signer.actor),\n            sp: String(this.signer.permission),\n            cid: String(this.chainId),\n        };\n        for (const [n, sig] of sigs.slice(1).entries()) {\n            payload[`sig${n}`] = String(sig);\n        }\n        if (blockNum) {\n            payload.bn = String(UInt32.from(blockNum));\n        }\n        const url = callback.replace(/({{([a-z0-9]+)}})/g, (_1, _2, m) => {\n            return payload[m] || '';\n        });\n        return {\n            background: flags.background,\n            payload,\n            url,\n        };\n    }\n    getIdentityProof(signature) {\n        if (!this.request.isIdentity()) {\n            throw new Error('Not a identity request');\n        }\n        return IdentityProof.from({\n            chainId: this.chainId,\n            scope: this.request.getIdentityScope(),\n            expiration: this.transaction.expiration,\n            signer: this.signer,\n            signature,\n        });\n    }\n}\nfunction encodeAction(action, abis) {\n    if (Bytes.isBytes(action.data) || action.data.constructor.abiName !== undefined) {\n        return Action.from(action);\n    }\n    const abi = abis[String(Name.from(action.account))];\n    if (!abi) {\n        throw new Error(`Missing ABI for ${action.account}`);\n    }\n    return Action.from(action, abi);\n}\nfunction isIdentity(action) {\n    const account = Name.from(action.account);\n    const name = Name.from(action.name);\n    return account.rawValue.equals(0) && name.equals('identity');\n}\nfunction hasTapos(tx) {\n    return !(tx.expiration.value.value === 0 &&\n        tx.ref_block_num.value === 0 &&\n        tx.ref_block_prefix.value === 0);\n}\nfunction expirationTime(timestamp, expireSeconds = 60) {\n    const ts = TimePointSec.from(timestamp || new Date());\n    const exp = UInt32.from(expireSeconds);\n    return TimePointSec.fromMilliseconds(ts.toMilliseconds() + exp.value * 1000);\n}\n\nexport { AccountName, base64u as Base64u, ChainAlias, ChainId, ChainIdVariant, ChainName, IdentityProof, IdentityV2, IdentityV3, InfoPair, PermissionName, PlaceholderAuth, PlaceholderName, PlaceholderPermission, ProtocolVersion, RequestDataV2, RequestDataV3, RequestFlags, RequestSignature, RequestVariantV2, RequestVariantV3, ResolvedSigningRequest, SigningRequest };\n//# sourceMappingURL=esr.m.js.map\n"]},"metadata":{},"sourceType":"module"}