{"ast":null,"code":"/**\n * EOSIO Core v0.3.2\n * https://github.com/greymass/eosio-core\n *\n * @license\n * Copyright (c) 2020 FFF00 Agents AB & Greymass Inc. All Rights Reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \n *  1. Redistribution of source code must retain the above copyright notice, this\n *     list of conditions and the following disclaimer.\n * \n *  2. Redistribution in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n * \n *  3. Neither the name of the copyright holder nor the names of its contributors\n *     may be used to endorse or promote products derived from this software without\n *     specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE\n * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.\n */\nimport rand from 'brorand';\nimport { sha256, sha512, ripemd160 } from 'hash.js';\nimport BN from 'bn.js';\nimport { ec } from 'elliptic';\nimport { __decorate } from 'tslib';\n\nfunction arrayEquals(a, b) {\n  const len = a.length;\n\n  if (len !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction arrayEquatableEquals(a, b) {\n  const len = a.length;\n\n  if (len !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < len; i++) {\n    if (!a[i].equals(b[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nconst hexLookup = {};\n\nfunction buildHexLookup() {\n  hexLookup.enc = new Array(0xff);\n  hexLookup.dec = {};\n\n  for (let i = 0; i <= 0xff; ++i) {\n    const b = i.toString(16).padStart(2, '0');\n    hexLookup.enc[i] = b;\n    hexLookup.dec[b] = i;\n  }\n}\n\nfunction arrayToHex(array) {\n  if (!hexLookup.enc) {\n    buildHexLookup();\n  }\n\n  const len = array.length;\n  const rv = new Array(len);\n\n  for (let i = 0; i < len; ++i) {\n    rv[i] = hexLookup.enc[array[i]];\n  }\n\n  return rv.join('');\n}\n\nfunction hexToArray(hex) {\n  if (!hexLookup.dec) {\n    buildHexLookup();\n  }\n\n  if (typeof hex !== 'string') {\n    throw new Error('Expected string containing hex digits');\n  }\n\n  if (hex.length % 2) {\n    throw new Error('Odd number of hex digits');\n  }\n\n  hex = hex.toLowerCase();\n  const len = hex.length / 2;\n  const result = new Uint8Array(len);\n\n  for (let i = 0; i < len; i++) {\n    const b = hexLookup.dec[hex[i * 2] + hex[i * 2 + 1]];\n\n    if (b === undefined) {\n      throw new Error('Expected hex string');\n    }\n\n    result[i] = b;\n  }\n\n  return result;\n}\n/** Generate N random bytes, throws if a secure random source isn't available. */\n\n\nfunction secureRandom(length) {\n  return rand(length);\n}\n/** Used in isInstanceOf checks so we don't spam with warnings. */\n\n\nlet didWarn = false;\n/** Check if object in instance of class. */\n\nfunction isInstanceOf(object, someClass) {\n  if (object instanceof someClass) {\n    return true;\n  }\n\n  if (object == null || typeof object !== 'object') {\n    return false;\n  } // not an actual instance but since bundlers can fail to dedupe stuff or\n  // multiple versions can be included we check for compatibility if possible\n\n\n  const className = someClass['__className'] || someClass['abiName'];\n\n  if (!className) {\n    return false;\n  }\n\n  let instanceClass = object.constructor;\n  let isAlienInstance = false;\n\n  while (instanceClass && !isAlienInstance) {\n    const instanceClassName = instanceClass['__className'] || instanceClass['abiName'];\n\n    if (!instanceClassName) {\n      break;\n    }\n\n    isAlienInstance = className == instanceClassName;\n    instanceClass = Object.getPrototypeOf(instanceClass);\n  }\n\n  if (isAlienInstance && !didWarn) {\n    // eslint-disable-next-line no-console\n    console.warn(`Detected alien instance of ${className}, this usually means more than one version of @greymass/eosio has been included in your bundle.`);\n    didWarn = true;\n  }\n\n  return isAlienInstance;\n}\n\nclass Bytes {\n  constructor(array = new Uint8Array()) {\n    this.array = array;\n  }\n\n  static from(value, encoding) {\n    if (isInstanceOf(value, this)) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      return this.fromString(value, encoding);\n    }\n\n    if (isInstanceOf(value, Uint8Array)) {\n      return new this(value);\n    }\n\n    return new this(new Uint8Array(value));\n  }\n\n  static fromString(value, encoding = 'hex') {\n    if (encoding === 'hex') {\n      const array = hexToArray(value);\n      return new this(array);\n    } else if (encoding == 'utf8') {\n      const encoder = new TextEncoder();\n      return new this(encoder.encode(value));\n    } else {\n      throw new Error(`Unknown encoding: ${encoding}`);\n    }\n  }\n\n  static fromABI(decoder) {\n    const len = decoder.readVaruint32();\n    return new this(decoder.readArray(len));\n  }\n\n  static equal(a, b) {\n    return this.from(a).equals(this.from(b));\n  }\n\n  static random(length) {\n    return new this(secureRandom(length));\n  }\n  /** Return true if given value is a valid `BytesType`. */\n\n\n  static isBytes(value) {\n    if (isInstanceOf(value, Bytes) || isInstanceOf(value, Uint8Array)) {\n      return true;\n    }\n\n    if (Array.isArray(value) && value.every(v => typeof v === 'number')) {\n      return true;\n    }\n\n    if (typeof value === 'string' && (/[\\da-f]/i.test(value) || value === '')) {\n      return true;\n    }\n\n    return false;\n  }\n\n  get hexString() {\n    return arrayToHex(this.array);\n  }\n\n  get utf8String() {\n    return new TextDecoder().decode(this.array);\n  }\n\n  appending(other) {\n    other = Bytes.from(other);\n    const newSize = this.array.byteLength + other.array.byteLength;\n    const buffer = new ArrayBuffer(newSize);\n    const array = new Uint8Array(buffer);\n    array.set(this.array);\n    array.set(other.array, this.array.byteLength);\n    return new Bytes(array);\n  }\n\n  droppingFirst(n = 1) {\n    return new Bytes(this.array.subarray(n));\n  }\n\n  copy() {\n    const buffer = new ArrayBuffer(this.array.byteLength);\n    const array = new Uint8Array(buffer);\n    array.set(this.array);\n    return new Bytes(array);\n  }\n\n  equals(other) {\n    return arrayEquals(this.array, Bytes.from(other).array);\n  }\n\n  toString(encoding = 'hex') {\n    if (encoding === 'hex') {\n      return this.hexString;\n    } else if (encoding === 'utf8') {\n      return this.utf8String;\n    } else {\n      throw new Error(`Unknown encoding: ${encoding}`);\n    }\n  }\n\n  toABI(encoder) {\n    encoder.writeVaruint32(this.array.byteLength);\n    encoder.writeArray(this.array);\n  }\n\n  toJSON() {\n    return this.hexString;\n  }\n\n}\n\nBytes.abiName = 'bytes';\n\nclass Checksum {\n  constructor(array) {\n    const byteSize = this.constructor.byteSize;\n\n    if (array.byteLength !== byteSize) {\n      throw new Error(`Checksum size mismatch, expected ${byteSize} bytes got ${array.byteLength}`);\n    }\n\n    this.array = array;\n  }\n\n  static from(value) {\n    if (isInstanceOf(value, this)) {\n      return value;\n    }\n\n    if (isInstanceOf(value, Checksum)) {\n      return new this(value.array);\n    }\n\n    return new this(Bytes.from(value).array);\n  }\n\n  static fromABI(decoder) {\n    return new this(decoder.readArray(this.byteSize));\n  }\n\n  equals(other) {\n    const self = this.constructor;\n\n    try {\n      return arrayEquals(this.array, self.from(other).array);\n    } catch {\n      return false;\n    }\n  }\n\n  get hexString() {\n    return arrayToHex(this.array);\n  }\n\n  toABI(encoder) {\n    encoder.writeArray(this.array);\n  }\n\n  toString() {\n    return this.hexString;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n\nChecksum.abiName = '__checksum';\n\nclass Checksum256 extends Checksum {\n  static from(value) {\n    return super.from(value);\n  }\n\n  static hash(data) {\n    const digest = new Uint8Array(sha256().update(Bytes.from(data).array).digest());\n    return new Checksum256(digest);\n  }\n\n}\n\nChecksum256.abiName = 'checksum256';\nChecksum256.byteSize = 32;\n\nclass Checksum512 extends Checksum {\n  static from(value) {\n    return super.from(value);\n  }\n\n  static hash(data) {\n    const digest = new Uint8Array(sha512().update(Bytes.from(data).array).digest());\n    return new Checksum512(digest);\n  }\n\n}\n\nChecksum512.abiName = 'checksum512';\nChecksum512.byteSize = 64;\n\nclass Checksum160 extends Checksum {\n  static from(value) {\n    return super.from(value);\n  }\n\n  static hash(data) {\n    const digest = new Uint8Array(ripemd160().update(Bytes.from(data).array).digest());\n    return new Checksum160(digest);\n  }\n\n}\n\nChecksum160.abiName = 'checksum160';\nChecksum160.byteSize = 20;\n/** Supported EOSIO curve types. */\n\nvar CurveType;\n\n(function (CurveType) {\n  CurveType[\"K1\"] = \"K1\";\n  CurveType[\"R1\"] = \"R1\";\n  CurveType[\"WA\"] = \"WA\";\n})(CurveType || (CurveType = {}));\n\n(function (CurveType) {\n  function indexFor(value) {\n    switch (value) {\n      case CurveType.K1:\n        return 0;\n\n      case CurveType.R1:\n        return 1;\n\n      case CurveType.WA:\n        return 2;\n\n      default:\n        throw new Error(`Unknown curve type: ${value}`);\n    }\n  }\n\n  CurveType.indexFor = indexFor;\n\n  function from(value) {\n    let index;\n\n    if (typeof value !== 'number') {\n      index = CurveType.indexFor(value);\n    } else {\n      index = value;\n    }\n\n    switch (index) {\n      case 0:\n        return CurveType.K1;\n\n      case 1:\n        return CurveType.R1;\n\n      case 2:\n        return CurveType.WA;\n\n      default:\n        throw new Error('Unknown curve type');\n    }\n  }\n\n  CurveType.from = from;\n})(CurveType || (CurveType = {}));\n/** Return a ABI definition for given ABISerializableType. */\n\n\nfunction synthesizeABI(type) {\n  const structs = [];\n  const variants = [];\n  const aliases = [];\n  const seen = new Set();\n\n  const resolveAbiType = t => {\n    let typeName;\n\n    if (typeof t.type !== 'string') {\n      typeName = resolve(t.type);\n    } else {\n      typeName = t.type;\n    }\n\n    if (t.array === true) {\n      typeName += '[]';\n    }\n\n    if (t.extension === true) {\n      typeName += '$';\n    }\n\n    if (t.optional === true) {\n      typeName += '?';\n    }\n\n    return typeName;\n  };\n\n  const resolve = t => {\n    if (!t.abiName) {\n      throw new Error('Encountered non-conforming type');\n    } else if (t.abiName === '__struct') {\n      throw new Error('Misconfigured Struct subclass, did you forget @Struct.type?');\n    }\n\n    if (seen.has(t)) {\n      return t.abiName;\n    }\n\n    seen.add(t);\n\n    if (t.abiAlias) {\n      aliases.push({\n        new_type_name: t.abiName,\n        type: resolveAbiType(t.abiAlias)\n      });\n    } else if (t.abiFields) {\n      const fields = t.abiFields.map(field => {\n        return {\n          name: field.name,\n          type: resolveAbiType(field)\n        };\n      });\n      const struct = {\n        base: t.abiBase ? resolve(t.abiBase) : '',\n        name: t.abiName,\n        fields\n      };\n      structs.push(struct);\n    } else if (t.abiVariant) {\n      const variant = {\n        name: t.abiName,\n        types: t.abiVariant.map(resolveAbiType)\n      };\n      variants.push(variant);\n    }\n\n    return t.abiName;\n  };\n\n  const root = resolve(type);\n  return {\n    abi: ABI.from({\n      structs,\n      variants,\n      types: aliases\n    }),\n    types: Array.from(seen),\n    root\n  };\n}\n\nfunction abiTypeString(type) {\n  let typeName = typeof type.type === 'string' ? type.type : type.type.abiName;\n\n  if (type.array === true) {\n    typeName += '[]';\n  }\n\n  if (type.extension === true) {\n    typeName += '$';\n  }\n\n  if (type.optional === true) {\n    typeName += '?';\n  }\n\n  return typeName;\n}\n\nfunction isTypeDescriptor(type) {\n  return typeof type !== 'string' && type.abiName === undefined && type.type !== undefined;\n}\n\nfunction toTypeDescriptor(type) {\n  if (typeof type === 'string') {\n    return {\n      type\n    };\n  }\n\n  if (typeof type.abiName !== 'undefined') {\n    return {\n      type: type\n    };\n  }\n\n  return type;\n}\n\nconst StringType = {\n  abiName: 'string',\n  fromABI: decoder => {\n    return decoder.readString();\n  },\n  from: string => string,\n  toABI: (string, encoder) => {\n    encoder.writeString(string);\n  }\n};\nconst BoolType = {\n  abiName: 'bool',\n  fromABI: decoder => {\n    return decoder.readByte() === 1;\n  },\n  from: value => value,\n  toABI: (value, encoder) => {\n    encoder.writeByte(value === true ? 1 : 0);\n  }\n};\n\nfunction getBuiltins() {\n  return [// types represented by JavaScript builtins\n  BoolType, StringType, // types represented by Classes\n  Asset, Asset.Symbol, Asset.SymbolCode, BlockTimestamp, Bytes, Checksum160, Checksum256, Checksum512, ExtendedAsset, Float128, Float32, Float64, Int128, Int16, Int32, Int64, Int8, Name, PublicKey, Signature, TimePoint, TimePointSec, UInt128, UInt16, UInt32, UInt64, UInt8, VarInt, VarUInt];\n}\n\nfunction buildTypeLookup(additional = []) {\n  const rv = {};\n  const builtins = getBuiltins();\n\n  for (const type of builtins) {\n    rv[type.abiName] = type;\n  }\n\n  for (const type of additional) {\n    if (!type.abiName) {\n      throw new Error('Invalid type');\n    }\n\n    rv[type.abiName] = type;\n  }\n\n  return rv;\n}\n\nfunction getTypeName(object) {\n  if (object.constructor && object.constructor.abiName !== undefined) {\n    return object.constructor.abiName;\n  }\n\n  if (Array.isArray(object)) {\n    const types = object.map(getTypeName);\n    const type = types[0];\n\n    if (!type || !types.every(t => t === type)) {\n      return;\n    }\n\n    return type + '[]';\n  }\n\n  switch (typeof object) {\n    case 'boolean':\n      return 'bool';\n\n    case 'string':\n      return 'string';\n  }\n}\n\nfunction getType(object, name = 'jsobj') {\n  var _a;\n\n  if (object.constructor && object.constructor.abiName !== undefined) {\n    return object.constructor;\n  }\n\n  if (Array.isArray(object)) {\n    // check for array of all ABISerializableType with same type name\n    const types = object.map(v => {\n      return getType(v, name);\n    });\n    const type = types[0];\n\n    if (!type) {\n      return; // some type not known\n    }\n\n    if (!types.every(t => t && t.abiName === type.abiName)) {\n      return; // not all types are the same\n    }\n\n    return type;\n  }\n\n  const objectType = typeof object;\n\n  if (objectType === 'object' && object !== null) {\n    const fields = Object.keys(object).map(key => {\n      return {\n        name: key,\n        type: getType(object[key], name + '_nested')\n      };\n    });\n\n    if (fields.find(field => !field.type)) {\n      return; // encountered unknown type\n    }\n\n    return _a = class extends Struct {}, _a.abiName = name, _a.abiFields = fields, _a;\n  }\n\n  switch (objectType) {\n    case 'boolean':\n      return BoolType;\n\n    case 'string':\n      return StringType;\n  }\n}\n/**\n * EOSIO ABI Decoder\n */\n\n\nclass DecodingError extends Error {\n  constructor(ctx, underlyingError) {\n    const path = ctx.codingPath.map(({\n      field,\n      type\n    }) => {\n      if (typeof field === 'number') {\n        return field;\n      } else {\n        return `${field}<${type.typeName}>`;\n      }\n    }).join('.');\n    super(`Decoding error at ${path}: ${underlyingError.message}`);\n    this.stack = underlyingError.stack;\n    this.ctx = ctx;\n    this.underlyingError = underlyingError;\n  }\n\n}\n\nDecodingError.__className = 'DecodingError';\n\nfunction abiDecode(args) {\n  const descriptor = toTypeDescriptor(args.type);\n  const typeName = abiTypeString(descriptor);\n  const customTypes = args.customTypes || [];\n  let abi;\n\n  if (args.abi) {\n    abi = ABI.from(args.abi);\n  } else {\n    try {\n      let type;\n\n      if (typeof descriptor.type === 'string') {\n        const lookup = buildTypeLookup(customTypes);\n        const rName = new ABI.ResolvedType(descriptor.type).name; // type name w/o suffixes\n\n        type = lookup[rName];\n\n        if (!type) {\n          throw new Error(`Unknown type: ${descriptor.type}`);\n        }\n      } else {\n        type = descriptor.type;\n      }\n\n      const synthesized = synthesizeABI(type);\n      abi = synthesized.abi;\n      customTypes.push(...synthesized.types);\n    } catch (error) {\n      throw Error(`Unable to synthesize ABI for: ${typeName} (${error.message}). ` + 'To decode non-class types you need to pass the ABI definition manually.');\n    }\n  }\n\n  const resolved = abi.resolveType(typeName);\n\n  if (typeof descriptor.type !== 'string') {\n    customTypes.unshift(descriptor.type);\n  }\n\n  const ctx = {\n    types: buildTypeLookup(customTypes),\n    codingPath: [{\n      field: 'root',\n      type: resolved\n    }]\n  };\n\n  try {\n    if (args.data) {\n      let decoder;\n\n      if (isInstanceOf(args.data, ABIDecoder)) {\n        decoder = args.data;\n      } else {\n        const bytes = Bytes.from(args.data);\n        decoder = new ABIDecoder(bytes.array);\n      }\n\n      if (args.metadata) {\n        decoder.metadata = args.metadata;\n      }\n\n      return decodeBinary(resolved, decoder, ctx);\n    } else if (args.object !== undefined) {\n      return decodeObject(args.object, resolved, ctx);\n    } else if (args.json) {\n      return decodeObject(JSON.parse(args.json), resolved, ctx);\n    } else {\n      throw new Error('Nothing to decode, you must set one of data, json, object');\n    }\n  } catch (error) {\n    throw new DecodingError(ctx, error);\n  }\n}\n/** Marker for objects when they have been resolved, i.e. their types `from` factory method will not need to resolve children. */\n\n\nconst Resolved = Symbol('Resolved');\n\nfunction decodeBinary(type, decoder, ctx) {\n  if (ctx.codingPath.length > 32) {\n    throw new Error('Maximum decoding depth exceeded');\n  }\n\n  if (type.isExtension) {\n    if (!decoder.canRead()) {\n      return undefined;\n    }\n  }\n\n  if (type.isOptional) {\n    if (decoder.readByte() === 0) {\n      return null;\n    }\n  }\n\n  if (type.isArray) {\n    const len = decoder.readVaruint32();\n    const rv = [];\n\n    for (let i = 0; i < len; i++) {\n      ctx.codingPath.push({\n        field: i,\n        type\n      });\n      rv.push(decodeInner());\n      ctx.codingPath.pop();\n    }\n\n    return rv;\n  } else {\n    return decodeInner();\n  }\n\n  function decodeInner() {\n    const abiType = ctx.types[type.name];\n\n    if (abiType && abiType.fromABI) {\n      return abiType.fromABI(decoder);\n    } else {\n      if (type.ref) {\n        // follow type alias\n        ctx.codingPath.push({\n          field: '',\n          type: type.ref\n        });\n        const rv = decodeBinary(type.ref, decoder, ctx);\n        ctx.codingPath.pop();\n        return rv;\n      } else if (type.fields) {\n        const fields = type.allFields;\n\n        if (!fields) {\n          throw new Error('Invalid struct fields');\n        }\n\n        const rv = {};\n\n        for (const field of fields) {\n          ctx.codingPath.push({\n            field: field.name,\n            type: field.type\n          });\n          rv[field.name] = decodeBinary(field.type, decoder, ctx);\n          ctx.codingPath.pop();\n        }\n\n        if (abiType) {\n          rv[Resolved] = true;\n          return abiType.from(rv);\n        } else {\n          return rv;\n        }\n      } else if (type.variant) {\n        const vIdx = decoder.readByte();\n        const vType = type.variant[vIdx];\n\n        if (!vType) {\n          throw new Error(`Unknown variant idx: ${vIdx}`);\n        }\n\n        ctx.codingPath.push({\n          field: `v${vIdx}`,\n          type: vType\n        });\n        const rv = [vType.typeName, decodeBinary(vType, decoder, ctx)];\n        ctx.codingPath.pop();\n\n        if (abiType) {\n          return abiType.from(rv);\n        } else {\n          return rv;\n        }\n      } else if (abiType) {\n        throw new Error('Invalid type');\n      } else {\n        throw new Error(type.name === 'any' ? \"Unable to decode 'any' type from binary\" : 'Unknown type');\n      }\n    }\n  }\n}\n\nfunction decodeObject(value, type, ctx) {\n  if (value === null || value === undefined) {\n    if (type.isOptional || type.isExtension) {\n      return null;\n    } else {\n      throw new Error(`Unexpectedly encountered ${value} for non-optional`);\n    }\n  } else if (type.isArray) {\n    if (!Array.isArray(value)) {\n      throw new Error('Expected array');\n    }\n\n    const rv = [];\n    const len = value.length;\n\n    for (let i = 0; i < len; i++) {\n      ctx.codingPath.push({\n        field: i,\n        type\n      });\n      rv.push(decodeInner(value[i]));\n      ctx.codingPath.pop();\n    }\n\n    return rv;\n  } else {\n    return decodeInner(value);\n  }\n\n  function decodeInner(value) {\n    const abiType = ctx.types[type.name];\n\n    if (type.ref && !abiType) {\n      // follow type alias\n      return decodeObject(value, type.ref, ctx);\n    } else if (type.fields) {\n      if (typeof value !== 'object') {\n        throw new Error('Expected object');\n      }\n\n      if (typeof abiType === 'function' && isInstanceOf(value, abiType)) {\n        return value;\n      }\n\n      const fields = type.allFields;\n\n      if (!fields) {\n        throw new Error('Invalid struct fields');\n      }\n\n      const struct = {};\n\n      for (const field of fields) {\n        ctx.codingPath.push({\n          field: field.name,\n          type: field.type\n        });\n        struct[field.name] = decodeObject(value[field.name], field.type, ctx);\n        ctx.codingPath.pop();\n      }\n\n      if (abiType) {\n        struct[Resolved] = true;\n        return abiType.from(struct);\n      } else {\n        return struct;\n      }\n    } else if (type.variant) {\n      let vName;\n\n      if (Array.isArray(value) && value.length === 2 && typeof value[0] === 'string') {\n        vName = value[0];\n        value = value[1];\n      } else if (isInstanceOf(value, Variant)) {\n        vName = value.variantName;\n        value = value.value;\n      } else {\n        vName = getTypeName(value);\n      }\n\n      const vIdx = type.variant.findIndex(t => t.typeName === vName);\n\n      if (vIdx === -1) {\n        throw new Error(`Unknown variant type: ${vName}`);\n      }\n\n      const vType = type.variant[vIdx];\n      ctx.codingPath.push({\n        field: `v${vIdx}`,\n        type: vType\n      });\n      const rv = [vType.typeName, decodeObject(value, vType, ctx)];\n      ctx.codingPath.pop();\n\n      if (abiType) {\n        rv[Resolved] = true;\n        return abiType.from(rv);\n      } else {\n        return rv;\n      }\n    } else {\n      if (!abiType) {\n        // special case for `any` when decoding from object\n        if (type.name === 'any') {\n          return value;\n        }\n\n        throw new Error('Unknown type');\n      }\n\n      return abiType.from(value);\n    }\n  }\n}\n\nclass ABIDecoder {\n  constructor(array) {\n    this.array = array;\n    this.pos = 0;\n    this.textDecoder = new TextDecoder('utf-8', {\n      fatal: true\n    });\n    /** User declared metadata, can be used to pass info to instances when decoding.  */\n\n    this.metadata = {};\n    this.data = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  }\n\n  canRead(bytes = 1) {\n    return !(this.pos + bytes > this.array.byteLength);\n  }\n\n  ensure(bytes) {\n    if (!this.canRead(bytes)) {\n      throw new Error('Read past end of buffer');\n    }\n  }\n  /** Read one byte. */\n\n\n  readByte() {\n    this.ensure(1);\n    return this.array[this.pos++];\n  }\n  /** Read integer as JavaScript number, up to 32 bits. */\n\n\n  readNum(byteWidth, isSigned) {\n    this.ensure(byteWidth);\n    const d = this.data,\n          p = this.pos;\n    let rv;\n\n    switch (byteWidth * (isSigned ? -1 : 1)) {\n      case 1:\n        rv = d.getUint8(p);\n        break;\n\n      case 2:\n        rv = d.getUint16(p, true);\n        break;\n\n      case 4:\n        rv = d.getUint32(p, true);\n        break;\n\n      case -1:\n        rv = d.getInt8(p);\n        break;\n\n      case -2:\n        rv = d.getInt16(p, true);\n        break;\n\n      case -4:\n        rv = d.getInt32(p, true);\n        break;\n\n      default:\n        throw new Error('Invalid integer width');\n    }\n\n    this.pos += byteWidth;\n    return rv;\n  }\n  /** Read integer as a bn.js number. */\n\n\n  readBn(bytes, signed) {\n    this.ensure(bytes);\n    const bn = new BN(this.array.subarray(this.pos, this.pos + bytes), 'le');\n    this.pos += bytes;\n\n    if (signed) {\n      return bn.fromTwos(bytes * 8);\n    } else {\n      return bn;\n    }\n  }\n  /** Read floating point as JavaScript number, 32 or 64 bits. */\n\n\n  readFloat(byteWidth) {\n    this.ensure(byteWidth);\n    let rv;\n\n    switch (byteWidth) {\n      case 4:\n        rv = this.data.getFloat32(this.pos, true);\n        break;\n\n      case 8:\n        rv = this.data.getFloat64(this.pos, true);\n        break;\n\n      default:\n        throw new Error('Invalid float size');\n    }\n\n    this.pos += byteWidth;\n    return rv;\n  }\n\n  readVaruint32() {\n    let v = 0;\n    let bit = 0;\n\n    for (;;) {\n      const b = this.readByte();\n      v |= (b & 0x7f) << bit;\n      bit += 7;\n\n      if (!(b & 0x80)) {\n        break;\n      }\n    }\n\n    return v >>> 0;\n  }\n\n  readVarint32() {\n    const v = this.readVaruint32();\n\n    if (v & 1) {\n      return ~v >> 1 | 2147483648;\n    } else {\n      return v >>> 1;\n    }\n  }\n\n  readArray(length) {\n    this.ensure(length);\n    const rv = this.array.subarray(this.pos, this.pos + length);\n    this.pos += length;\n    return rv;\n  }\n\n  readString() {\n    const length = this.readVaruint32();\n    return this.textDecoder.decode(this.readArray(length));\n  }\n\n}\n\nABIDecoder.__className = 'ABIDecoder';\n\nclass Int {\n  constructor(value) {\n    if (!Number.isFinite(value)) {\n      throw new Error('Invalid number');\n    }\n\n    this.value = clamp(value, this.constructor['min'], this.constructor['max']);\n  }\n\n  static get max() {\n    return Math.pow(2, this.byteWidth * 8 - (this.isSigned ? 1 : 0)) - 1;\n  }\n\n  static get min() {\n    return this.isSigned ? -(this.max + 1) : 0;\n  }\n\n  static from(value) {\n    if (isInstanceOf(value, this)) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      value = Number.parseInt(value, 10);\n    } else if (isInstanceOf(value, BNInt)) {\n      value = value.value.toNumber();\n    } else if (isInstanceOf(value, Int)) {\n      value = value.value;\n    } else if (BN.isBN(value)) {\n      value = value.toNumber();\n    }\n\n    if (typeof value !== 'number') {\n      throw new Error('Invalid integer');\n    }\n\n    return new this(value);\n  }\n\n  static fromABI(decoder) {\n    return new this(decoder.readNum(this.byteWidth, this.isSigned));\n  }\n\n  static random() {\n    const bytes = secureRandom(this.byteWidth);\n    const decoder = new ABIDecoder(bytes);\n    return this.fromABI(decoder);\n  }\n\n  equals(other) {\n    const self = this.constructor;\n    return this.value === self.from(other).value;\n  }\n\n  toABI(encoder) {\n    const self = this.constructor;\n    encoder.writeNum(this.value, self.byteWidth, self.isSigned);\n  }\n\n  toNumber() {\n    return this.value;\n  }\n\n  toString() {\n    return this.value.toFixed(0);\n  }\n\n  toJSON() {\n    return this.value;\n  }\n\n}\n\nInt.abiName = '__int';\n\nclass BNInt {\n  constructor(value) {\n    const self = this.constructor;\n\n    if (value.byteLength() > self.byteWidth) {\n      throw new Error('Number too wide');\n    }\n\n    this.value = value;\n  }\n\n  static from(value) {\n    if (isInstanceOf(value, this)) {\n      return value;\n    }\n\n    if (isInstanceOf(value, BNInt)) {\n      return new this(value.value);\n    }\n\n    if (isInstanceOf(value, Uint8Array)) {\n      return new this(new BN(value, undefined, 'le'));\n    }\n\n    if (isInstanceOf(value, Int)) {\n      value = value.value;\n    }\n\n    return new this(new BN(value));\n  }\n\n  static fromABI(decoder) {\n    return new this(decoder.readBn(this.byteWidth, this.isSigned));\n  }\n\n  static random() {\n    const bytes = secureRandom(this.byteWidth);\n    const decoder = new ABIDecoder(bytes);\n    return this.fromABI(decoder);\n  }\n\n  equals(other, allowCast = false) {\n    const self = this.constructor;\n\n    if (!allowCast && typeof other.constructor.byteWidth === 'number' && other.constructor.byteWidth !== self.byteWidth) {\n      return false;\n    }\n\n    return this.value.eq(self.from(other).value);\n  }\n\n  toABI(encoder) {\n    const self = this.constructor;\n    encoder.writeBn(this.value, self.byteWidth, self.isSigned);\n  }\n  /**\n   * Return JavaScript number for this instance.\n   * @throws If the number is larger than 53-bits.\n   **/\n\n\n  toNumber() {\n    return this.value.toNumber();\n  }\n\n  toString() {\n    return this.value.toString();\n  }\n\n  toJSON() {\n    // match FCs behavior and return strings for anything above Uint32\n    if (this.value.bitLength() > 32) {\n      return this.value.toString();\n    } else {\n      return this.value.toNumber();\n    }\n  }\n\n}\n\nBNInt.abiName = '__bn_int';\n\nclass Int8 extends Int {}\n\nInt8.abiName = 'int8';\nInt8.byteWidth = 1;\nInt8.isSigned = true;\n\nclass Int16 extends Int {}\n\nInt16.abiName = 'int16';\nInt16.byteWidth = 2;\nInt16.isSigned = true;\n\nclass Int32 extends Int {}\n\nInt32.abiName = 'int32';\nInt32.byteWidth = 4;\nInt32.isSigned = true;\n\nclass Int64 extends BNInt {}\n\nInt64.abiName = 'int64';\nInt64.byteWidth = 8;\nInt64.isSigned = true;\n\nclass Int128 extends BNInt {}\n\nInt128.abiName = 'int128';\nInt128.byteWidth = 16;\nInt128.isSigned = true;\n\nclass UInt8 extends Int {}\n\nUInt8.abiName = 'uint8';\nUInt8.byteWidth = 1;\nUInt8.isSigned = false;\n\nclass UInt16 extends Int {}\n\nUInt16.abiName = 'uint16';\nUInt16.byteWidth = 2;\nUInt16.isSigned = false;\n\nclass UInt32 extends Int {}\n\nUInt32.abiName = 'uint32';\nUInt32.byteWidth = 4;\nUInt32.isSigned = false;\n\nclass UInt64 extends BNInt {}\n\nUInt64.abiName = 'uint64';\nUInt64.byteWidth = 8;\nUInt64.isSigned = false;\n\nclass UInt128 extends BNInt {}\n\nUInt128.abiName = 'uint128';\nUInt128.byteWidth = 16;\nUInt128.isSigned = false;\n\nclass VarInt extends Int {\n  static fromABI(decoder) {\n    return new this(decoder.readVarint32());\n  }\n\n  toABI(encoder) {\n    encoder.writeVarint32(this.value);\n  }\n\n}\n\nVarInt.abiName = 'varint32';\nVarInt.byteWidth = 32;\nVarInt.isSigned = true;\n\nclass VarUInt extends Int {\n  static fromABI(decoder) {\n    return new this(decoder.readVaruint32());\n  }\n\n  toABI(encoder) {\n    encoder.writeVaruint32(this.value);\n  }\n\n}\n\nVarUInt.abiName = 'varuint32';\nVarUInt.byteWidth = 32;\nVarUInt.isSigned = false;\n\nfunction clamp(num, min, max) {\n  return Math.min(Math.max(num, min), max);\n}\n/**\n * EOSIO ABI Encoder\n */\n\n\nclass EncodingError extends Error {\n  constructor(ctx, underlyingError) {\n    const path = ctx.codingPath.map(({\n      field,\n      type\n    }) => {\n      if (typeof field === 'number') {\n        return field;\n      } else {\n        return `${field}<${type.typeName}>`;\n      }\n    }).join('.');\n    super(`Encoding error at ${path}: ${underlyingError.message}`);\n    this.stack = underlyingError.stack;\n    this.ctx = ctx;\n    this.underlyingError = underlyingError;\n  }\n\n}\n\nEncodingError.__className = 'EncodingError';\n\nfunction abiEncode(args) {\n  let type;\n  let typeName;\n\n  if (typeof args.type === 'string') {\n    typeName = args.type;\n  } else if (args.type && isTypeDescriptor(args.type)) {\n    if (typeof args.type.type !== 'string') {\n      type = args.type.type;\n    }\n\n    typeName = abiTypeString(args.type);\n  } else if (args.type && args.type.abiName !== undefined) {\n    type = args.type;\n    typeName = args.type.abiName;\n  } else {\n    type = getType(args.object);\n\n    if (type) {\n      typeName = type.abiName;\n\n      if (Array.isArray(args.object)) {\n        typeName += '[]';\n      }\n    }\n  }\n\n  const customTypes = args.customTypes || [];\n\n  if (type) {\n    customTypes.unshift(type);\n  } else if (typeName) {\n    const rootName = new ABI.ResolvedType(typeName).name;\n    type = customTypes.find(t => t.abiName === rootName);\n  }\n\n  let rootType;\n\n  if (args.abi && typeName) {\n    rootType = ABI.from(args.abi).resolveType(typeName);\n  } else if (type) {\n    const synthesized = synthesizeABI(type);\n    rootType = synthesized.abi.resolveType(typeName || type.abiName);\n    customTypes.push(...synthesized.types);\n  } else if (typeName) {\n    rootType = new ABI.ResolvedType(typeName);\n  } else {\n    throw new Error('Unable to determine the type of the object to be encoded. ' + 'To encode custom ABI types you must pass the type argument.');\n  }\n\n  const types = buildTypeLookup(customTypes);\n  const encoder = args.encoder || new ABIEncoder();\n\n  if (args.metadata) {\n    encoder.metadata = args.metadata;\n  }\n\n  const ctx = {\n    types,\n    encoder,\n    codingPath: [{\n      field: 'root',\n      type: rootType\n    }]\n  };\n\n  try {\n    encodeAny(args.object, rootType, ctx);\n  } catch (error) {\n    throw new EncodingError(ctx, error);\n  }\n\n  return Bytes.from(encoder.getData());\n}\n\nfunction encodeAny(value, type, ctx) {\n  const valueExists = value !== undefined && value !== null;\n\n  if (type.isOptional) {\n    ctx.encoder.writeByte(valueExists ? 1 : 0);\n\n    if (!valueExists) {\n      return;\n    }\n  }\n\n  if (type.isArray) {\n    if (!Array.isArray(value)) {\n      throw new Error(`Expected array for: ${type.typeName}`);\n    }\n\n    const len = value.length;\n    ctx.encoder.writeVaruint32(len);\n\n    for (let i = 0; i < len; i++) {\n      ctx.codingPath.push({\n        field: i,\n        type\n      });\n      encodeInner(value[i]);\n      ctx.codingPath.pop();\n    }\n  } else {\n    encodeInner(value);\n  }\n\n  function encodeInner(value) {\n    const abiType = ctx.types[type.name];\n\n    if (type.ref && !abiType) {\n      // type is alias, follow it\n      encodeAny(value, type.ref, ctx);\n      return;\n    }\n\n    if (!valueExists) {\n      if (type.isExtension) {\n        return;\n      }\n\n      throw new Error(`Found ${value} for non-optional type: ${type.typeName}`);\n    }\n\n    if (abiType && abiType.toABI) {\n      // type explicitly handles encoding\n      abiType.toABI(value, ctx.encoder);\n    } else if (typeof value.toABI === 'function' && value.constructor.abiName === type.name) {\n      // instance handles encoding\n      value.toABI(ctx.encoder);\n    } else {\n      // encode according to abi def if possible\n      if (type.fields) {\n        if (typeof value !== 'object') {\n          throw new Error(`Expected object for: ${type.name}`);\n        }\n\n        const fields = type.allFields;\n\n        if (!fields) {\n          throw new Error('Invalid struct fields');\n        }\n\n        for (const field of fields) {\n          ctx.codingPath.push({\n            field: field.name,\n            type: field.type\n          });\n          encodeAny(value[field.name], field.type, ctx);\n          ctx.codingPath.pop();\n        }\n      } else if (type.variant) {\n        let vName;\n\n        if (Array.isArray(value) && value.length === 2 && typeof value[0] === 'string') {\n          vName = value[0];\n          value = value[1];\n        } else if (isInstanceOf(value, Variant)) {\n          vName = value.variantName;\n          value = value.value;\n        } else {\n          vName = getTypeName(value);\n        }\n\n        const vIdx = type.variant.findIndex(t => t.typeName === vName);\n\n        if (vIdx === -1) {\n          const types = type.variant.map(t => `'${t.typeName}'`).join(', ');\n          throw new Error(`Unknown variant type '${vName}', expected one of ${types}`);\n        }\n\n        const vType = type.variant[vIdx];\n        ctx.encoder.writeVaruint32(vIdx);\n        ctx.codingPath.push({\n          field: `v${vIdx}`,\n          type: vType\n        });\n        encodeAny(value, vType, ctx);\n        ctx.codingPath.pop();\n      } else {\n        if (!abiType) {\n          throw new Error(type.name === 'any' ? 'Unable to encode any type to binary' : 'Unknown type');\n        }\n\n        const instance = abiType.from(value);\n\n        if (!instance.toABI) {\n          throw new Error(`Invalid type ${type.name}, no encoding methods implemented`);\n        }\n\n        instance.toABI(ctx.encoder);\n      }\n    }\n  }\n}\n\nclass ABIEncoder {\n  constructor(pageSize = 1024) {\n    this.pageSize = pageSize;\n    this.pos = 0;\n    this.textEncoder = new TextEncoder();\n    /** User declared metadata, can be used to pass info to instances when encoding.  */\n\n    this.metadata = {};\n    const buffer = new ArrayBuffer(pageSize);\n    this.data = new DataView(buffer);\n    this.array = new Uint8Array(buffer);\n  }\n\n  ensure(bytes) {\n    if (this.data.byteLength >= this.pos + bytes) {\n      return;\n    }\n\n    const pages = Math.ceil(bytes / this.pageSize);\n    const newSize = this.data.byteLength + this.pageSize * pages;\n    const buffer = new ArrayBuffer(newSize);\n    const data = new DataView(buffer);\n    const array = new Uint8Array(buffer);\n    array.set(this.array);\n    this.data = data;\n    this.array = array;\n  }\n  /** Write a single byte. */\n\n\n  writeByte(byte) {\n    this.ensure(1);\n    this.array[this.pos++] = byte;\n  }\n  /** Write an array of bytes. */\n\n\n  writeArray(bytes) {\n    const size = bytes.length;\n    this.ensure(size);\n    this.array.set(bytes, this.pos);\n    this.pos += size;\n  }\n  /** Write a JavaScript number as integer, up to 32 bits. */\n\n\n  writeNum(value, byteWidth, isSigned) {\n    this.ensure(byteWidth);\n    const d = this.data,\n          p = this.pos;\n\n    switch (byteWidth * (isSigned ? -1 : 1)) {\n      case 1:\n        d.setUint8(p, value);\n        break;\n\n      case 2:\n        d.setUint16(p, value, true);\n        break;\n\n      case 4:\n        d.setUint32(p, value, true);\n        break;\n\n      case -1:\n        d.setInt8(p, value);\n        break;\n\n      case -2:\n        d.setInt16(p, value, true);\n        break;\n\n      case -4:\n        d.setInt32(p, value, true);\n        break;\n\n      default:\n        throw new Error('Invalid integer width');\n    }\n\n    this.pos += byteWidth;\n  }\n  /** Write a bn.js number. */\n\n\n  writeBn(value, byteWidth, isSigned) {\n    if (isSigned) {\n      value = value.toTwos(byteWidth * 8);\n    }\n\n    this.writeArray(value.toArrayLike(Uint8Array, 'le', byteWidth));\n  }\n\n  writeFloat(value, byteWidth) {\n    this.ensure(byteWidth);\n\n    switch (byteWidth) {\n      case 4:\n        this.data.setFloat32(this.pos, value, true);\n        break;\n\n      case 8:\n        this.data.setFloat64(this.pos, value, true);\n        break;\n\n      default:\n        throw new Error('Invalid float size');\n    }\n\n    this.pos += byteWidth;\n  }\n\n  writeVaruint32(v) {\n    this.ensure(4);\n\n    for (;;) {\n      if (v >>> 7) {\n        this.array[this.pos++] = 0x80 | v & 0x7f;\n        v = v >>> 7;\n      } else {\n        this.array[this.pos++] = v;\n        break;\n      }\n    }\n  }\n\n  writeVarint32(v) {\n    this.writeVaruint32(v << 1 ^ v >> 31);\n  }\n\n  writeString(v) {\n    const data = this.textEncoder.encode(v);\n    this.writeVaruint32(data.byteLength);\n    this.writeArray(data);\n  }\n\n  getData() {\n    return new Uint8Array(this.array.buffer, this.array.byteOffset, this.pos);\n  }\n\n}\n\nABIEncoder.__className = 'ABIEncoder';\n\nclass Struct {\n  /** @internal */\n  constructor(object) {\n    const self = this.constructor;\n\n    for (const field of self.structFields) {\n      this[field.name] = object[field.name];\n    }\n  }\n\n  static from(value) {\n    if (value[Resolved] === true) {\n      // objects already resolved\n      return new this(value);\n    }\n\n    if (isInstanceOf(value, this)) {\n      return value;\n    }\n\n    const object = {};\n\n    for (const field of this.structFields) {\n      const v = value[field.name] === undefined ? field.default : value[field.name];\n\n      if (v === undefined && !(field.optional === true || field.name.includes('?'))) {\n        throw new Error(`Missing value for non optional field: ${field.name}`);\n      }\n\n      object[field.name] = v;\n    }\n\n    return abiDecode({\n      object,\n      type: this\n    });\n  }\n\n  static get structFields() {\n    const rv = [];\n\n    const walk = t => {\n      if (t.abiBase) {\n        walk(t.abiBase);\n      }\n\n      for (const field of t.abiFields || []) {\n        rv.push(field);\n      }\n    };\n\n    walk(this);\n    return rv;\n  }\n  /**\n   * Return true if this struct equals the other.\n   *\n   * Note: This compares the ABI encoded bytes of both structs, subclasses\n   *       should implement their own fast equality check when possible.\n   */\n\n\n  equals(other) {\n    const self = this.constructor;\n\n    if (other.constructor && typeof other.constructor.abiName === 'string' && other.constructor.abiName !== self.abiName) {\n      return false;\n    }\n\n    return abiEncode({\n      object: this\n    }).equals(abiEncode({\n      object: self.from(other)\n    }));\n  }\n  /** @internal */\n\n\n  toJSON() {\n    const self = this.constructor;\n    const rv = {};\n\n    for (const field of self.structFields) {\n      rv[field.name] = this[field.name];\n    }\n\n    return rv;\n  }\n\n}\n\nStruct.abiName = '__struct';\n\n(function (Struct) {\n  const FieldsOwner = Symbol('FieldsOwner');\n\n  function type(name) {\n    return function (struct) {\n      struct.abiName = name;\n      return struct;\n    };\n  }\n\n  Struct.type = type;\n\n  function field(type, options) {\n    if (!options) options = {};\n    return (target, name) => {\n      const ctor = target.constructor;\n\n      if (!ctor.abiFields) {\n        ctor.abiFields = [];\n        ctor.abiFields[FieldsOwner] = ctor;\n      } else if (ctor.abiFields[FieldsOwner] !== ctor) {\n        // if the target class isn't the owner we set the base and start new fields\n        ctor.abiBase = ctor.abiFields[FieldsOwner];\n        ctor.abiFields = [];\n        ctor.abiFields[FieldsOwner] = ctor;\n      }\n\n      ctor.abiFields.push({ ...options,\n        name,\n        type\n      });\n    };\n  }\n\n  Struct.field = field;\n})(Struct || (Struct = {}));\n\nfunction TypeAlias(name) {\n  return function (typeAlias) {\n    typeAlias.abiAlias = {\n      type: Object.getPrototypeOf(typeAlias.prototype).constructor\n    };\n    typeAlias.abiName = name;\n    return typeAlias;\n  };\n}\n\nclass Variant {\n  /** @internal */\n  constructor(variant) {\n    const abiVariant = this.constructor.abiVariant;\n    this.value = variant[1];\n    const variantIdx = abiVariant.map(abiTypeString).findIndex(t => t === variant[0]);\n\n    if (0 > variantIdx || abiVariant.length <= variantIdx) {\n      throw new Error(`Unknown variant ${variant[0]}`);\n    }\n\n    this.variantIdx = variantIdx;\n  }\n\n  static from(object) {\n    if (object[Resolved]) {\n      return new this(object);\n    }\n\n    if (isInstanceOf(object, this)) {\n      return object;\n    }\n\n    return abiDecode({\n      object,\n      type: this\n    });\n  }\n  /**\n   * Return true if this variant equals the other.\n   *\n   * Note: This compares the ABI encoded bytes of both variants, subclasses\n   *       should implement their own fast equality check when possible.\n   */\n\n\n  equals(other) {\n    const self = this.constructor;\n    const otherVariant = self.from(other);\n\n    if (this.variantIdx !== otherVariant.variantIdx) {\n      return false;\n    }\n\n    return abiEncode({\n      object: this\n    }).equals(abiEncode({\n      object: otherVariant\n    }));\n  }\n\n  get variantName() {\n    const variant = this.constructor.abiVariant[this.variantIdx];\n    return abiTypeString(variant);\n  }\n  /** @internal */\n\n\n  toJSON() {\n    return [this.variantName, this.value];\n  }\n\n}\n\nVariant.abiName = '__variant';\nVariant.abiVariant = [];\n\n(function (Variant) {\n  function type(name, types) {\n    return function (variant) {\n      variant.abiName = name;\n      variant.abiVariant = types.map(toTypeDescriptor);\n      return variant;\n    };\n  }\n\n  Variant.type = type;\n})(Variant || (Variant = {}));\n\nclass Float {\n  constructor(value) {\n    if (!Number.isFinite(value)) {\n      throw new Error('Invalid number');\n    }\n\n    this.value = value;\n  }\n\n  static from(value) {\n    if (isInstanceOf(value, this)) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      value = Number.parseFloat(value);\n    } else if (isInstanceOf(value, Float)) {\n      value = value.value;\n    }\n\n    return new this(value);\n  }\n\n  static fromABI(decoder) {\n    return new this(decoder.readFloat(this.byteWidth));\n  }\n\n  static random() {\n    const bytes = secureRandom(this.byteWidth);\n    const decoder = new ABIDecoder(bytes);\n    return this.fromABI(decoder);\n  }\n\n  equals(other) {\n    const self = this.constructor;\n    return this.value === self.from(other).value;\n  }\n\n  toABI(encoder) {\n    const self = this.constructor;\n    encoder.writeFloat(this.value, self.byteWidth);\n  }\n\n  toString() {\n    return this.value.toString();\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n\nFloat.abiName = '__float';\n\nclass Float32 extends Float {\n  toString() {\n    return this.value.toFixed(7);\n  }\n\n}\n\nFloat32.abiName = 'float32';\nFloat32.byteWidth = 4;\n\nclass Float64 extends Float {}\n\nFloat64.abiName = 'float64';\nFloat64.byteWidth = 8;\n\nclass Float128 {\n  constructor(data) {\n    if (data.array.length !== 16) {\n      throw new Error('Invalid float128');\n    }\n\n    this.data = data;\n  }\n\n  static from(value) {\n    if (isInstanceOf(value, this)) {\n      return value;\n    }\n\n    if (typeof value === 'string' && value.startsWith('0x')) {\n      value = value.slice(2);\n    }\n\n    return new this(Bytes.from(value));\n  }\n\n  static fromABI(decoder) {\n    return new this(new Bytes(decoder.readArray(this.byteWidth)));\n  }\n\n  static random() {\n    const bytes = secureRandom(16);\n    const decoder = new ABIDecoder(bytes);\n    return this.fromABI(decoder);\n  }\n\n  equals(other) {\n    const self = this.constructor;\n    return this.data.equals(self.from(other).data);\n  }\n\n  toABI(encoder) {\n    encoder.writeArray(this.data.array);\n  }\n\n  toString() {\n    // float128 uses 0x prefixed hex strings as opposed to everywhere else in where there is no prefix ¯\\_(ツ)_/¯\n    return '0x' + this.data.hexString;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n\nFloat128.abiName = 'float128';\nFloat128.byteWidth = 16;\n/** EOSIO Name */\n\nclass Name {\n  constructor(rawValue) {\n    this.rawValue = rawValue;\n  }\n  /** Create a new Name instance from any of its representing types. */\n\n\n  static from(value) {\n    if (isInstanceOf(value, Name)) {\n      return value;\n    } else if (typeof value === 'string') {\n      return new Name(stringToName(value));\n    } else if (isInstanceOf(value, UInt64)) {\n      return new Name(value);\n    } else {\n      throw new Error('Invalid name');\n    }\n  }\n\n  static fromABI(decoder) {\n    return new Name(UInt64.fromABI(decoder));\n  }\n  /** Return true if this name is equal to passed name. */\n\n\n  equals(other) {\n    return this.rawValue.equals(Name.from(other).rawValue);\n  }\n  /** Return string representation of this name. */\n\n\n  toString() {\n    return nameToString(this.rawValue);\n  }\n\n  toABI(encoder) {\n    this.rawValue.toABI(encoder);\n  }\n  /** @internal */\n\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n\nName.abiName = 'name';\n/** Regex pattern matching a EOSIO name, case-sensitive. */\n\nName.pattern = /^[a-z1-5.]{0,13}$/;\n\nfunction stringToName(s) {\n  function charToSymbol(c) {\n    if (c >= 'a'.charCodeAt(0) && c <= 'z'.charCodeAt(0)) {\n      return c - 'a'.charCodeAt(0) + 6;\n    }\n\n    if (c >= '1'.charCodeAt(0) && c <= '5'.charCodeAt(0)) {\n      return c - '1'.charCodeAt(0) + 1;\n    }\n\n    return 0;\n  }\n\n  const a = new Uint8Array(8);\n  let bit = 63;\n\n  for (let i = 0; i < s.length; ++i) {\n    let c = charToSymbol(s.charCodeAt(i));\n\n    if (bit < 5) {\n      c = c << 1;\n    }\n\n    for (let j = 4; j >= 0; --j) {\n      if (bit >= 0) {\n        a[Math.floor(bit / 8)] |= (c >> j & 1) << bit % 8;\n        --bit;\n      }\n    }\n  }\n\n  return UInt64.from(a);\n}\n\nfunction nameToString(n) {\n  const a = n.value.toArray('le', 8);\n  let result = '';\n\n  for (let bit = 63; bit >= 0;) {\n    let c = 0;\n\n    for (let i = 0; i < 5; ++i) {\n      if (bit >= 0) {\n        c = c << 1 | a[Math.floor(bit / 8)] >> bit % 8 & 1;\n        --bit;\n      }\n    }\n\n    if (c >= 6) {\n      result += String.fromCharCode(c + 'a'.charCodeAt(0) - 6);\n    } else if (c >= 1) {\n      result += String.fromCharCode(c + '1'.charCodeAt(0) - 1);\n    } else {\n      result += '.';\n    }\n  }\n\n  while (result.endsWith('.')) {\n    result = result.substr(0, result.length - 1);\n  }\n\n  return result;\n}\n\nclass TimePointBase {\n  constructor(value) {\n    this.value = value;\n  }\n\n  static from(value) {\n    if (isInstanceOf(value, this)) {\n      return value;\n    }\n\n    if (isInstanceOf(value, TimePointBase)) {\n      // converting between types\n      return this.fromMilliseconds(value.toMilliseconds());\n    }\n\n    if (isInstanceOf(value, Date)) {\n      return this.fromDate(value);\n    }\n\n    if (typeof value === 'string') {\n      return this.fromString(value);\n    }\n\n    return this.fromInteger(value);\n  }\n\n  static fromString(string) {\n    const value = Date.parse(string + 'Z');\n\n    if (!Number.isFinite(value)) {\n      throw new Error('Invalid date string');\n    }\n\n    return this.fromMilliseconds(value);\n  }\n\n  static fromDate(date) {\n    return this.fromMilliseconds(date.getTime());\n  }\n\n  toABI(encoder) {\n    const self = this;\n    self.value.toABI(encoder);\n  }\n\n  equals(other) {\n    const self = this.constructor;\n    return this.toMilliseconds() === self.from(other).toMilliseconds();\n  }\n\n  toMilliseconds() {\n    throw new Error('Not implemented');\n  }\n\n  toDate() {\n    return new Date(this.toMilliseconds());\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n\nTimePointBase.abiName = '__time_point_base';\n/** Timestamp with microsecond accuracy. */\n\nclass TimePoint extends TimePointBase {\n  static fromMilliseconds(ms) {\n    return new TimePoint(Int64.from(Math.round(ms * 1000)));\n  }\n\n  static fromInteger(value) {\n    return new TimePoint(Int64.from(value));\n  }\n\n  static fromABI(decoder) {\n    return new this(Int64.fromABI(decoder));\n  }\n\n  toString() {\n    return this.toDate().toISOString().slice(0, -1);\n  }\n\n  toMilliseconds() {\n    return this.value.value.divRound(new BN(1000)).toNumber();\n  }\n\n}\n\nTimePoint.abiName = 'time_point';\n/** Timestamp with second accuracy. */\n\nclass TimePointSec extends TimePointBase {\n  static fromMilliseconds(ms) {\n    return new TimePointSec(UInt32.from(Math.round(ms / 1000)));\n  }\n\n  static fromInteger(value) {\n    return new TimePointSec(UInt32.from(value));\n  }\n\n  static fromABI(decoder) {\n    return new this(UInt32.fromABI(decoder));\n  }\n\n  toString() {\n    return this.toDate().toISOString().slice(0, -5);\n  }\n\n  toMilliseconds() {\n    return this.value.value * 1000;\n  }\n\n}\n\nTimePointSec.abiName = 'time_point_sec';\n\nclass BlockTimestamp extends TimePointBase {\n  static fromMilliseconds(ms) {\n    return new TimePointSec(UInt32.from(Math.round((ms - 946684800000) / 500)));\n  }\n\n  static fromInteger(value) {\n    return new TimePointSec(UInt32.from(value));\n  }\n\n  static fromABI(decoder) {\n    return new this(UInt32.fromABI(decoder));\n  }\n\n  toString() {\n    return this.toDate().toISOString().slice(0, -1);\n  }\n\n  toMilliseconds() {\n    return this.value.value * 500 + 946684800000;\n  }\n\n}\n\nBlockTimestamp.abiName = 'block_timestamp_type';\n\nclass ABI {\n  constructor(args) {\n    this.version = args.version || ABI.version;\n    this.types = args.types || [];\n    this.variants = args.variants || [];\n    this.structs = args.structs || [];\n    this.actions = args.actions || [];\n    this.tables = args.tables || [];\n    this.ricardian_clauses = args.ricardian_clauses || [];\n  }\n\n  static from(value) {\n    if (isInstanceOf(value, ABI)) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      return new ABI(JSON.parse(value));\n    }\n\n    return new ABI(value);\n  }\n\n  resolveType(name) {\n    const types = {};\n    return this.resolve({\n      name,\n      types\n    }, {\n      id: 0\n    });\n  }\n\n  resolveAll() {\n    const types = {};\n    const ctx = {\n      id: 0\n    };\n    return {\n      types: this.types.map(t => this.resolve({\n        name: t.new_type_name,\n        types\n      }, ctx)),\n      variants: this.variants.map(t => this.resolve({\n        name: t.name,\n        types\n      }, ctx)),\n      structs: this.structs.map(t => this.resolve({\n        name: t.name,\n        types\n      }, ctx))\n    };\n  }\n\n  resolve({\n    name,\n    types\n  }, ctx) {\n    const existing = types[name];\n\n    if (existing) {\n      return existing;\n    }\n\n    const type = new ABI.ResolvedType(name, ++ctx.id);\n    types[type.typeName] = type;\n    const alias = this.types.find(typeDef => typeDef.new_type_name == type.name);\n\n    if (alias) {\n      type.ref = this.resolve({\n        name: alias.type,\n        types\n      }, ctx);\n      return type;\n    }\n\n    const struct = this.getStruct(type.name);\n\n    if (struct) {\n      if (struct.base) {\n        type.base = this.resolve({\n          name: struct.base,\n          types\n        }, ctx);\n      }\n\n      type.fields = struct.fields.map(field => {\n        return {\n          name: field.name,\n          type: this.resolve({\n            name: field.type,\n            types\n          }, ctx)\n        };\n      });\n      return type;\n    }\n\n    const variant = this.getVariant(type.name);\n\n    if (variant) {\n      type.variant = variant.types.map(name => this.resolve({\n        name,\n        types\n      }, ctx));\n      return type;\n    } // builtin or unknown type\n\n\n    return type;\n  }\n\n  getStruct(name) {\n    return this.structs.find(struct => struct.name == name);\n  }\n\n  getVariant(name) {\n    return this.variants.find(variant => variant.name == name);\n  }\n  /** Return arguments type of an action in this ABI. */\n\n\n  getActionType(actionName) {\n    const name = Name.from(actionName).toString();\n    const action = this.actions.find(a => a.name.toString() === name);\n\n    if (action) {\n      return action.type;\n    }\n  }\n\n}\n\nABI.__className = 'ABI';\nABI.version = 'eosio::abi/1.1';\n\n(function (ABI) {\n  class ResolvedType {\n    constructor(fullName, id = 0) {\n      let name = fullName;\n\n      if (name.endsWith('$')) {\n        name = name.slice(0, -1);\n        this.isExtension = true;\n      } else {\n        this.isExtension = false;\n      }\n\n      if (name.endsWith('?')) {\n        name = name.slice(0, -1);\n        this.isOptional = true;\n      } else {\n        this.isOptional = false;\n      }\n\n      if (name.endsWith('[]')) {\n        name = name.slice(0, -2);\n        this.isArray = true;\n      } else {\n        this.isArray = false;\n      }\n\n      this.id = id;\n      this.name = name;\n    }\n    /**\n     * Type name including suffixes: [] array, ? optional, $ binary ext\n     */\n\n\n    get typeName() {\n      let rv = this.name;\n\n      if (this.isArray) {\n        rv += '[]';\n      }\n\n      if (this.isOptional) {\n        rv += '?';\n      }\n\n      if (this.isExtension) {\n        rv += '$';\n      }\n\n      return rv;\n    }\n    /** All fields including base struct(s), undefined if not a struct type. */\n\n\n    get allFields() {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      let current = this;\n      const rv = [];\n      const seen = new Set();\n\n      do {\n        if (!current.fields) {\n          return; // invalid struct\n        }\n\n        if (seen.has(current.name)) {\n          return; // circular ref\n        }\n\n        for (let i = current.fields.length - 1; i >= 0; i--) {\n          rv.unshift(current.fields[i]);\n        }\n\n        seen.add(current.name);\n        current = current.base;\n      } while (current !== undefined);\n\n      return rv;\n    }\n\n  }\n\n  ABI.ResolvedType = ResolvedType;\n})(ABI || (ABI = {}));\n\nclass Asset {\n  constructor(units, symbol) {\n    this.units = units;\n    this.symbol = symbol;\n  }\n\n  static from(value, symbol) {\n    if (isInstanceOf(value, Asset)) {\n      return value;\n    }\n\n    switch (typeof value) {\n      case 'number':\n        if (!symbol) {\n          throw new Error('Symbol is required when creating Asset from number');\n        }\n\n        return this.fromFloat(value, symbol);\n\n      case 'string':\n        return this.fromString(value);\n\n      default:\n        throw new Error('Invalid asset');\n    }\n  }\n\n  static fromString(value) {\n    const parts = (typeof value === 'string' ? value : '').split(' ');\n\n    if (parts.length !== 2) {\n      throw new Error('Invalid asset string');\n    }\n\n    const amount = parts[0].replace('.', '');\n    const precision = (parts[0].split('.')[1] || '').length;\n    const symbol = Asset.Symbol.fromParts(parts[1], precision);\n    return new Asset(Int64.from(amount), symbol);\n  }\n\n  static fromFloat(value, symbol) {\n    const s = Asset.Symbol.from(symbol);\n    return new Asset(s.convertFloat(value), s);\n  }\n\n  static fromUnits(value, symbol) {\n    return new Asset(Int64.from(value), Asset.Symbol.from(symbol));\n  }\n\n  static fromABI(decoder) {\n    const units = Int64.fromABI(decoder);\n    const symbol = Asset.Symbol.fromABI(decoder);\n    return new Asset(units, symbol);\n  }\n\n  equals(other) {\n    const {\n      symbol,\n      units\n    } = Asset.from(other);\n    return this.symbol.value.equals(symbol.value) && this.units.equals(units);\n  }\n\n  get value() {\n    return this.symbol.convertUnits(this.units);\n  }\n\n  set value(newValue) {\n    this.units = this.symbol.convertFloat(newValue);\n  }\n\n  toABI(encoder) {\n    this.units.toABI(encoder);\n    this.symbol.toABI(encoder);\n  }\n\n  toString() {\n    const digits = this.units.toString().split('');\n    let negative = false;\n\n    if (digits[0] === '-') {\n      negative = true;\n      digits.shift();\n    }\n\n    const p = this.symbol.precision;\n\n    while (digits.length <= p) {\n      digits.unshift('0');\n    }\n\n    if (p > 0) {\n      digits.splice(digits.length - p, 0, '.');\n    }\n\n    let rv = digits.join('');\n\n    if (negative) {\n      rv = '-' + rv;\n    }\n\n    return rv + ' ' + this.symbol.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n\nAsset.abiName = 'asset';\n\n(function (Asset) {\n  class Symbol {\n    constructor(value) {\n      if (toSymbolPrecision(value) > Symbol.maxPrecision) {\n        throw new Error('Invalid asset symbol, precision too large');\n      }\n\n      if (!Symbol.symbolNamePattern.test(toSymbolName(value))) {\n        throw new Error('Invalid asset symbol, name must be uppercase A-Z');\n      }\n\n      this.value = value;\n    }\n\n    static from(value) {\n      if (isInstanceOf(value, Symbol)) {\n        return value;\n      }\n\n      if (isInstanceOf(value, UInt64)) {\n        return new Symbol(value);\n      }\n\n      const parts = value.split(',');\n\n      if (parts.length !== 2) {\n        throw new Error('Invalid symbol string');\n      }\n\n      const precision = Number.parseInt(parts[0]);\n      return Symbol.fromParts(parts[1], precision);\n    }\n\n    static fromParts(name, precision) {\n      return new Symbol(toRawSymbol(name, precision));\n    } // eslint-disable-next-line @typescript-eslint/ban-types\n\n\n    static fromABI(decoder) {\n      return new Symbol(UInt64.fromABI(decoder));\n    }\n\n    equals(other) {\n      return this.value.equals(Symbol.from(other).value);\n    }\n\n    get name() {\n      return toSymbolName(this.value);\n    }\n\n    get precision() {\n      return toSymbolPrecision(this.value);\n    }\n\n    get code() {\n      return new SymbolCode(UInt64.from(this.value.value.clone().iushrn(8)));\n    }\n\n    toABI(encoder) {\n      this.value.toABI(encoder);\n    }\n    /**\n     * Convert units to floating point number according to symbol precision.\n     * @throws If the given units can't be represented in 53 bits.\n     **/\n\n\n    convertUnits(units) {\n      return units.value.toNumber() / Math.pow(10, this.precision);\n    }\n    /**\n     * Convert floating point to units according to symbol precision.\n     * Note that the value will be rounded to closest precision.\n     **/\n\n\n    convertFloat(float) {\n      return Int64.from(float.toFixed(this.precision).replace('.', ''));\n    }\n\n    toString() {\n      return `${this.precision},${this.name}`;\n    }\n\n    toJSON() {\n      return this.toString();\n    }\n\n  }\n\n  Symbol.abiName = 'symbol';\n  Symbol.symbolNamePattern = /^[A-Z]{1,7}$/;\n  Symbol.maxPrecision = 18;\n  Asset.Symbol = Symbol;\n\n  class SymbolCode {\n    constructor(value) {\n      this.value = value;\n    }\n\n    static from(value) {\n      if (isInstanceOf(value, SymbolCode)) {\n        return value;\n      }\n\n      if (typeof value === 'string') {\n        value = UInt64.from(new BN(toRawSymbolCode(value), 'le'));\n      }\n\n      return new this(UInt64.from(value));\n    }\n\n    static fromABI(decoder) {\n      return new SymbolCode(UInt64.fromABI(decoder));\n    }\n\n    equals(other) {\n      return this.value.equals(SymbolCode.from(other).value);\n    }\n\n    toABI(encoder) {\n      this.value.toABI(encoder);\n    }\n\n    toString() {\n      return charsToSymbolName(this.value.value.toArray('be'));\n    }\n\n    toJSON() {\n      return this.toString();\n    }\n\n  }\n\n  SymbolCode.abiName = 'symbol_code';\n  Asset.SymbolCode = SymbolCode;\n})(Asset || (Asset = {}));\n\nclass ExtendedAsset {\n  constructor(quantity, contract) {\n    this.quantity = quantity;\n    this.contract = contract;\n  }\n\n  static from(value) {\n    if (isInstanceOf(value, ExtendedAsset)) {\n      return value;\n    }\n\n    return new this(Asset.from(value.quantity), Name.from(value.contract));\n  }\n\n  static fromABI(decoder) {\n    return new ExtendedAsset(Asset.fromABI(decoder), Name.fromABI(decoder));\n  }\n\n  equals(other) {\n    return this.quantity.equals(other.quantity) && this.contract.equals(other.contract);\n  }\n\n  toABI(encoder) {\n    this.quantity.toABI(encoder);\n    this.contract.toABI(encoder);\n  }\n\n  toJSON() {\n    return {\n      quantity: this.quantity,\n      contract: this.contract\n    };\n  }\n\n}\n\nExtendedAsset.abiName = 'extended_asset';\n\nfunction toSymbolPrecision(rawSymbol) {\n  return rawSymbol.value.and(UInt64.from(0xff).value).toNumber();\n}\n\nfunction toSymbolName(rawSymbol) {\n  const chars = rawSymbol.value.toArray('be').slice(0, -1);\n  return charsToSymbolName(chars);\n}\n\nfunction charsToSymbolName(chars) {\n  return chars.map(char => String.fromCharCode(char)).reverse().join('');\n}\n\nfunction toRawSymbol(name, precision) {\n  const array = toRawSymbolCode(name);\n  array.unshift(precision);\n  return UInt64.from(new BN(array, 'le'));\n}\n\nfunction toRawSymbolCode(name) {\n  const array = [];\n  const length = Math.min(name.length, 7);\n\n  for (let i = 0; i < length; i++) {\n    array.push(name.charCodeAt(i));\n  }\n\n  return array;\n}\n\nvar Base58;\n\n(function (Base58) {\n  const chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n  const charMap = new Int16Array(0xff).fill(-1);\n\n  for (let i = 0; i < 58; ++i) {\n    charMap[chars.charCodeAt(i)] = i;\n  }\n  /** Decode a Base58 encoded string. */\n\n\n  function decode(s, size) {\n    if (size == null) {\n      return decodeVar(s);\n    }\n\n    const result = new Uint8Array(size);\n\n    for (let i = 0; i < s.length; ++i) {\n      let carry = charMap[s.charCodeAt(i)];\n\n      if (carry < 0) {\n        throw new Error('Invalid Base58 value');\n      }\n\n      for (let j = 0; j < size; ++j) {\n        const x = result[j] * 58 + carry;\n        result[j] = x;\n        carry = x >> 8;\n      }\n\n      if (carry) {\n        throw new Error('Base58 value is out of range');\n      }\n    }\n\n    result.reverse();\n    return new Bytes(result);\n  }\n\n  Base58.decode = decode;\n  /** Decode a Base58Check encoded string. */\n\n  function decodeCheck(encoded, size) {\n    const decoded = decode(encoded, size != null ? size + 4 : size);\n    const data = decoded.array.subarray(0, -4);\n    const checksum = decoded.array.subarray(-4);\n\n    if (!arrayEquals(checksum, dsha256Checksum(data))) {\n      throw new Error('Checksum mismatch');\n    }\n\n    return new Bytes(data);\n  }\n\n  Base58.decodeCheck = decodeCheck;\n  /** Decode a Base58Check encoded string that uses ripemd160 instead of double sha256 for the digest. */\n\n  function decodeRipemd160Check(encoded, size, suffix) {\n    const decoded = decode(encoded, size != null ? size + 4 : size);\n    const data = decoded.array.subarray(0, -4);\n    const checksum = decoded.array.subarray(-4);\n\n    if (!arrayEquals(checksum, ripemd160Checksum(data, suffix))) {\n      throw new Error('Checksum mismatch');\n    }\n\n    return new Bytes(data);\n  }\n\n  Base58.decodeRipemd160Check = decodeRipemd160Check;\n  /** Encode bytes to a Base58 string.  */\n\n  function encode(data) {\n    data = Bytes.from(data);\n    const result = [];\n\n    for (const byte of data.array) {\n      let carry = byte;\n\n      for (let j = 0; j < result.length; ++j) {\n        const x = (charMap[result[j]] << 8) + carry;\n        result[j] = chars.charCodeAt(x % 58);\n        carry = x / 58 | 0;\n      }\n\n      while (carry) {\n        result.push(chars.charCodeAt(carry % 58));\n        carry = carry / 58 | 0;\n      }\n    }\n\n    for (const byte of data.array) {\n      if (byte) {\n        break;\n      } else {\n        result.push('1'.charCodeAt(0));\n      }\n    }\n\n    result.reverse();\n    return String.fromCharCode(...result);\n  }\n\n  Base58.encode = encode;\n\n  function encodeCheck(data) {\n    data = Bytes.from(data);\n    data = data.appending(dsha256Checksum(data.array));\n    return encode(data);\n  }\n\n  Base58.encodeCheck = encodeCheck;\n\n  function encodeRipemd160Check(data, suffix) {\n    data = Bytes.from(data);\n    data = data.appending(ripemd160Checksum(data.array, suffix));\n    return encode(data);\n  }\n\n  Base58.encodeRipemd160Check = encodeRipemd160Check;\n  /** @internal */\n\n  function decodeVar(s) {\n    const result = [];\n\n    for (let i = 0; i < s.length; ++i) {\n      let carry = charMap[s.charCodeAt(i)];\n\n      if (carry < 0) {\n        throw new Error('Invalid Base58 value');\n      }\n\n      for (let j = 0; j < result.length; ++j) {\n        const x = result[j] * 58 + carry;\n        result[j] = x & 0xff;\n        carry = x >> 8;\n      }\n\n      if (carry) {\n        result.push(carry);\n      }\n    }\n\n    for (const ch of s) {\n      if (ch === '1') {\n        result.push(0);\n      } else {\n        break;\n      }\n    }\n\n    result.reverse();\n    return Bytes.from(result);\n  }\n  /** @internal */\n\n\n  function ripemd160Checksum(data, suffix) {\n    const hash = ripemd160().update(data);\n\n    if (suffix) {\n      hash.update(suffix);\n    }\n\n    return hash.digest().slice(0, 4);\n  }\n  /** @internal */\n\n\n  function dsha256Checksum(data) {\n    const round1 = sha256().update(data).digest();\n    const round2 = sha256().update(round1).digest();\n    return round2.slice(0, 4);\n  }\n})(Base58 || (Base58 = {}));\n\nclass PublicKey {\n  /** @internal */\n  constructor(type, data) {\n    this.type = type;\n    this.data = data;\n  }\n  /** Create PublicKey object from representing types. */\n\n\n  static from(value) {\n    if (isInstanceOf(value, PublicKey)) {\n      return value;\n    }\n\n    if (typeof value === 'object' && value.type && value.compressed) {\n      return new PublicKey(CurveType.from(value.type), new Bytes(value.compressed));\n    }\n\n    if (typeof value !== 'string') {\n      throw new Error('Invalid public key');\n    }\n\n    if (value.startsWith('PUB_')) {\n      const parts = value.split('_');\n\n      if (parts.length !== 3) {\n        throw new Error('Invalid public key string');\n      }\n\n      const type = CurveType.from(parts[1]);\n      const size = type === CurveType.K1 || type === CurveType.R1 ? 33 : undefined;\n      const data = Base58.decodeRipemd160Check(parts[2], size, type);\n      return new PublicKey(type, data);\n    } else if (value.length >= 50) {\n      // Legacy EOS key\n      const data = Base58.decodeRipemd160Check(value.slice(-50));\n      return new PublicKey(CurveType.K1, data);\n    } else {\n      throw new Error('Invalid public key string');\n    }\n  }\n  /** @internal */\n\n\n  static fromABI(decoder) {\n    const type = CurveType.from(decoder.readByte());\n\n    if (type == CurveType.WA) {\n      // \"WA\" keys pack some sort of metadata\n      // we probably need to restructure key data storage into containers like FC does\n      const data = new Bytes(decoder.readArray(33));\n      Bytes.fromABI(decoder); // throw away metadata for now\n\n      return new PublicKey(type, data);\n    }\n\n    return new PublicKey(type, new Bytes(decoder.readArray(33)));\n  }\n\n  equals(other) {\n    const otherKey = PublicKey.from(other);\n    return this.type === otherKey.type && this.data.equals(otherKey.data);\n  }\n  /**\n   * Return EOSIO legacy (`EOS<base58data>`) formatted key.\n   * @throws If the key type isn't `K1`\n   */\n\n\n  toLegacyString(prefix = 'EOS') {\n    if (this.type !== CurveType.K1) {\n      throw new Error('Unable to create legacy formatted string for non-K1 key');\n    }\n\n    return `${prefix}${Base58.encodeRipemd160Check(this.data)}`;\n  }\n  /** Return key in modern EOSIO format (`PUB_<type>_<base58data>`) */\n\n\n  toString() {\n    return `PUB_${this.type}_${Base58.encodeRipemd160Check(this.data, this.type)}`;\n  }\n  /** @internal */\n\n\n  toABI(encoder) {\n    if (this.type === CurveType.WA) {\n      throw new Error('WA keys are not supported yet');\n    }\n\n    encoder.writeByte(CurveType.indexFor(this.type));\n    encoder.writeArray(this.data.array);\n  }\n  /** @internal */\n\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n\nPublicKey.abiName = 'public_key';\nconst curves = {};\n/**\n * Get curve for key type.\n * @internal\n */\n\nfunction getCurve(type) {\n  let rv = curves[type];\n\n  if (!rv) {\n    if (type === 'K1') {\n      rv = curves[type] = new ec('secp256k1');\n    } else if (type === 'R1') {\n      rv = curves[type] = new ec('p256');\n    } else {\n      throw new Error(`Unknown curve type: ${type}`);\n    }\n  }\n\n  return rv;\n}\n/**\n * Recover public key from signature and recovery id.\n * @internal\n */\n\n\nfunction recover(signature, message, type) {\n  const curve = getCurve(type);\n  const recid = signature[0] - 31;\n  const r = signature.subarray(1, 33);\n  const s = signature.subarray(33);\n  const point = curve.recoverPubKey(message, {\n    r,\n    s\n  }, recid);\n  return new Uint8Array(point.encodeCompressed());\n}\n/**\n * Verify signature using message and public key.\n * @internal\n */\n\n\nfunction verify(signature, message, pubkey, type) {\n  const curve = getCurve(type);\n  const r = signature.subarray(1, 33);\n  const s = signature.subarray(33);\n  return curve.verify(message, {\n    r,\n    s\n  }, pubkey);\n}\n\nclass Signature {\n  /** @internal */\n  constructor(type, data) {\n    this.type = type;\n    this.data = data;\n  }\n  /** Create Signature object from representing types. */\n\n\n  static from(value) {\n    if (isInstanceOf(value, Signature)) {\n      return value;\n    }\n\n    if (typeof value === 'object' && value.r && value.s) {\n      const data = new Uint8Array(1 + 32 + 32);\n      let recid = value.recid;\n      const type = CurveType.from(value.type);\n\n      if (value.type === CurveType.K1 || value.type === CurveType.R1) {\n        recid += 31;\n      }\n\n      data[0] = recid;\n      data.set(value.r, 1);\n      data.set(value.s, 33);\n      return new Signature(type, new Bytes(data));\n    }\n\n    if (typeof value !== 'string') {\n      throw new Error('Invalid signature');\n    }\n\n    if (value.startsWith('SIG_')) {\n      const parts = value.split('_');\n\n      if (parts.length !== 3) {\n        throw new Error('Invalid signature string');\n      }\n\n      const type = CurveType.from(parts[1]);\n      const size = type === CurveType.K1 || type === CurveType.R1 ? 65 : undefined;\n      const data = Base58.decodeRipemd160Check(parts[2], size, type);\n      return new Signature(type, data);\n    } else {\n      throw new Error('Invalid signature string');\n    }\n  }\n  /** @internal */\n\n\n  static fromABI(decoder) {\n    const type = CurveType.from(decoder.readByte());\n\n    if (type === CurveType.WA) {\n      // same as with public keys WA type has some extra data tacked on\n      const data = new Bytes(decoder.readArray(65)); // sig\n\n      Bytes.fromABI(decoder); // throw away for now\n\n      Bytes.fromABI(decoder);\n      return new Signature(CurveType.WA, data);\n    }\n\n    return new Signature(type, new Bytes(decoder.readArray(65)));\n  }\n\n  equals(other) {\n    const otherSig = Signature.from(other);\n    return this.type === otherSig.type && this.data.equals(otherSig.data);\n  }\n  /** Recover public key from given message digest. */\n\n\n  recoverDigest(digest) {\n    digest = Checksum256.from(digest);\n    const compressed = recover(this.data.array, digest.array, this.type);\n    return PublicKey.from({\n      compressed,\n      type: this.type\n    });\n  }\n  /** Recover public key from given message. */\n\n\n  recoverMessage(message) {\n    return this.recoverDigest(Checksum256.hash(message));\n  }\n  /** Verify this signature with given message digest and public key. */\n\n\n  verifyDigest(digest, publicKey) {\n    digest = Checksum256.from(digest);\n    return verify(this.data.array, digest.array, publicKey.data.array, this.type);\n  }\n  /** Verify this signature with given message and public key. */\n\n\n  verifyMessage(message, publicKey) {\n    return this.verifyDigest(Checksum256.hash(message), publicKey);\n  }\n  /** Base58check encoded string representation of this signature (`SIG_<type>_<data>`). */\n\n\n  toString() {\n    return `SIG_${this.type}_${Base58.encodeRipemd160Check(this.data, this.type)}`;\n  }\n  /** @internal */\n\n\n  toABI(encoder) {\n    if (this.type === CurveType.WA) {\n      throw new Error('WA signatures are not supported yet');\n    }\n\n    encoder.writeByte(CurveType.indexFor(this.type));\n    encoder.writeArray(this.data.array);\n  }\n  /** @internal */\n\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n\nSignature.abiName = 'signature';\n/**\n * Get public key corresponding to given private key.\n * @internal\n */\n\nfunction getPublic(privkey, type) {\n  const curve = getCurve(type);\n  const key = curve.keyFromPrivate(privkey);\n  const point = key.getPublic();\n  return new Uint8Array(point.encodeCompressed());\n}\n/**\n * Derive shared secret for key pair.\n * @internal\n */\n\n\nfunction sharedSecret(privkey, pubkey, type) {\n  const curve = getCurve(type);\n  const priv = curve.keyFromPrivate(privkey);\n  const pub = curve.keyFromPublic(pubkey).getPublic();\n  return priv.derive(pub).toArrayLike(Uint8Array, 'be');\n}\n/**\n * Sign digest using private key.\n * @internal\n */\n\n\nfunction sign(secret, message, type) {\n  const curve = getCurve(type);\n  const key = curve.keyFromPrivate(secret);\n  let sig;\n  let r;\n  let s;\n\n  if (type === 'K1') {\n    let attempt = 1;\n\n    do {\n      sig = key.sign(message, {\n        canonical: true,\n        pers: [attempt++]\n      });\n      r = sig.r.toArrayLike(Uint8Array, 'be', 32);\n      s = sig.s.toArrayLike(Uint8Array, 'be', 32);\n    } while (!isCanonical(r, s));\n  } else {\n    sig = key.sign(message, {\n      canonical: true\n    });\n    r = sig.r.toArrayLike(Uint8Array, 'be', 32);\n    s = sig.s.toArrayLike(Uint8Array, 'be', 32);\n  }\n\n  return {\n    type,\n    r,\n    s,\n    recid: sig.recoveryParam || 0\n  };\n}\n/**\n * Here be dragons\n * - https://github.com/steemit/steem/issues/1944\n * - https://github.com/EOSIO/eos/issues/6699\n * @internal\n */\n\n\nfunction isCanonical(r, s) {\n  return !(r[0] & 0x80) && !(r[0] === 0 && !(r[1] & 0x80)) && !(s[0] & 0x80) && !(s[0] === 0 && !(s[1] & 0x80));\n}\n/**\n * Generate a new private key for given type.\n * @internal\n */\n\n\nfunction generate(type) {\n  const curve = getCurve(type);\n  const privkey = curve.genKeyPair().getPrivate();\n  return privkey.toArrayLike(Uint8Array, 'be');\n}\n\nclass PrivateKey {\n  /** @internal */\n  constructor(type, data) {\n    this.type = type;\n    this.data = data;\n  }\n  /** Create PrivateKey object from representing types. */\n\n\n  static from(value) {\n    if (isInstanceOf(value, PrivateKey)) {\n      return value;\n    }\n\n    if (typeof value !== 'string') {\n      throw new Error('Invalid private key');\n    }\n\n    if (value.startsWith('PVT_')) {\n      // EOSIO format\n      const parts = value.split('_');\n\n      if (parts.length !== 3) {\n        throw new Error('Invalid private key string');\n      }\n\n      const type = CurveType.from(parts[1]);\n      let size;\n\n      switch (type) {\n        case CurveType.K1:\n        case CurveType.R1:\n          size = 32;\n          break;\n      }\n\n      const data = Base58.decodeRipemd160Check(parts[2], size, type);\n      return new PrivateKey(type, data);\n    } else {\n      // WIF format\n      const type = CurveType.K1;\n      const data = Base58.decodeCheck(value);\n\n      if (data.array[0] !== 0x80) {\n        throw new Error('Invalid private key WIF');\n      }\n\n      return new PrivateKey(type, data.droppingFirst());\n    }\n  }\n  /**\n   * Generate new PrivateKey.\n   * @throws If a secure random source isn't available.\n   */\n\n\n  static generate(type) {\n    return new PrivateKey(CurveType.from(type), new Bytes(generate(type)));\n  }\n  /**\n   * Sign message digest using this key.\n   * @throws If the key type isn't R1 or K1.\n   */\n\n\n  signDigest(digest) {\n    digest = Checksum256.from(digest);\n    return Signature.from(sign(this.data.array, digest.array, this.type));\n  }\n  /**\n   * Sign message using this key.\n   * @throws If the key type isn't R1 or K1.\n   */\n\n\n  signMessage(message) {\n    return this.signDigest(Checksum256.hash(message));\n  }\n  /**\n   * Derive the shared secret between this private key and given public key.\n   * @throws If the key type isn't R1 or K1.\n   */\n\n\n  sharedSecret(publicKey) {\n    const shared = sharedSecret(this.data.array, publicKey.data.array, this.type);\n    return Checksum512.hash(shared);\n  }\n  /**\n   * Get the corresponding public key.\n   * @throws If the key type isn't R1 or K1.\n   */\n\n\n  toPublic() {\n    const compressed = getPublic(this.data.array, this.type);\n    return PublicKey.from({\n      compressed,\n      type: this.type\n    });\n  }\n  /**\n   * Return WIF representation of this private key\n   * @throws If the key type isn't K1.\n   */\n\n\n  toWif() {\n    if (this.type !== CurveType.K1) {\n      throw new Error('Unable to generate WIF for non-k1 key');\n    }\n\n    return Base58.encodeCheck(Bytes.from([0x80]).appending(this.data));\n  }\n  /**\n   * Return the key in EOSIO PVT_<type>_<base58check> format.\n   */\n\n\n  toString() {\n    return `PVT_${this.type}_${Base58.encodeRipemd160Check(this.data, this.type)}`;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n\nvar PermissionLevel_1;\n/** EOSIO Permission Level, a.k.a \"auth\". */\n\nlet PermissionLevel = PermissionLevel_1 = class PermissionLevel extends Struct {\n  /** Create new permission level from representing types. Can be expressed as a string in the format `<actor>@<permission>`. */\n  static from(value) {\n    if (typeof value === 'string') {\n      const parts = value.split('@');\n\n      if (parts.length !== 2 && parts[0].length > 0 && parts[1].length > 0) {\n        throw new Error('Invalid permission level string, should be in the format <actor>@<permission>');\n      }\n\n      value = {\n        actor: parts[0],\n        permission: parts[1]\n      };\n    }\n\n    return super.from(value);\n  }\n  /** Return true if this permission level equals other. */\n\n\n  equals(other) {\n    const otherPerm = PermissionLevel_1.from(other);\n    return this.actor.equals(otherPerm.actor) && this.permission.equals(otherPerm.permission);\n  }\n\n  toString() {\n    return `${this.actor}@${this.permission}`;\n  }\n\n};\n\n__decorate([Struct.field('name')], PermissionLevel.prototype, \"actor\", void 0);\n\n__decorate([Struct.field('name')], PermissionLevel.prototype, \"permission\", void 0);\n\nPermissionLevel = PermissionLevel_1 = __decorate([Struct.type('permission_level')], PermissionLevel);\nvar Action_1;\nlet Action = Action_1 = class Action extends Struct {\n  static from(object, abi) {\n    const data = object.data;\n\n    if (!Bytes.isBytes(data)) {\n      let type;\n\n      if (abi) {\n        type = ABI.from(abi).getActionType(object.name);\n      } else if (!data.constructor || data.constructor.abiName === undefined) {\n        throw new Error('Missing ABI definition when creating action with untyped action data');\n      }\n\n      object = { ...object,\n        data: abiEncode({\n          object: data,\n          type,\n          abi\n        })\n      };\n    }\n\n    return super.from(object);\n  }\n  /** Return true if this Action is equal to given action. */\n\n\n  equals(other) {\n    const otherAction = Action_1.from(other);\n    return this.account.equals(otherAction.account) && this.name.equals(otherAction.name) && arrayEquatableEquals(this.authorization, otherAction.authorization) && this.data.equals(otherAction.data);\n  }\n\n  decodeData(typeOrAbi) {\n    if (typeof typeOrAbi === 'string' || typeOrAbi.abiName) {\n      return abiDecode({\n        data: this.data,\n        type: typeOrAbi\n      });\n    } else {\n      const abi = ABI.from(typeOrAbi);\n      const type = abi.getActionType(this.name);\n\n      if (!type) {\n        throw new Error(`Action ${this.name} does not exist in provided ABI`);\n      }\n\n      return abiDecode({\n        data: this.data,\n        type,\n        abi\n      });\n    }\n  }\n\n};\n\n__decorate([Struct.field('name')], Action.prototype, \"account\", void 0);\n\n__decorate([Struct.field('name')], Action.prototype, \"name\", void 0);\n\n__decorate([Struct.field(PermissionLevel, {\n  array: true\n})], Action.prototype, \"authorization\", void 0);\n\n__decorate([Struct.field('bytes')], Action.prototype, \"data\", void 0);\n\nAction = Action_1 = __decorate([Struct.type('action')], Action);\nvar Transaction_1;\nlet TransactionExtension = class TransactionExtension extends Struct {};\n\n__decorate([Struct.field('uint16')], TransactionExtension.prototype, \"type\", void 0);\n\n__decorate([Struct.field('bytes')], TransactionExtension.prototype, \"data\", void 0);\n\nTransactionExtension = __decorate([Struct.type('transaction_extension')], TransactionExtension);\nlet TransactionHeader = class TransactionHeader extends Struct {\n  static from(object) {\n    return super.from(object);\n  }\n\n};\n\n__decorate([Struct.field('time_point_sec')], TransactionHeader.prototype, \"expiration\", void 0);\n\n__decorate([Struct.field('uint16')], TransactionHeader.prototype, \"ref_block_num\", void 0);\n\n__decorate([Struct.field('uint32')], TransactionHeader.prototype, \"ref_block_prefix\", void 0);\n\n__decorate([Struct.field('varuint32', {\n  default: 0\n})], TransactionHeader.prototype, \"max_net_usage_words\", void 0);\n\n__decorate([Struct.field('uint8', {\n  default: 0\n})], TransactionHeader.prototype, \"max_cpu_usage_ms\", void 0);\n\n__decorate([Struct.field('varuint32', {\n  default: 0\n})], TransactionHeader.prototype, \"delay_sec\", void 0);\n\nTransactionHeader = __decorate([Struct.type('transaction_header')], TransactionHeader);\nlet Transaction = Transaction_1 = class Transaction extends TransactionHeader {\n  static from(object, abis) {\n    const abiFor = contract => {\n      if (!abis) {\n        return;\n      } else if (Array.isArray(abis)) {\n        return abis.filter(abi => Name.from(abi.contract).equals(contract)).map(({\n          abi\n        }) => abi)[0];\n      } else {\n        return abis;\n      }\n    };\n\n    const resolveAction = action => Action.from(action, abiFor(action.account));\n\n    const actions = (object.actions || []).map(resolveAction);\n    const context_free_actions = (object.context_free_actions || []).map(resolveAction);\n    const transaction = { ...object,\n      context_free_actions,\n      actions\n    };\n    return super.from(transaction);\n  }\n  /** Return true if this transaction is equal to given transaction. */\n\n\n  equals(other) {\n    const tx = Transaction_1.from(other);\n    return this.id.equals(tx.id);\n  }\n\n  get id() {\n    return Checksum256.hash(abiEncode({\n      object: this\n    }));\n  }\n\n  signingDigest(chainId) {\n    let data = Bytes.from(Checksum256.from(chainId).array);\n    data = data.appending(abiEncode({\n      object: this\n    }));\n    data = data.appending(new Uint8Array(32));\n    return Checksum256.hash(data);\n  }\n\n};\n\n__decorate([Struct.field(Action, {\n  array: true,\n  default: []\n})], Transaction.prototype, \"context_free_actions\", void 0);\n\n__decorate([Struct.field(Action, {\n  array: true,\n  default: []\n})], Transaction.prototype, \"actions\", void 0);\n\n__decorate([Struct.field(TransactionExtension, {\n  array: true,\n  default: []\n})], Transaction.prototype, \"transaction_extensions\", void 0);\n\nTransaction = Transaction_1 = __decorate([Struct.type('transaction')], Transaction);\nlet SignedTransaction = class SignedTransaction extends Transaction {\n  static from(object) {\n    return super.from(object);\n  }\n\n};\n\n__decorate([Struct.field('signature[]', {\n  default: []\n})], SignedTransaction.prototype, \"signatures\", void 0);\n\n__decorate([Struct.field('bytes[]', {\n  default: []\n})], SignedTransaction.prototype, \"context_free_data\", void 0);\n\nSignedTransaction = __decorate([Struct.type('signed_transaction')], SignedTransaction);\nlet PackedTransaction = class PackedTransaction extends Struct {\n  static fromSigned(signed) {\n    const tx = Transaction.from(signed);\n    return this.from({\n      signatures: signed.signatures,\n      packed_context_free_data: abiEncode({\n        object: signed.context_free_data,\n        type: 'bytes[]'\n      }),\n      packed_trx: abiEncode({\n        object: tx\n      })\n    });\n  }\n\n  getTransaction() {\n    if (this.compression.value !== 0) {\n      throw new Error('Transaction compression not supported yet');\n    }\n\n    return abiDecode({\n      data: this.packed_trx,\n      type: Transaction\n    });\n  }\n\n  getSignedTransaction() {\n    const transaction = this.getTransaction(); // TODO: decode context free data\n\n    return SignedTransaction.from({ ...transaction,\n      signatures: this.signatures\n    });\n  }\n\n};\n\n__decorate([Struct.field('signature[]')], PackedTransaction.prototype, \"signatures\", void 0);\n\n__decorate([Struct.field('uint8', {\n  default: 0\n})], PackedTransaction.prototype, \"compression\", void 0);\n\n__decorate([Struct.field('bytes')], PackedTransaction.prototype, \"packed_context_free_data\", void 0);\n\n__decorate([Struct.field('bytes')], PackedTransaction.prototype, \"packed_trx\", void 0);\n\nPackedTransaction = __decorate([Struct.type('packed_transaction')], PackedTransaction);\nlet TransactionReceipt = class TransactionReceipt extends Struct {};\n\n__decorate([Struct.field('string')], TransactionReceipt.prototype, \"status\", void 0);\n\n__decorate([Struct.field('uint32')], TransactionReceipt.prototype, \"cpu_usage_us\", void 0);\n\n__decorate([Struct.field('uint32')], TransactionReceipt.prototype, \"net_usage_words\", void 0);\n\nTransactionReceipt = __decorate([Struct.type('transaction_receipt')], TransactionReceipt);\nvar Authority_1;\nlet Weight = class Weight extends UInt16 {};\nWeight = __decorate([TypeAlias('weight_type')], Weight);\nlet KeyWeight = class KeyWeight extends Struct {};\n\n__decorate([Struct.field(PublicKey)], KeyWeight.prototype, \"key\", void 0);\n\n__decorate([Struct.field(Weight)], KeyWeight.prototype, \"weight\", void 0);\n\nKeyWeight = __decorate([Struct.type('key_weight')], KeyWeight);\nlet PermissionLevelWeight = class PermissionLevelWeight extends Struct {};\n\n__decorate([Struct.field(PermissionLevel)], PermissionLevelWeight.prototype, \"permission\", void 0);\n\n__decorate([Struct.field(Weight)], PermissionLevelWeight.prototype, \"weight\", void 0);\n\nPermissionLevelWeight = __decorate([Struct.type('permission_level_weight')], PermissionLevelWeight);\nlet WaitWeight = class WaitWeight extends Struct {};\n\n__decorate([Struct.field(UInt32)], WaitWeight.prototype, \"wait_sec\", void 0);\n\n__decorate([Struct.field(Weight)], WaitWeight.prototype, \"weight\", void 0);\n\nWaitWeight = __decorate([Struct.type('wait_weight')], WaitWeight);\nlet Authority = Authority_1 = class Authority extends Struct {\n  static from(value) {\n    if (isInstanceOf(value, Authority_1)) {\n      return value;\n    }\n\n    const rv = super.from({\n      keys: [],\n      accounts: [],\n      waits: [],\n      ...value\n    });\n    rv.sort();\n    return rv;\n  }\n  /** Total weight of all waits. */\n\n\n  get waitThreshold() {\n    return this.waits.reduce((val, wait) => val + wait.weight.toNumber(), 0);\n  }\n  /** Weight a key needs to sign for this authority. */\n\n\n  get keyTreshhold() {\n    return this.threshold.toNumber() - this.waitThreshold;\n  }\n  /** Return the weight for given public key, or zero if it is not included in this authority. */\n\n\n  keyWeight(publicKey) {\n    const weight = this.keys.find(({\n      key\n    }) => key.equals(publicKey));\n    return weight ? weight.weight.toNumber() : 0;\n  }\n  /**\n   * Check if given public key has permission in this authority,\n   * @attention Does not take indirect permissions for the key via account weights into account.\n   * @param publicKey The key to check.\n   * @param includePartial Whether to consider auths where the key is included but can't be reached alone (e.g. multisig).\n   */\n\n\n  hasPermission(publicKey, includePartial = false) {\n    const threshold = includePartial ? 1 : this.keyTreshhold;\n    const weight = this.keyWeight(publicKey);\n    return weight >= threshold;\n  }\n  /**\n   * Sorts the authority weights in place, should be called before including the authority in a `updateauth` action or it might be rejected.\n   */\n\n\n  sort() {\n    // This hack satisfies the constraints that authority weights, see: https://github.com/greymass/eosio-core/issues/8\n    this.keys.sort((a, b) => String(a.key).localeCompare(String(b.key)));\n    this.accounts.sort((a, b) => String(a.permission).localeCompare(String(b.permission)));\n    this.waits.sort((a, b) => String(a.wait_sec).localeCompare(String(b.wait_sec)));\n  }\n\n};\n\n__decorate([Struct.field(UInt32)], Authority.prototype, \"threshold\", void 0);\n\n__decorate([Struct.field(KeyWeight, {\n  array: true\n})], Authority.prototype, \"keys\", void 0);\n\n__decorate([Struct.field(PermissionLevelWeight, {\n  array: true\n})], Authority.prototype, \"accounts\", void 0);\n\n__decorate([Struct.field(WaitWeight, {\n  array: true\n})], Authority.prototype, \"waits\", void 0);\n\nAuthority = Authority_1 = __decorate([Struct.type('authority')], Authority);\nvar Serializer;\n\n(function (Serializer) {\n  Serializer.encode = abiEncode;\n  Serializer.decode = abiDecode;\n  /** Create an EOSIO ABI definition for given core type. */\n\n  function synthesize(type) {\n    return synthesizeABI(type).abi;\n  }\n\n  Serializer.synthesize = synthesize;\n  /** Create JSON representation of a core object. */\n\n  function stringify(object) {\n    return JSON.stringify(object);\n  }\n\n  Serializer.stringify = stringify;\n  /** Create a vanilla js representation of a core object. */\n\n  function objectify(object) {\n    return JSON.parse(JSON.stringify(object));\n  }\n\n  Serializer.objectify = objectify;\n})(Serializer || (Serializer = {}));\n/** Default provider that uses the Fetch API to call a single node. */\n\n\nclass FetchProvider {\n  constructor(url, options = {}) {\n    url = url.trim();\n    if (url.endsWith('/')) url = url.slice(0, -1);\n    this.url = url;\n\n    if (!options.fetch) {\n      if (typeof window !== 'undefined' && window.fetch) {\n        this.fetch = window.fetch.bind(window);\n      } else if (typeof global !== 'undefined' && global.fetch) {\n        this.fetch = global.fetch.bind(global);\n      } else {\n        throw new Error('Missing fetch');\n      }\n    } else {\n      this.fetch = options.fetch;\n    }\n  }\n\n  async call(path, params) {\n    const url = this.url + path;\n    const response = await this.fetch(url, {\n      method: 'POST',\n      body: params !== undefined ? JSON.stringify(params) : undefined\n    });\n\n    try {\n      return response.json();\n    } catch (error) {\n      if (!response.ok) {\n        throw Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      error.message = `Unable to parse JSON response from server: ${error.message}`;\n      throw error;\n    }\n  }\n\n}\n\nlet AccountPermission = class AccountPermission extends Struct {};\n\n__decorate([Struct.field('name')], AccountPermission.prototype, \"perm_name\", void 0);\n\n__decorate([Struct.field('name')], AccountPermission.prototype, \"parent\", void 0);\n\n__decorate([Struct.field(Authority)], AccountPermission.prototype, \"required_auth\", void 0);\n\nAccountPermission = __decorate([Struct.type('account_permission')], AccountPermission);\nlet AccountResourceLimit = class AccountResourceLimit extends Struct {};\n\n__decorate([Struct.field('uint64')], AccountResourceLimit.prototype, \"used\", void 0);\n\n__decorate([Struct.field('uint64')], AccountResourceLimit.prototype, \"available\", void 0);\n\n__decorate([Struct.field('uint64')], AccountResourceLimit.prototype, \"max\", void 0);\n\nAccountResourceLimit = __decorate([Struct.type('account_resource_limit')], AccountResourceLimit);\nlet AccountTotalResources = class AccountTotalResources extends Struct {};\n\n__decorate([Struct.field('name')], AccountTotalResources.prototype, \"owner\", void 0);\n\n__decorate([Struct.field('asset')], AccountTotalResources.prototype, \"net_weight\", void 0);\n\n__decorate([Struct.field('asset')], AccountTotalResources.prototype, \"cpu_weight\", void 0);\n\n__decorate([Struct.field('uint64')], AccountTotalResources.prototype, \"ram_bytes\", void 0);\n\nAccountTotalResources = __decorate([Struct.type('account_total_resources')], AccountTotalResources);\nlet AccountSelfDelegatedBandwidth = class AccountSelfDelegatedBandwidth extends Struct {};\n\n__decorate([Struct.field('name')], AccountSelfDelegatedBandwidth.prototype, \"from\", void 0);\n\n__decorate([Struct.field('name')], AccountSelfDelegatedBandwidth.prototype, \"to\", void 0);\n\n__decorate([Struct.field('asset')], AccountSelfDelegatedBandwidth.prototype, \"net_weight\", void 0);\n\n__decorate([Struct.field('asset')], AccountSelfDelegatedBandwidth.prototype, \"cpu_weight\", void 0);\n\nAccountSelfDelegatedBandwidth = __decorate([Struct.type('account_self_delegated_bandwidth')], AccountSelfDelegatedBandwidth);\nlet AccountRefundRequest = class AccountRefundRequest extends Struct {};\n\n__decorate([Struct.field('name')], AccountRefundRequest.prototype, \"owner\", void 0);\n\n__decorate([Struct.field('time_point')], AccountRefundRequest.prototype, \"request_time\", void 0);\n\n__decorate([Struct.field('asset')], AccountRefundRequest.prototype, \"net_amount\", void 0);\n\n__decorate([Struct.field('asset')], AccountRefundRequest.prototype, \"cpu_amount\", void 0);\n\nAccountRefundRequest = __decorate([Struct.type('account_refund_request')], AccountRefundRequest);\nlet AccountVoterInfo = class AccountVoterInfo extends Struct {};\n\n__decorate([Struct.field('name')], AccountVoterInfo.prototype, \"owner\", void 0);\n\n__decorate([Struct.field('name')], AccountVoterInfo.prototype, \"proxy\", void 0);\n\n__decorate([Struct.field('name', {\n  array: true\n})], AccountVoterInfo.prototype, \"producers\", void 0);\n\n__decorate([Struct.field('int64', {\n  optional: true\n})], AccountVoterInfo.prototype, \"staked\", void 0);\n\n__decorate([Struct.field('bool')], AccountVoterInfo.prototype, \"is_proxy\", void 0);\n\n__decorate([Struct.field('uint32', {\n  optional: true\n})], AccountVoterInfo.prototype, \"flags1\", void 0);\n\n__decorate([Struct.field('uint32')], AccountVoterInfo.prototype, \"reserved2\", void 0);\n\n__decorate([Struct.field('string')], AccountVoterInfo.prototype, \"reserved3\", void 0);\n\nAccountVoterInfo = __decorate([Struct.type('account_voter_info')], AccountVoterInfo);\nlet AccountRexInfoMaturities = class AccountRexInfoMaturities extends Struct {};\n\n__decorate([Struct.field('time_point', {\n  optional: true\n})], AccountRexInfoMaturities.prototype, \"key\", void 0);\n\n__decorate([Struct.field('int64', {\n  optional: true\n})], AccountRexInfoMaturities.prototype, \"value\", void 0);\n\n__decorate([Struct.field('time_point', {\n  optional: true\n})], AccountRexInfoMaturities.prototype, \"first\", void 0);\n\n__decorate([Struct.field('int64', {\n  optional: true\n})], AccountRexInfoMaturities.prototype, \"second\", void 0);\n\nAccountRexInfoMaturities = __decorate([Struct.type('account_rex_info_maturities')], AccountRexInfoMaturities);\nlet AccountRexInfo = class AccountRexInfo extends Struct {};\n\n__decorate([Struct.field('uint32')], AccountRexInfo.prototype, \"version\", void 0);\n\n__decorate([Struct.field('name')], AccountRexInfo.prototype, \"owner\", void 0);\n\n__decorate([Struct.field('asset')], AccountRexInfo.prototype, \"vote_stake\", void 0);\n\n__decorate([Struct.field('asset')], AccountRexInfo.prototype, \"rex_balance\", void 0);\n\n__decorate([Struct.field('int64')], AccountRexInfo.prototype, \"matured_rex\", void 0);\n\n__decorate([Struct.field(AccountRexInfoMaturities, {\n  array: true\n})], AccountRexInfo.prototype, \"rex_maturities\", void 0);\n\nAccountRexInfo = __decorate([Struct.type('account_rex_info')], AccountRexInfo);\nlet AccountObject = class AccountObject extends Struct {\n  getPermission(permission) {\n    const name = Name.from(permission);\n    const match = this.permissions.find(p => p.perm_name.equals(name));\n\n    if (!match) {\n      throw new Error(`Unknown permission ${name} on account ${this.account_name}.`);\n    }\n\n    return match;\n  }\n\n};\n\n__decorate([Struct.field('name')], AccountObject.prototype, \"account_name\", void 0);\n\n__decorate([Struct.field('uint32')], AccountObject.prototype, \"head_block_num\", void 0);\n\n__decorate([Struct.field('time_point')], AccountObject.prototype, \"head_block_time\", void 0);\n\n__decorate([Struct.field('bool')], AccountObject.prototype, \"privileged\", void 0);\n\n__decorate([Struct.field('time_point')], AccountObject.prototype, \"last_code_update\", void 0);\n\n__decorate([Struct.field('time_point')], AccountObject.prototype, \"created\", void 0);\n\n__decorate([Struct.field('asset?')], AccountObject.prototype, \"core_liquid_balance\", void 0);\n\n__decorate([Struct.field('int64')], AccountObject.prototype, \"ram_quota\", void 0);\n\n__decorate([Struct.field('int64')], AccountObject.prototype, \"net_weight\", void 0);\n\n__decorate([Struct.field('int64')], AccountObject.prototype, \"cpu_weight\", void 0);\n\n__decorate([Struct.field(AccountResourceLimit)], AccountObject.prototype, \"net_limit\", void 0);\n\n__decorate([Struct.field(AccountResourceLimit)], AccountObject.prototype, \"cpu_limit\", void 0);\n\n__decorate([Struct.field('uint64')], AccountObject.prototype, \"ram_usage\", void 0);\n\n__decorate([Struct.field(AccountPermission, {\n  array: true\n})], AccountObject.prototype, \"permissions\", void 0);\n\n__decorate([Struct.field(AccountTotalResources)], AccountObject.prototype, \"total_resources\", void 0);\n\n__decorate([Struct.field(AccountSelfDelegatedBandwidth, {\n  optional: true\n})], AccountObject.prototype, \"self_delegated_bandwidth\", void 0);\n\n__decorate([Struct.field(AccountRefundRequest, {\n  optional: true\n})], AccountObject.prototype, \"refund_request\", void 0);\n\n__decorate([Struct.field(AccountVoterInfo, {\n  optional: true\n})], AccountObject.prototype, \"voter_info\", void 0);\n\n__decorate([Struct.field(AccountRexInfo, {\n  optional: true\n})], AccountObject.prototype, \"rex_info\", void 0);\n\nAccountObject = __decorate([Struct.type('account_object')], AccountObject);\nlet NewProducersEntry = class NewProducersEntry extends Struct {};\n\n__decorate([Struct.field('name')], NewProducersEntry.prototype, \"producer_name\", void 0);\n\n__decorate([Struct.field('public_key')], NewProducersEntry.prototype, \"block_signing_key\", void 0);\n\nNewProducersEntry = __decorate([Struct.type('new_producers_entry')], NewProducersEntry);\nlet NewProducers = class NewProducers extends Struct {};\n\n__decorate([Struct.field('uint32')], NewProducers.prototype, \"version\", void 0);\n\n__decorate([Struct.field(NewProducersEntry, {\n  array: true\n})], NewProducers.prototype, \"producers\", void 0);\n\nNewProducers = __decorate([Struct.type('new_producers')], NewProducers);\nlet BlockExtension = class BlockExtension extends Struct {};\n\n__decorate([Struct.field('uint16')], BlockExtension.prototype, \"type\", void 0);\n\n__decorate([Struct.field('bytes')], BlockExtension.prototype, \"data\", void 0);\n\nBlockExtension = __decorate([Struct.type('block_extension')], BlockExtension);\nlet HeaderExtension = class HeaderExtension extends Struct {};\n\n__decorate([Struct.field('uint16')], HeaderExtension.prototype, \"type\", void 0);\n\n__decorate([Struct.field('bytes')], HeaderExtension.prototype, \"data\", void 0);\n\nHeaderExtension = __decorate([Struct.type('header_extension')], HeaderExtension);\nlet GetBlockResponse = class GetBlockResponse extends Struct {};\n\n__decorate([Struct.field('time_point')], GetBlockResponse.prototype, \"timestamp\", void 0);\n\n__decorate([Struct.field('name')], GetBlockResponse.prototype, \"producer\", void 0);\n\n__decorate([Struct.field('uint16')], GetBlockResponse.prototype, \"confirmed\", void 0);\n\n__decorate([Struct.field('checksum256')], GetBlockResponse.prototype, \"previous\", void 0);\n\n__decorate([Struct.field('checksum256')], GetBlockResponse.prototype, \"transaction_mroot\", void 0);\n\n__decorate([Struct.field('checksum256')], GetBlockResponse.prototype, \"action_mroot\", void 0);\n\n__decorate([Struct.field('uint32')], GetBlockResponse.prototype, \"schedule_version\", void 0);\n\n__decorate([Struct.field(NewProducers, {\n  optional: true\n})], GetBlockResponse.prototype, \"new_producers\", void 0);\n\n__decorate([Struct.field('header_extension', {\n  optional: true\n})], GetBlockResponse.prototype, \"header_extensions\", void 0);\n\n__decorate([Struct.field('any', {\n  optional: true\n})], GetBlockResponse.prototype, \"new_protocol_features\", void 0);\n\n__decorate([Struct.field('signature')], GetBlockResponse.prototype, \"producer_signature\", void 0);\n\n__decorate([Struct.field(TransactionReceipt, {\n  array: true\n})], GetBlockResponse.prototype, \"transactions\", void 0);\n\n__decorate([Struct.field('block_extension', {\n  optional: true\n})], GetBlockResponse.prototype, \"block_extensions\", void 0);\n\n__decorate([Struct.field('checksum256')], GetBlockResponse.prototype, \"id\", void 0);\n\n__decorate([Struct.field('uint32')], GetBlockResponse.prototype, \"block_num\", void 0);\n\n__decorate([Struct.field('uint32')], GetBlockResponse.prototype, \"ref_block_prefix\", void 0);\n\nGetBlockResponse = __decorate([Struct.type('get_block_response')], GetBlockResponse);\nlet ActiveScheduleProducerAuthority = class ActiveScheduleProducerAuthority extends Struct {};\n\n__decorate([Struct.field('name')], ActiveScheduleProducerAuthority.prototype, \"producer_name\", void 0);\n\n__decorate([Struct.field('any')], ActiveScheduleProducerAuthority.prototype, \"authority\", void 0);\n\nActiveScheduleProducerAuthority = __decorate([Struct.type('active_schedule_producer_authority')], ActiveScheduleProducerAuthority);\nlet ActiveScheduleProducer = class ActiveScheduleProducer extends Struct {};\n\n__decorate([Struct.field('name')], ActiveScheduleProducer.prototype, \"producer_name\", void 0);\n\n__decorate([Struct.field(ActiveScheduleProducerAuthority)], ActiveScheduleProducer.prototype, \"authority\", void 0);\n\nActiveScheduleProducer = __decorate([Struct.type('active_schedule_producer')], ActiveScheduleProducer);\nlet ActiveSchedule = class ActiveSchedule extends Struct {};\n\n__decorate([Struct.field('uint32')], ActiveSchedule.prototype, \"version\", void 0);\n\n__decorate([Struct.field(ActiveScheduleProducer, {\n  array: true\n})], ActiveSchedule.prototype, \"producers\", void 0);\n\nActiveSchedule = __decorate([Struct.type('active_schedule')], ActiveSchedule);\nlet BlockStateHeader = class BlockStateHeader extends Struct {};\n\n__decorate([Struct.field('time_point')], BlockStateHeader.prototype, \"timestamp\", void 0);\n\n__decorate([Struct.field('name')], BlockStateHeader.prototype, \"producer\", void 0);\n\n__decorate([Struct.field('uint16')], BlockStateHeader.prototype, \"confirmed\", void 0);\n\n__decorate([Struct.field('checksum256')], BlockStateHeader.prototype, \"previous\", void 0);\n\n__decorate([Struct.field('checksum256')], BlockStateHeader.prototype, \"transaction_mroot\", void 0);\n\n__decorate([Struct.field('checksum256')], BlockStateHeader.prototype, \"action_mroot\", void 0);\n\n__decorate([Struct.field('uint32')], BlockStateHeader.prototype, \"schedule_version\", void 0);\n\n__decorate([Struct.field(HeaderExtension, {\n  array: true,\n  optional: true\n})], BlockStateHeader.prototype, \"header_extensions\", void 0);\n\n__decorate([Struct.field('signature')], BlockStateHeader.prototype, \"producer_signature\", void 0);\n\nBlockStateHeader = __decorate([Struct.type('block_state_header')], BlockStateHeader);\nlet GetBlockHeaderStateResponse = class GetBlockHeaderStateResponse extends Struct {};\n\n__decorate([Struct.field('uint32')], GetBlockHeaderStateResponse.prototype, \"block_num\", void 0);\n\n__decorate([Struct.field('uint32')], GetBlockHeaderStateResponse.prototype, \"dpos_proposed_irreversible_blocknum\", void 0);\n\n__decorate([Struct.field('uint32')], GetBlockHeaderStateResponse.prototype, \"dpos_irreversible_blocknum\", void 0);\n\n__decorate([Struct.field('checksum256')], GetBlockHeaderStateResponse.prototype, \"id\", void 0);\n\n__decorate([Struct.field(BlockStateHeader)], GetBlockHeaderStateResponse.prototype, \"header\", void 0);\n\n__decorate([Struct.field('any')], GetBlockHeaderStateResponse.prototype, \"active_schedule\", void 0);\n\n__decorate([Struct.field('any')], GetBlockHeaderStateResponse.prototype, \"blockroot_merkle\", void 0);\n\n__decorate([Struct.field('any')], GetBlockHeaderStateResponse.prototype, \"producer_to_last_produced\", void 0);\n\n__decorate([Struct.field('any')], GetBlockHeaderStateResponse.prototype, \"producer_to_last_implied_irb\", void 0);\n\n__decorate([Struct.field('any')], GetBlockHeaderStateResponse.prototype, \"valid_block_signing_authority\", void 0);\n\n__decorate([Struct.field('any')], GetBlockHeaderStateResponse.prototype, \"confirm_count\", void 0);\n\n__decorate([Struct.field('any')], GetBlockHeaderStateResponse.prototype, \"pending_schedule\", void 0);\n\n__decorate([Struct.field('any')], GetBlockHeaderStateResponse.prototype, \"activated_protocol_features\", void 0);\n\n__decorate([Struct.field('any')], GetBlockHeaderStateResponse.prototype, \"additional_signatures\", void 0);\n\nGetBlockHeaderStateResponse = __decorate([Struct.type('get_block_header_state_response')], GetBlockHeaderStateResponse);\nlet GetInfoResponse = class GetInfoResponse extends Struct {\n  getTransactionHeader(secondsAhead = 120) {\n    const expiration = TimePointSec.fromMilliseconds(this.head_block_time.toMilliseconds() + secondsAhead * 1000);\n    const id = this.last_irreversible_block_id;\n    const prefixArray = id.array.subarray(8, 12);\n    const prefix = new Uint32Array(prefixArray.buffer, prefixArray.byteOffset, 1)[0];\n    return TransactionHeader.from({\n      expiration,\n      ref_block_num: this.last_irreversible_block_num.value & 0xffff,\n      ref_block_prefix: prefix\n    });\n  }\n\n};\n\n__decorate([Struct.field('string')], GetInfoResponse.prototype, \"server_version\", void 0);\n\n__decorate([Struct.field('checksum256')], GetInfoResponse.prototype, \"chain_id\", void 0);\n\n__decorate([Struct.field('uint32')], GetInfoResponse.prototype, \"head_block_num\", void 0);\n\n__decorate([Struct.field('uint32')], GetInfoResponse.prototype, \"last_irreversible_block_num\", void 0);\n\n__decorate([Struct.field('checksum256')], GetInfoResponse.prototype, \"last_irreversible_block_id\", void 0);\n\n__decorate([Struct.field('checksum256')], GetInfoResponse.prototype, \"head_block_id\", void 0);\n\n__decorate([Struct.field('time_point')], GetInfoResponse.prototype, \"head_block_time\", void 0);\n\n__decorate([Struct.field('name')], GetInfoResponse.prototype, \"head_block_producer\", void 0);\n\n__decorate([Struct.field('uint64')], GetInfoResponse.prototype, \"virtual_block_cpu_limit\", void 0);\n\n__decorate([Struct.field('uint64')], GetInfoResponse.prototype, \"virtual_block_net_limit\", void 0);\n\n__decorate([Struct.field('uint64')], GetInfoResponse.prototype, \"block_cpu_limit\", void 0);\n\n__decorate([Struct.field('uint64')], GetInfoResponse.prototype, \"block_net_limit\", void 0);\n\n__decorate([Struct.field('string?')], GetInfoResponse.prototype, \"server_version_string\", void 0);\n\n__decorate([Struct.field('uint32?')], GetInfoResponse.prototype, \"fork_db_head_block_num\", void 0);\n\n__decorate([Struct.field('checksum256?')], GetInfoResponse.prototype, \"fork_db_head_block_id\", void 0);\n\nGetInfoResponse = __decorate([Struct.type('get_info_response')], GetInfoResponse);\nvar types$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n\n  get AccountPermission() {\n    return AccountPermission;\n  },\n\n  get AccountResourceLimit() {\n    return AccountResourceLimit;\n  },\n\n  get AccountTotalResources() {\n    return AccountTotalResources;\n  },\n\n  get AccountSelfDelegatedBandwidth() {\n    return AccountSelfDelegatedBandwidth;\n  },\n\n  get AccountRefundRequest() {\n    return AccountRefundRequest;\n  },\n\n  get AccountVoterInfo() {\n    return AccountVoterInfo;\n  },\n\n  get AccountRexInfoMaturities() {\n    return AccountRexInfoMaturities;\n  },\n\n  get AccountRexInfo() {\n    return AccountRexInfo;\n  },\n\n  get AccountObject() {\n    return AccountObject;\n  },\n\n  get NewProducersEntry() {\n    return NewProducersEntry;\n  },\n\n  get NewProducers() {\n    return NewProducers;\n  },\n\n  get BlockExtension() {\n    return BlockExtension;\n  },\n\n  get HeaderExtension() {\n    return HeaderExtension;\n  },\n\n  get GetBlockResponse() {\n    return GetBlockResponse;\n  },\n\n  get ActiveScheduleProducerAuthority() {\n    return ActiveScheduleProducerAuthority;\n  },\n\n  get ActiveScheduleProducer() {\n    return ActiveScheduleProducer;\n  },\n\n  get ActiveSchedule() {\n    return ActiveSchedule;\n  },\n\n  get BlockStateHeader() {\n    return BlockStateHeader;\n  },\n\n  get GetBlockHeaderStateResponse() {\n    return GetBlockHeaderStateResponse;\n  },\n\n  get GetInfoResponse() {\n    return GetInfoResponse;\n  }\n\n});\n\nclass ChainAPI {\n  constructor(client) {\n    this.client = client;\n  }\n\n  async get_abi(accountName) {\n    return this.client.call({\n      path: '/v1/chain/get_abi',\n      params: {\n        account_name: Name.from(accountName)\n      }\n    });\n  }\n\n  async get_account(accountName) {\n    return this.client.call({\n      path: '/v1/chain/get_account',\n      params: {\n        account_name: Name.from(accountName)\n      },\n      responseType: AccountObject\n    });\n  }\n\n  async get_block(block_num_or_id) {\n    return this.client.call({\n      path: '/v1/chain/get_block',\n      params: {\n        block_num_or_id\n      },\n      responseType: GetBlockResponse\n    });\n  }\n\n  async get_block_header_state(block_num_or_id) {\n    return this.client.call({\n      path: '/v1/chain/get_block_header_state',\n      params: {\n        block_num_or_id\n      },\n      responseType: GetBlockHeaderStateResponse\n    });\n  }\n\n  async get_currency_balance(contract, accountName, symbol) {\n    const params = {\n      account: Name.from(accountName),\n      code: Name.from(contract)\n    };\n\n    if (symbol) {\n      params.symbol = symbol;\n    }\n\n    return this.client.call({\n      path: '/v1/chain/get_currency_balance',\n      params,\n      responseType: 'asset[]'\n    });\n  }\n\n  async get_info() {\n    return this.client.call({\n      path: '/v1/chain/get_info',\n      responseType: GetInfoResponse\n    });\n  }\n\n  async push_transaction(tx) {\n    if (!isInstanceOf(tx, PackedTransaction)) {\n      tx = PackedTransaction.fromSigned(SignedTransaction.from(tx));\n    }\n\n    return this.client.call({\n      path: '/v1/chain/push_transaction',\n      params: tx\n    });\n  }\n\n  async get_table_rows(params) {\n    const type = params.type;\n    let key_type = params.key_type;\n    const someBound = params.lower_bound || params.upper_bound;\n\n    if (!key_type && someBound) {\n      // determine key type from bounds type\n      if (isInstanceOf(someBound, Int64)) {\n        key_type = 'i64';\n      } else if (isInstanceOf(someBound, Int128)) {\n        key_type = 'i128';\n      } else if (isInstanceOf(someBound, Checksum256)) {\n        key_type = 'sha256';\n      } else if (isInstanceOf(someBound, Checksum160)) {\n        key_type = 'ripemd160';\n      }\n    }\n\n    if (!key_type) {\n      key_type = 'name';\n    }\n\n    let json = params.json;\n\n    if (json === undefined) {\n      // if we know the row type don't ask the node to perform abi decoding\n      json = type === undefined;\n    }\n\n    let upper_bound = params.upper_bound;\n\n    if (upper_bound && typeof upper_bound !== 'string') {\n      upper_bound = String(upper_bound);\n    }\n\n    let lower_bound = params.lower_bound;\n\n    if (lower_bound && typeof lower_bound !== 'string') {\n      lower_bound = String(lower_bound);\n    }\n\n    let scope = params.scope;\n\n    if (typeof scope === 'undefined') {\n      scope = String(Name.from(params.code));\n    } // eslint-disable-next-line prefer-const\n\n\n    let {\n      rows,\n      more,\n      next_key\n    } = await this.client.call({\n      path: '/v1/chain/get_table_rows',\n      params: {\n        code: Name.from(params.code),\n        table: Name.from(params.table),\n        limit: params.limit !== undefined ? UInt32.from(params.limit) : undefined,\n        scope,\n        key_type,\n        json,\n        upper_bound,\n        lower_bound\n      }\n    });\n\n    if (type) {\n      if (json) {\n        rows = rows.map(value => {\n          if (typeof value === 'string' && Bytes.isBytes(value)) {\n            // this handles the case where nodeos bails on abi decoding and just returns a hex string\n            return Serializer.decode({\n              data: Bytes.from(value),\n              type\n            });\n          } else {\n            return Serializer.decode({\n              object: value,\n              type\n            });\n          }\n        });\n      } else {\n        rows = rows.map(hex => Bytes.from(hex)).map(data => Serializer.decode({\n          data,\n          type\n        }));\n      }\n    }\n\n    if (next_key && next_key.length > 0) {\n      let indexType; // set index type so we can decode next_key in the response if present\n\n      switch (key_type) {\n        case 'i64':\n          indexType = Int64;\n          break;\n\n        case 'i128':\n          indexType = Int128;\n          break;\n\n        case 'name':\n          indexType = Name;\n          break;\n\n        case 'float64':\n          indexType = Float64;\n          break;\n\n        case 'float128':\n          indexType = Float128;\n          break;\n\n        case 'sha256':\n          indexType = Checksum256;\n          break;\n\n        case 'ripemd160':\n          indexType = Checksum160;\n          break;\n\n        default:\n          throw new Error(`Unsupported key type: ${key_type}`);\n      }\n\n      if (indexType === Name) {\n        // names are sent back as an uint64 string instead of a name string..\n        next_key = Name.from(Serializer.decode({\n          object: next_key,\n          type: UInt64\n        }));\n      } else {\n        next_key = Serializer.decode({\n          object: next_key,\n          type: indexType\n        });\n      }\n    } else {\n      next_key = undefined;\n    }\n\n    return {\n      rows,\n      more,\n      next_key\n    };\n  }\n\n}\n\nclass APIError extends Error {\n  constructor(path, error) {\n    super(`${APIError.formatError(error)} at ${path}`);\n    this.path = path;\n    this.error = error;\n  }\n\n  static formatError(error) {\n    if (error.what === 'unspecified' && error.details && error.details.length > 0) {\n      return error.details[0].message;\n    } else if (error.what && error.what.length > 0) {\n      return error.what;\n    } else {\n      return 'Unknown API error';\n    }\n  }\n  /** The nodeos error name, e.g. `tx_net_usage_exceeded` */\n\n\n  get name() {\n    return this.error.name || 'unspecified';\n  }\n  /** The nodeos error code, e.g. `3080002`. */\n\n\n  get code() {\n    return this.error.code || 0;\n  }\n  /** List of exceptions, if any. */\n\n\n  get details() {\n    return this.error.details;\n  }\n\n}\n\nAPIError.__className = 'APIError';\n\nclass APIClient {\n  constructor(options) {\n    this.v1 = {\n      chain: new ChainAPI(this)\n    };\n\n    if (options.provider) {\n      this.provider = options.provider;\n    } else if (options.url) {\n      this.provider = new FetchProvider(options.url, options);\n    } else {\n      throw new Error('Missing url or provider');\n    }\n  }\n\n  async call(args) {\n    const response = await this.provider.call(args.path, args.params);\n\n    if (response.error) {\n      throw new APIError(args.path, response.error);\n    }\n\n    if (args.responseType) {\n      return abiDecode({\n        type: args.responseType,\n        object: response\n      });\n    }\n\n    return response;\n  }\n\n}\n\nAPIClient.__className = 'APIClient';\nvar types = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  v1: types$1\n});\nexport { ABI, ABIDecoder, ABIEncoder, types as API, APIClient, APIError, Action, Asset, Authority, Base58, BlockTimestamp, Bytes, Checksum160, Checksum256, Checksum512, CurveType, ExtendedAsset, FetchProvider, Float128, Float32, Float64, Int128, Int16, Int32, Int64, Int8, Name, PackedTransaction, PermissionLevel, PrivateKey, PublicKey, Serializer, Signature, SignedTransaction, Struct, TimePoint, TimePointSec, Transaction, TransactionExtension, TransactionHeader, TransactionReceipt, TypeAlias, UInt128, UInt16, UInt32, UInt64, UInt8, VarInt, VarUInt, Variant, isInstanceOf };","map":{"version":3,"sources":["../src/utils.ts","../src/chain/bytes.ts","../src/chain/checksum.ts","../src/chain/curve-type.ts","../src/serializer/serializable.ts","../src/serializer/builtins.ts","../src/serializer/decoder.ts","../src/chain/integer.ts","../src/serializer/encoder.ts","../src/chain/struct.ts","../src/chain/type-alias.ts","../src/chain/variant.ts","../src/chain/float.ts","../src/chain/name.ts","../src/chain/time.ts","../src/chain/abi.ts","../src/chain/asset.ts","../src/base58.ts","../src/chain/public-key.ts","../src/crypto/curves.ts","../src/crypto/recover.ts","../src/crypto/verify.ts","../src/chain/signature.ts","../src/crypto/get-public.ts","../src/crypto/shared-secret.ts","../src/crypto/sign.ts","../src/crypto/generate.ts","../src/chain/private-key.ts","../src/chain/permission-level.ts","../src/chain/action.ts","../src/chain/transaction.ts","../src/chain/authority.ts","../src/serializer/index.ts","../src/api/provider.ts","../src/api/v1/types.ts","../src/api/v1/chain.ts","../src/api/client.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * EOSIO Core v0.3.2\n * https://github.com/greymass/eosio-core\n *\n * @license\n * Copyright (c) 2020 FFF00 Agents AB & Greymass Inc. All Rights Reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \n *  1. Redistribution of source code must retain the above copyright notice, this\n *     list of conditions and the following disclaimer.\n * \n *  2. Redistribution in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n * \n *  3. Neither the name of the copyright holder nor the names of its contributors\n *     may be used to endorse or promote products derived from this software without\n *     specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE\n * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.\n */\nimport rand from 'brorand';\nimport { sha256, sha512, ripemd160 } from 'hash.js';\nimport BN from 'bn.js';\nimport { ec } from 'elliptic';\nimport { __decorate } from 'tslib';\n\nfunction arrayEquals(a, b) {\n    const len = a.length;\n    if (len !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < len; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction arrayEquatableEquals(a, b) {\n    const len = a.length;\n    if (len !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < len; i++) {\n        if (!a[i].equals(b[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nconst hexLookup = {};\nfunction buildHexLookup() {\n    hexLookup.enc = new Array(0xff);\n    hexLookup.dec = {};\n    for (let i = 0; i <= 0xff; ++i) {\n        const b = i.toString(16).padStart(2, '0');\n        hexLookup.enc[i] = b;\n        hexLookup.dec[b] = i;\n    }\n}\nfunction arrayToHex(array) {\n    if (!hexLookup.enc) {\n        buildHexLookup();\n    }\n    const len = array.length;\n    const rv = new Array(len);\n    for (let i = 0; i < len; ++i) {\n        rv[i] = hexLookup.enc[array[i]];\n    }\n    return rv.join('');\n}\nfunction hexToArray(hex) {\n    if (!hexLookup.dec) {\n        buildHexLookup();\n    }\n    if (typeof hex !== 'string') {\n        throw new Error('Expected string containing hex digits');\n    }\n    if (hex.length % 2) {\n        throw new Error('Odd number of hex digits');\n    }\n    hex = hex.toLowerCase();\n    const len = hex.length / 2;\n    const result = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n        const b = hexLookup.dec[hex[i * 2] + hex[i * 2 + 1]];\n        if (b === undefined) {\n            throw new Error('Expected hex string');\n        }\n        result[i] = b;\n    }\n    return result;\n}\n/** Generate N random bytes, throws if a secure random source isn't available. */\nfunction secureRandom(length) {\n    return rand(length);\n}\n/** Used in isInstanceOf checks so we don't spam with warnings. */\nlet didWarn = false;\n/** Check if object in instance of class. */\nfunction isInstanceOf(object, someClass) {\n    if (object instanceof someClass) {\n        return true;\n    }\n    if (object == null || typeof object !== 'object') {\n        return false;\n    }\n    // not an actual instance but since bundlers can fail to dedupe stuff or\n    // multiple versions can be included we check for compatibility if possible\n    const className = someClass['__className'] || someClass['abiName'];\n    if (!className) {\n        return false;\n    }\n    let instanceClass = object.constructor;\n    let isAlienInstance = false;\n    while (instanceClass && !isAlienInstance) {\n        const instanceClassName = instanceClass['__className'] || instanceClass['abiName'];\n        if (!instanceClassName) {\n            break;\n        }\n        isAlienInstance = className == instanceClassName;\n        instanceClass = Object.getPrototypeOf(instanceClass);\n    }\n    if (isAlienInstance && !didWarn) {\n        // eslint-disable-next-line no-console\n        console.warn(`Detected alien instance of ${className}, this usually means more than one version of @greymass/eosio has been included in your bundle.`);\n        didWarn = true;\n    }\n    return isAlienInstance;\n}\n\nclass Bytes {\n    constructor(array = new Uint8Array()) {\n        this.array = array;\n    }\n    static from(value, encoding) {\n        if (isInstanceOf(value, this)) {\n            return value;\n        }\n        if (typeof value === 'string') {\n            return this.fromString(value, encoding);\n        }\n        if (isInstanceOf(value, Uint8Array)) {\n            return new this(value);\n        }\n        return new this(new Uint8Array(value));\n    }\n    static fromString(value, encoding = 'hex') {\n        if (encoding === 'hex') {\n            const array = hexToArray(value);\n            return new this(array);\n        }\n        else if (encoding == 'utf8') {\n            const encoder = new TextEncoder();\n            return new this(encoder.encode(value));\n        }\n        else {\n            throw new Error(`Unknown encoding: ${encoding}`);\n        }\n    }\n    static fromABI(decoder) {\n        const len = decoder.readVaruint32();\n        return new this(decoder.readArray(len));\n    }\n    static equal(a, b) {\n        return this.from(a).equals(this.from(b));\n    }\n    static random(length) {\n        return new this(secureRandom(length));\n    }\n    /** Return true if given value is a valid `BytesType`. */\n    static isBytes(value) {\n        if (isInstanceOf(value, Bytes) || isInstanceOf(value, Uint8Array)) {\n            return true;\n        }\n        if (Array.isArray(value) && value.every((v) => typeof v === 'number')) {\n            return true;\n        }\n        if (typeof value === 'string' && (/[\\da-f]/i.test(value) || value === '')) {\n            return true;\n        }\n        return false;\n    }\n    get hexString() {\n        return arrayToHex(this.array);\n    }\n    get utf8String() {\n        return new TextDecoder().decode(this.array);\n    }\n    appending(other) {\n        other = Bytes.from(other);\n        const newSize = this.array.byteLength + other.array.byteLength;\n        const buffer = new ArrayBuffer(newSize);\n        const array = new Uint8Array(buffer);\n        array.set(this.array);\n        array.set(other.array, this.array.byteLength);\n        return new Bytes(array);\n    }\n    droppingFirst(n = 1) {\n        return new Bytes(this.array.subarray(n));\n    }\n    copy() {\n        const buffer = new ArrayBuffer(this.array.byteLength);\n        const array = new Uint8Array(buffer);\n        array.set(this.array);\n        return new Bytes(array);\n    }\n    equals(other) {\n        return arrayEquals(this.array, Bytes.from(other).array);\n    }\n    toString(encoding = 'hex') {\n        if (encoding === 'hex') {\n            return this.hexString;\n        }\n        else if (encoding === 'utf8') {\n            return this.utf8String;\n        }\n        else {\n            throw new Error(`Unknown encoding: ${encoding}`);\n        }\n    }\n    toABI(encoder) {\n        encoder.writeVaruint32(this.array.byteLength);\n        encoder.writeArray(this.array);\n    }\n    toJSON() {\n        return this.hexString;\n    }\n}\nBytes.abiName = 'bytes';\n\nclass Checksum {\n    constructor(array) {\n        const byteSize = this.constructor.byteSize;\n        if (array.byteLength !== byteSize) {\n            throw new Error(`Checksum size mismatch, expected ${byteSize} bytes got ${array.byteLength}`);\n        }\n        this.array = array;\n    }\n    static from(value) {\n        if (isInstanceOf(value, this)) {\n            return value;\n        }\n        if (isInstanceOf(value, Checksum)) {\n            return new this(value.array);\n        }\n        return new this(Bytes.from(value).array);\n    }\n    static fromABI(decoder) {\n        return new this(decoder.readArray(this.byteSize));\n    }\n    equals(other) {\n        const self = this.constructor;\n        try {\n            return arrayEquals(this.array, self.from(other).array);\n        }\n        catch {\n            return false;\n        }\n    }\n    get hexString() {\n        return arrayToHex(this.array);\n    }\n    toABI(encoder) {\n        encoder.writeArray(this.array);\n    }\n    toString() {\n        return this.hexString;\n    }\n    toJSON() {\n        return this.toString();\n    }\n}\nChecksum.abiName = '__checksum';\nclass Checksum256 extends Checksum {\n    static from(value) {\n        return super.from(value);\n    }\n    static hash(data) {\n        const digest = new Uint8Array(sha256().update(Bytes.from(data).array).digest());\n        return new Checksum256(digest);\n    }\n}\nChecksum256.abiName = 'checksum256';\nChecksum256.byteSize = 32;\nclass Checksum512 extends Checksum {\n    static from(value) {\n        return super.from(value);\n    }\n    static hash(data) {\n        const digest = new Uint8Array(sha512().update(Bytes.from(data).array).digest());\n        return new Checksum512(digest);\n    }\n}\nChecksum512.abiName = 'checksum512';\nChecksum512.byteSize = 64;\nclass Checksum160 extends Checksum {\n    static from(value) {\n        return super.from(value);\n    }\n    static hash(data) {\n        const digest = new Uint8Array(ripemd160().update(Bytes.from(data).array).digest());\n        return new Checksum160(digest);\n    }\n}\nChecksum160.abiName = 'checksum160';\nChecksum160.byteSize = 20;\n\n/** Supported EOSIO curve types. */\nvar CurveType;\n(function (CurveType) {\n    CurveType[\"K1\"] = \"K1\";\n    CurveType[\"R1\"] = \"R1\";\n    CurveType[\"WA\"] = \"WA\";\n})(CurveType || (CurveType = {}));\n(function (CurveType) {\n    function indexFor(value) {\n        switch (value) {\n            case CurveType.K1:\n                return 0;\n            case CurveType.R1:\n                return 1;\n            case CurveType.WA:\n                return 2;\n            default:\n                throw new Error(`Unknown curve type: ${value}`);\n        }\n    }\n    CurveType.indexFor = indexFor;\n    function from(value) {\n        let index;\n        if (typeof value !== 'number') {\n            index = CurveType.indexFor(value);\n        }\n        else {\n            index = value;\n        }\n        switch (index) {\n            case 0:\n                return CurveType.K1;\n            case 1:\n                return CurveType.R1;\n            case 2:\n                return CurveType.WA;\n            default:\n                throw new Error('Unknown curve type');\n        }\n    }\n    CurveType.from = from;\n})(CurveType || (CurveType = {}));\n\n/** Return a ABI definition for given ABISerializableType. */\nfunction synthesizeABI(type) {\n    const structs = [];\n    const variants = [];\n    const aliases = [];\n    const seen = new Set();\n    const resolveAbiType = (t) => {\n        let typeName;\n        if (typeof t.type !== 'string') {\n            typeName = resolve(t.type);\n        }\n        else {\n            typeName = t.type;\n        }\n        if (t.array === true) {\n            typeName += '[]';\n        }\n        if (t.extension === true) {\n            typeName += '$';\n        }\n        if (t.optional === true) {\n            typeName += '?';\n        }\n        return typeName;\n    };\n    const resolve = (t) => {\n        if (!t.abiName) {\n            throw new Error('Encountered non-conforming type');\n        }\n        else if (t.abiName === '__struct') {\n            throw new Error('Misconfigured Struct subclass, did you forget @Struct.type?');\n        }\n        if (seen.has(t)) {\n            return t.abiName;\n        }\n        seen.add(t);\n        if (t.abiAlias) {\n            aliases.push({\n                new_type_name: t.abiName,\n                type: resolveAbiType(t.abiAlias),\n            });\n        }\n        else if (t.abiFields) {\n            const fields = t.abiFields.map((field) => {\n                return {\n                    name: field.name,\n                    type: resolveAbiType(field),\n                };\n            });\n            const struct = {\n                base: t.abiBase ? resolve(t.abiBase) : '',\n                name: t.abiName,\n                fields,\n            };\n            structs.push(struct);\n        }\n        else if (t.abiVariant) {\n            const variant = {\n                name: t.abiName,\n                types: t.abiVariant.map(resolveAbiType),\n            };\n            variants.push(variant);\n        }\n        return t.abiName;\n    };\n    const root = resolve(type);\n    return { abi: ABI.from({ structs, variants, types: aliases }), types: Array.from(seen), root };\n}\nfunction abiTypeString(type) {\n    let typeName = typeof type.type === 'string' ? type.type : type.type.abiName;\n    if (type.array === true) {\n        typeName += '[]';\n    }\n    if (type.extension === true) {\n        typeName += '$';\n    }\n    if (type.optional === true) {\n        typeName += '?';\n    }\n    return typeName;\n}\nfunction isTypeDescriptor(type) {\n    return (typeof type !== 'string' &&\n        type.abiName === undefined &&\n        type.type !== undefined);\n}\nfunction toTypeDescriptor(type) {\n    if (typeof type === 'string') {\n        return { type };\n    }\n    if (typeof type.abiName !== 'undefined') {\n        return { type: type };\n    }\n    return type;\n}\n\nconst StringType = {\n    abiName: 'string',\n    fromABI: (decoder) => {\n        return decoder.readString();\n    },\n    from: (string) => string,\n    toABI: (string, encoder) => {\n        encoder.writeString(string);\n    },\n};\nconst BoolType = {\n    abiName: 'bool',\n    fromABI: (decoder) => {\n        return decoder.readByte() === 1;\n    },\n    from: (value) => value,\n    toABI: (value, encoder) => {\n        encoder.writeByte(value === true ? 1 : 0);\n    },\n};\nfunction getBuiltins() {\n    return [\n        // types represented by JavaScript builtins\n        BoolType,\n        StringType,\n        // types represented by Classes\n        Asset,\n        Asset.Symbol,\n        Asset.SymbolCode,\n        BlockTimestamp,\n        Bytes,\n        Checksum160,\n        Checksum256,\n        Checksum512,\n        ExtendedAsset,\n        Float128,\n        Float32,\n        Float64,\n        Int128,\n        Int16,\n        Int32,\n        Int64,\n        Int8,\n        Name,\n        PublicKey,\n        Signature,\n        TimePoint,\n        TimePointSec,\n        UInt128,\n        UInt16,\n        UInt32,\n        UInt64,\n        UInt8,\n        VarInt,\n        VarUInt,\n    ];\n}\nfunction buildTypeLookup(additional = []) {\n    const rv = {};\n    const builtins = getBuiltins();\n    for (const type of builtins) {\n        rv[type.abiName] = type;\n    }\n    for (const type of additional) {\n        if (!type.abiName) {\n            throw new Error('Invalid type');\n        }\n        rv[type.abiName] = type;\n    }\n    return rv;\n}\nfunction getTypeName(object) {\n    if (object.constructor && object.constructor.abiName !== undefined) {\n        return object.constructor.abiName;\n    }\n    if (Array.isArray(object)) {\n        const types = object.map(getTypeName);\n        const type = types[0];\n        if (!type || !types.every((t) => t === type)) {\n            return;\n        }\n        return type + '[]';\n    }\n    switch (typeof object) {\n        case 'boolean':\n            return 'bool';\n        case 'string':\n            return 'string';\n    }\n}\nfunction getType(object, name = 'jsobj') {\n    var _a;\n    if (object.constructor && object.constructor.abiName !== undefined) {\n        return object.constructor;\n    }\n    if (Array.isArray(object)) {\n        // check for array of all ABISerializableType with same type name\n        const types = object.map((v) => {\n            return getType(v, name);\n        });\n        const type = types[0];\n        if (!type) {\n            return; // some type not known\n        }\n        if (!types.every((t) => t && t.abiName === type.abiName)) {\n            return; // not all types are the same\n        }\n        return type;\n    }\n    const objectType = typeof object;\n    if (objectType === 'object' && object !== null) {\n        const fields = Object.keys(object).map((key) => {\n            return { name: key, type: getType(object[key], name + '_nested') };\n        });\n        if (fields.find((field) => !field.type)) {\n            return; // encountered unknown type\n        }\n        return _a = class extends Struct {\n            },\n            _a.abiName = name,\n            _a.abiFields = fields,\n            _a;\n    }\n    switch (objectType) {\n        case 'boolean':\n            return BoolType;\n        case 'string':\n            return StringType;\n    }\n}\n\n/**\n * EOSIO ABI Decoder\n */\nclass DecodingError extends Error {\n    constructor(ctx, underlyingError) {\n        const path = ctx.codingPath\n            .map(({ field, type }) => {\n            if (typeof field === 'number') {\n                return field;\n            }\n            else {\n                return `${field}<${type.typeName}>`;\n            }\n        })\n            .join('.');\n        super(`Decoding error at ${path}: ${underlyingError.message}`);\n        this.stack = underlyingError.stack;\n        this.ctx = ctx;\n        this.underlyingError = underlyingError;\n    }\n}\nDecodingError.__className = 'DecodingError';\nfunction abiDecode(args) {\n    const descriptor = toTypeDescriptor(args.type);\n    const typeName = abiTypeString(descriptor);\n    const customTypes = args.customTypes || [];\n    let abi;\n    if (args.abi) {\n        abi = ABI.from(args.abi);\n    }\n    else {\n        try {\n            let type;\n            if (typeof descriptor.type === 'string') {\n                const lookup = buildTypeLookup(customTypes);\n                const rName = new ABI.ResolvedType(descriptor.type).name; // type name w/o suffixes\n                type = lookup[rName];\n                if (!type) {\n                    throw new Error(`Unknown type: ${descriptor.type}`);\n                }\n            }\n            else {\n                type = descriptor.type;\n            }\n            const synthesized = synthesizeABI(type);\n            abi = synthesized.abi;\n            customTypes.push(...synthesized.types);\n        }\n        catch (error) {\n            throw Error(`Unable to synthesize ABI for: ${typeName} (${error.message}). ` +\n                'To decode non-class types you need to pass the ABI definition manually.');\n        }\n    }\n    const resolved = abi.resolveType(typeName);\n    if (typeof descriptor.type !== 'string') {\n        customTypes.unshift(descriptor.type);\n    }\n    const ctx = {\n        types: buildTypeLookup(customTypes),\n        codingPath: [{ field: 'root', type: resolved }],\n    };\n    try {\n        if (args.data) {\n            let decoder;\n            if (isInstanceOf(args.data, ABIDecoder)) {\n                decoder = args.data;\n            }\n            else {\n                const bytes = Bytes.from(args.data);\n                decoder = new ABIDecoder(bytes.array);\n            }\n            if (args.metadata) {\n                decoder.metadata = args.metadata;\n            }\n            return decodeBinary(resolved, decoder, ctx);\n        }\n        else if (args.object !== undefined) {\n            return decodeObject(args.object, resolved, ctx);\n        }\n        else if (args.json) {\n            return decodeObject(JSON.parse(args.json), resolved, ctx);\n        }\n        else {\n            throw new Error('Nothing to decode, you must set one of data, json, object');\n        }\n    }\n    catch (error) {\n        throw new DecodingError(ctx, error);\n    }\n}\n/** Marker for objects when they have been resolved, i.e. their types `from` factory method will not need to resolve children. */\nconst Resolved = Symbol('Resolved');\nfunction decodeBinary(type, decoder, ctx) {\n    if (ctx.codingPath.length > 32) {\n        throw new Error('Maximum decoding depth exceeded');\n    }\n    if (type.isExtension) {\n        if (!decoder.canRead()) {\n            return undefined;\n        }\n    }\n    if (type.isOptional) {\n        if (decoder.readByte() === 0) {\n            return null;\n        }\n    }\n    if (type.isArray) {\n        const len = decoder.readVaruint32();\n        const rv = [];\n        for (let i = 0; i < len; i++) {\n            ctx.codingPath.push({ field: i, type });\n            rv.push(decodeInner());\n            ctx.codingPath.pop();\n        }\n        return rv;\n    }\n    else {\n        return decodeInner();\n    }\n    function decodeInner() {\n        const abiType = ctx.types[type.name];\n        if (abiType && abiType.fromABI) {\n            return abiType.fromABI(decoder);\n        }\n        else {\n            if (type.ref) {\n                // follow type alias\n                ctx.codingPath.push({ field: '', type: type.ref });\n                const rv = decodeBinary(type.ref, decoder, ctx);\n                ctx.codingPath.pop();\n                return rv;\n            }\n            else if (type.fields) {\n                const fields = type.allFields;\n                if (!fields) {\n                    throw new Error('Invalid struct fields');\n                }\n                const rv = {};\n                for (const field of fields) {\n                    ctx.codingPath.push({ field: field.name, type: field.type });\n                    rv[field.name] = decodeBinary(field.type, decoder, ctx);\n                    ctx.codingPath.pop();\n                }\n                if (abiType) {\n                    rv[Resolved] = true;\n                    return abiType.from(rv);\n                }\n                else {\n                    return rv;\n                }\n            }\n            else if (type.variant) {\n                const vIdx = decoder.readByte();\n                const vType = type.variant[vIdx];\n                if (!vType) {\n                    throw new Error(`Unknown variant idx: ${vIdx}`);\n                }\n                ctx.codingPath.push({ field: `v${vIdx}`, type: vType });\n                const rv = [vType.typeName, decodeBinary(vType, decoder, ctx)];\n                ctx.codingPath.pop();\n                if (abiType) {\n                    return abiType.from(rv);\n                }\n                else {\n                    return rv;\n                }\n            }\n            else if (abiType) {\n                throw new Error('Invalid type');\n            }\n            else {\n                throw new Error(type.name === 'any' ? \"Unable to decode 'any' type from binary\" : 'Unknown type');\n            }\n        }\n    }\n}\nfunction decodeObject(value, type, ctx) {\n    if (value === null || value === undefined) {\n        if (type.isOptional || type.isExtension) {\n            return null;\n        }\n        else {\n            throw new Error(`Unexpectedly encountered ${value} for non-optional`);\n        }\n    }\n    else if (type.isArray) {\n        if (!Array.isArray(value)) {\n            throw new Error('Expected array');\n        }\n        const rv = [];\n        const len = value.length;\n        for (let i = 0; i < len; i++) {\n            ctx.codingPath.push({ field: i, type });\n            rv.push(decodeInner(value[i]));\n            ctx.codingPath.pop();\n        }\n        return rv;\n    }\n    else {\n        return decodeInner(value);\n    }\n    function decodeInner(value) {\n        const abiType = ctx.types[type.name];\n        if (type.ref && !abiType) {\n            // follow type alias\n            return decodeObject(value, type.ref, ctx);\n        }\n        else if (type.fields) {\n            if (typeof value !== 'object') {\n                throw new Error('Expected object');\n            }\n            if (typeof abiType === 'function' && isInstanceOf(value, abiType)) {\n                return value;\n            }\n            const fields = type.allFields;\n            if (!fields) {\n                throw new Error('Invalid struct fields');\n            }\n            const struct = {};\n            for (const field of fields) {\n                ctx.codingPath.push({ field: field.name, type: field.type });\n                struct[field.name] = decodeObject(value[field.name], field.type, ctx);\n                ctx.codingPath.pop();\n            }\n            if (abiType) {\n                struct[Resolved] = true;\n                return abiType.from(struct);\n            }\n            else {\n                return struct;\n            }\n        }\n        else if (type.variant) {\n            let vName;\n            if (Array.isArray(value) && value.length === 2 && typeof value[0] === 'string') {\n                vName = value[0];\n                value = value[1];\n            }\n            else if (isInstanceOf(value, Variant)) {\n                vName = value.variantName;\n                value = value.value;\n            }\n            else {\n                vName = getTypeName(value);\n            }\n            const vIdx = type.variant.findIndex((t) => t.typeName === vName);\n            if (vIdx === -1) {\n                throw new Error(`Unknown variant type: ${vName}`);\n            }\n            const vType = type.variant[vIdx];\n            ctx.codingPath.push({ field: `v${vIdx}`, type: vType });\n            const rv = [vType.typeName, decodeObject(value, vType, ctx)];\n            ctx.codingPath.pop();\n            if (abiType) {\n                rv[Resolved] = true;\n                return abiType.from(rv);\n            }\n            else {\n                return rv;\n            }\n        }\n        else {\n            if (!abiType) {\n                // special case for `any` when decoding from object\n                if (type.name === 'any') {\n                    return value;\n                }\n                throw new Error('Unknown type');\n            }\n            return abiType.from(value);\n        }\n    }\n}\nclass ABIDecoder {\n    constructor(array) {\n        this.array = array;\n        this.pos = 0;\n        this.textDecoder = new TextDecoder('utf-8', { fatal: true });\n        /** User declared metadata, can be used to pass info to instances when decoding.  */\n        this.metadata = {};\n        this.data = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    }\n    canRead(bytes = 1) {\n        return !(this.pos + bytes > this.array.byteLength);\n    }\n    ensure(bytes) {\n        if (!this.canRead(bytes)) {\n            throw new Error('Read past end of buffer');\n        }\n    }\n    /** Read one byte. */\n    readByte() {\n        this.ensure(1);\n        return this.array[this.pos++];\n    }\n    /** Read integer as JavaScript number, up to 32 bits. */\n    readNum(byteWidth, isSigned) {\n        this.ensure(byteWidth);\n        const d = this.data, p = this.pos;\n        let rv;\n        switch (byteWidth * (isSigned ? -1 : 1)) {\n            case 1:\n                rv = d.getUint8(p);\n                break;\n            case 2:\n                rv = d.getUint16(p, true);\n                break;\n            case 4:\n                rv = d.getUint32(p, true);\n                break;\n            case -1:\n                rv = d.getInt8(p);\n                break;\n            case -2:\n                rv = d.getInt16(p, true);\n                break;\n            case -4:\n                rv = d.getInt32(p, true);\n                break;\n            default:\n                throw new Error('Invalid integer width');\n        }\n        this.pos += byteWidth;\n        return rv;\n    }\n    /** Read integer as a bn.js number. */\n    readBn(bytes, signed) {\n        this.ensure(bytes);\n        const bn = new BN(this.array.subarray(this.pos, this.pos + bytes), 'le');\n        this.pos += bytes;\n        if (signed) {\n            return bn.fromTwos(bytes * 8);\n        }\n        else {\n            return bn;\n        }\n    }\n    /** Read floating point as JavaScript number, 32 or 64 bits. */\n    readFloat(byteWidth) {\n        this.ensure(byteWidth);\n        let rv;\n        switch (byteWidth) {\n            case 4:\n                rv = this.data.getFloat32(this.pos, true);\n                break;\n            case 8:\n                rv = this.data.getFloat64(this.pos, true);\n                break;\n            default:\n                throw new Error('Invalid float size');\n        }\n        this.pos += byteWidth;\n        return rv;\n    }\n    readVaruint32() {\n        let v = 0;\n        let bit = 0;\n        for (;;) {\n            const b = this.readByte();\n            v |= (b & 0x7f) << bit;\n            bit += 7;\n            if (!(b & 0x80)) {\n                break;\n            }\n        }\n        return v >>> 0;\n    }\n    readVarint32() {\n        const v = this.readVaruint32();\n        if (v & 1) {\n            return (~v >> 1) | 2147483648;\n        }\n        else {\n            return v >>> 1;\n        }\n    }\n    readArray(length) {\n        this.ensure(length);\n        const rv = this.array.subarray(this.pos, this.pos + length);\n        this.pos += length;\n        return rv;\n    }\n    readString() {\n        const length = this.readVaruint32();\n        return this.textDecoder.decode(this.readArray(length));\n    }\n}\nABIDecoder.__className = 'ABIDecoder';\n\nclass Int {\n    constructor(value) {\n        if (!Number.isFinite(value)) {\n            throw new Error('Invalid number');\n        }\n        this.value = clamp(value, this.constructor['min'], this.constructor['max']);\n    }\n    static get max() {\n        return Math.pow(2, this.byteWidth * 8 - (this.isSigned ? 1 : 0)) - 1;\n    }\n    static get min() {\n        return this.isSigned ? -(this.max + 1) : 0;\n    }\n    static from(value) {\n        if (isInstanceOf(value, this)) {\n            return value;\n        }\n        if (typeof value === 'string') {\n            value = Number.parseInt(value, 10);\n        }\n        else if (isInstanceOf(value, BNInt)) {\n            value = value.value.toNumber();\n        }\n        else if (isInstanceOf(value, Int)) {\n            value = value.value;\n        }\n        else if (BN.isBN(value)) {\n            value = value.toNumber();\n        }\n        if (typeof value !== 'number') {\n            throw new Error('Invalid integer');\n        }\n        return new this(value);\n    }\n    static fromABI(decoder) {\n        return new this(decoder.readNum(this.byteWidth, this.isSigned));\n    }\n    static random() {\n        const bytes = secureRandom(this.byteWidth);\n        const decoder = new ABIDecoder(bytes);\n        return this.fromABI(decoder);\n    }\n    equals(other) {\n        const self = this.constructor;\n        return this.value === self.from(other).value;\n    }\n    toABI(encoder) {\n        const self = this.constructor;\n        encoder.writeNum(this.value, self.byteWidth, self.isSigned);\n    }\n    toNumber() {\n        return this.value;\n    }\n    toString() {\n        return this.value.toFixed(0);\n    }\n    toJSON() {\n        return this.value;\n    }\n}\nInt.abiName = '__int';\nclass BNInt {\n    constructor(value) {\n        const self = this.constructor;\n        if (value.byteLength() > self.byteWidth) {\n            throw new Error('Number too wide');\n        }\n        this.value = value;\n    }\n    static from(value) {\n        if (isInstanceOf(value, this)) {\n            return value;\n        }\n        if (isInstanceOf(value, BNInt)) {\n            return new this(value.value);\n        }\n        if (isInstanceOf(value, Uint8Array)) {\n            return new this(new BN(value, undefined, 'le'));\n        }\n        if (isInstanceOf(value, Int)) {\n            value = value.value;\n        }\n        return new this(new BN(value));\n    }\n    static fromABI(decoder) {\n        return new this(decoder.readBn(this.byteWidth, this.isSigned));\n    }\n    static random() {\n        const bytes = secureRandom(this.byteWidth);\n        const decoder = new ABIDecoder(bytes);\n        return this.fromABI(decoder);\n    }\n    equals(other, allowCast = false) {\n        const self = this.constructor;\n        if (!allowCast &&\n            typeof other.constructor.byteWidth === 'number' &&\n            other.constructor.byteWidth !== self.byteWidth) {\n            return false;\n        }\n        return this.value.eq(self.from(other).value);\n    }\n    toABI(encoder) {\n        const self = this.constructor;\n        encoder.writeBn(this.value, self.byteWidth, self.isSigned);\n    }\n    /**\n     * Return JavaScript number for this instance.\n     * @throws If the number is larger than 53-bits.\n     **/\n    toNumber() {\n        return this.value.toNumber();\n    }\n    toString() {\n        return this.value.toString();\n    }\n    toJSON() {\n        // match FCs behavior and return strings for anything above Uint32\n        if (this.value.bitLength() > 32) {\n            return this.value.toString();\n        }\n        else {\n            return this.value.toNumber();\n        }\n    }\n}\nBNInt.abiName = '__bn_int';\nclass Int8 extends Int {\n}\nInt8.abiName = 'int8';\nInt8.byteWidth = 1;\nInt8.isSigned = true;\nclass Int16 extends Int {\n}\nInt16.abiName = 'int16';\nInt16.byteWidth = 2;\nInt16.isSigned = true;\nclass Int32 extends Int {\n}\nInt32.abiName = 'int32';\nInt32.byteWidth = 4;\nInt32.isSigned = true;\nclass Int64 extends BNInt {\n}\nInt64.abiName = 'int64';\nInt64.byteWidth = 8;\nInt64.isSigned = true;\nclass Int128 extends BNInt {\n}\nInt128.abiName = 'int128';\nInt128.byteWidth = 16;\nInt128.isSigned = true;\nclass UInt8 extends Int {\n}\nUInt8.abiName = 'uint8';\nUInt8.byteWidth = 1;\nUInt8.isSigned = false;\nclass UInt16 extends Int {\n}\nUInt16.abiName = 'uint16';\nUInt16.byteWidth = 2;\nUInt16.isSigned = false;\nclass UInt32 extends Int {\n}\nUInt32.abiName = 'uint32';\nUInt32.byteWidth = 4;\nUInt32.isSigned = false;\nclass UInt64 extends BNInt {\n}\nUInt64.abiName = 'uint64';\nUInt64.byteWidth = 8;\nUInt64.isSigned = false;\nclass UInt128 extends BNInt {\n}\nUInt128.abiName = 'uint128';\nUInt128.byteWidth = 16;\nUInt128.isSigned = false;\nclass VarInt extends Int {\n    static fromABI(decoder) {\n        return new this(decoder.readVarint32());\n    }\n    toABI(encoder) {\n        encoder.writeVarint32(this.value);\n    }\n}\nVarInt.abiName = 'varint32';\nVarInt.byteWidth = 32;\nVarInt.isSigned = true;\nclass VarUInt extends Int {\n    static fromABI(decoder) {\n        return new this(decoder.readVaruint32());\n    }\n    toABI(encoder) {\n        encoder.writeVaruint32(this.value);\n    }\n}\nVarUInt.abiName = 'varuint32';\nVarUInt.byteWidth = 32;\nVarUInt.isSigned = false;\nfunction clamp(num, min, max) {\n    return Math.min(Math.max(num, min), max);\n}\n\n/**\n * EOSIO ABI Encoder\n */\nclass EncodingError extends Error {\n    constructor(ctx, underlyingError) {\n        const path = ctx.codingPath\n            .map(({ field, type }) => {\n            if (typeof field === 'number') {\n                return field;\n            }\n            else {\n                return `${field}<${type.typeName}>`;\n            }\n        })\n            .join('.');\n        super(`Encoding error at ${path}: ${underlyingError.message}`);\n        this.stack = underlyingError.stack;\n        this.ctx = ctx;\n        this.underlyingError = underlyingError;\n    }\n}\nEncodingError.__className = 'EncodingError';\nfunction abiEncode(args) {\n    let type;\n    let typeName;\n    if (typeof args.type === 'string') {\n        typeName = args.type;\n    }\n    else if (args.type && isTypeDescriptor(args.type)) {\n        if (typeof args.type.type !== 'string') {\n            type = args.type.type;\n        }\n        typeName = abiTypeString(args.type);\n    }\n    else if (args.type && args.type.abiName !== undefined) {\n        type = args.type;\n        typeName = args.type.abiName;\n    }\n    else {\n        type = getType(args.object);\n        if (type) {\n            typeName = type.abiName;\n            if (Array.isArray(args.object)) {\n                typeName += '[]';\n            }\n        }\n    }\n    const customTypes = args.customTypes || [];\n    if (type) {\n        customTypes.unshift(type);\n    }\n    else if (typeName) {\n        const rootName = new ABI.ResolvedType(typeName).name;\n        type = customTypes.find((t) => t.abiName === rootName);\n    }\n    let rootType;\n    if (args.abi && typeName) {\n        rootType = ABI.from(args.abi).resolveType(typeName);\n    }\n    else if (type) {\n        const synthesized = synthesizeABI(type);\n        rootType = synthesized.abi.resolveType(typeName || type.abiName);\n        customTypes.push(...synthesized.types);\n    }\n    else if (typeName) {\n        rootType = new ABI.ResolvedType(typeName);\n    }\n    else {\n        throw new Error('Unable to determine the type of the object to be encoded. ' +\n            'To encode custom ABI types you must pass the type argument.');\n    }\n    const types = buildTypeLookup(customTypes);\n    const encoder = args.encoder || new ABIEncoder();\n    if (args.metadata) {\n        encoder.metadata = args.metadata;\n    }\n    const ctx = {\n        types,\n        encoder,\n        codingPath: [{ field: 'root', type: rootType }],\n    };\n    try {\n        encodeAny(args.object, rootType, ctx);\n    }\n    catch (error) {\n        throw new EncodingError(ctx, error);\n    }\n    return Bytes.from(encoder.getData());\n}\nfunction encodeAny(value, type, ctx) {\n    const valueExists = value !== undefined && value !== null;\n    if (type.isOptional) {\n        ctx.encoder.writeByte(valueExists ? 1 : 0);\n        if (!valueExists) {\n            return;\n        }\n    }\n    if (type.isArray) {\n        if (!Array.isArray(value)) {\n            throw new Error(`Expected array for: ${type.typeName}`);\n        }\n        const len = value.length;\n        ctx.encoder.writeVaruint32(len);\n        for (let i = 0; i < len; i++) {\n            ctx.codingPath.push({ field: i, type });\n            encodeInner(value[i]);\n            ctx.codingPath.pop();\n        }\n    }\n    else {\n        encodeInner(value);\n    }\n    function encodeInner(value) {\n        const abiType = ctx.types[type.name];\n        if (type.ref && !abiType) {\n            // type is alias, follow it\n            encodeAny(value, type.ref, ctx);\n            return;\n        }\n        if (!valueExists) {\n            if (type.isExtension) {\n                return;\n            }\n            throw new Error(`Found ${value} for non-optional type: ${type.typeName}`);\n        }\n        if (abiType && abiType.toABI) {\n            // type explicitly handles encoding\n            abiType.toABI(value, ctx.encoder);\n        }\n        else if (typeof value.toABI === 'function' && value.constructor.abiName === type.name) {\n            // instance handles encoding\n            value.toABI(ctx.encoder);\n        }\n        else {\n            // encode according to abi def if possible\n            if (type.fields) {\n                if (typeof value !== 'object') {\n                    throw new Error(`Expected object for: ${type.name}`);\n                }\n                const fields = type.allFields;\n                if (!fields) {\n                    throw new Error('Invalid struct fields');\n                }\n                for (const field of fields) {\n                    ctx.codingPath.push({ field: field.name, type: field.type });\n                    encodeAny(value[field.name], field.type, ctx);\n                    ctx.codingPath.pop();\n                }\n            }\n            else if (type.variant) {\n                let vName;\n                if (Array.isArray(value) && value.length === 2 && typeof value[0] === 'string') {\n                    vName = value[0];\n                    value = value[1];\n                }\n                else if (isInstanceOf(value, Variant)) {\n                    vName = value.variantName;\n                    value = value.value;\n                }\n                else {\n                    vName = getTypeName(value);\n                }\n                const vIdx = type.variant.findIndex((t) => t.typeName === vName);\n                if (vIdx === -1) {\n                    const types = type.variant.map((t) => `'${t.typeName}'`).join(', ');\n                    throw new Error(`Unknown variant type '${vName}', expected one of ${types}`);\n                }\n                const vType = type.variant[vIdx];\n                ctx.encoder.writeVaruint32(vIdx);\n                ctx.codingPath.push({ field: `v${vIdx}`, type: vType });\n                encodeAny(value, vType, ctx);\n                ctx.codingPath.pop();\n            }\n            else {\n                if (!abiType) {\n                    throw new Error(type.name === 'any' ? 'Unable to encode any type to binary' : 'Unknown type');\n                }\n                const instance = abiType.from(value);\n                if (!instance.toABI) {\n                    throw new Error(`Invalid type ${type.name}, no encoding methods implemented`);\n                }\n                instance.toABI(ctx.encoder);\n            }\n        }\n    }\n}\nclass ABIEncoder {\n    constructor(pageSize = 1024) {\n        this.pageSize = pageSize;\n        this.pos = 0;\n        this.textEncoder = new TextEncoder();\n        /** User declared metadata, can be used to pass info to instances when encoding.  */\n        this.metadata = {};\n        const buffer = new ArrayBuffer(pageSize);\n        this.data = new DataView(buffer);\n        this.array = new Uint8Array(buffer);\n    }\n    ensure(bytes) {\n        if (this.data.byteLength >= this.pos + bytes) {\n            return;\n        }\n        const pages = Math.ceil(bytes / this.pageSize);\n        const newSize = this.data.byteLength + this.pageSize * pages;\n        const buffer = new ArrayBuffer(newSize);\n        const data = new DataView(buffer);\n        const array = new Uint8Array(buffer);\n        array.set(this.array);\n        this.data = data;\n        this.array = array;\n    }\n    /** Write a single byte. */\n    writeByte(byte) {\n        this.ensure(1);\n        this.array[this.pos++] = byte;\n    }\n    /** Write an array of bytes. */\n    writeArray(bytes) {\n        const size = bytes.length;\n        this.ensure(size);\n        this.array.set(bytes, this.pos);\n        this.pos += size;\n    }\n    /** Write a JavaScript number as integer, up to 32 bits. */\n    writeNum(value, byteWidth, isSigned) {\n        this.ensure(byteWidth);\n        const d = this.data, p = this.pos;\n        switch (byteWidth * (isSigned ? -1 : 1)) {\n            case 1:\n                d.setUint8(p, value);\n                break;\n            case 2:\n                d.setUint16(p, value, true);\n                break;\n            case 4:\n                d.setUint32(p, value, true);\n                break;\n            case -1:\n                d.setInt8(p, value);\n                break;\n            case -2:\n                d.setInt16(p, value, true);\n                break;\n            case -4:\n                d.setInt32(p, value, true);\n                break;\n            default:\n                throw new Error('Invalid integer width');\n        }\n        this.pos += byteWidth;\n    }\n    /** Write a bn.js number. */\n    writeBn(value, byteWidth, isSigned) {\n        if (isSigned) {\n            value = value.toTwos(byteWidth * 8);\n        }\n        this.writeArray(value.toArrayLike(Uint8Array, 'le', byteWidth));\n    }\n    writeFloat(value, byteWidth) {\n        this.ensure(byteWidth);\n        switch (byteWidth) {\n            case 4:\n                this.data.setFloat32(this.pos, value, true);\n                break;\n            case 8:\n                this.data.setFloat64(this.pos, value, true);\n                break;\n            default:\n                throw new Error('Invalid float size');\n        }\n        this.pos += byteWidth;\n    }\n    writeVaruint32(v) {\n        this.ensure(4);\n        for (;;) {\n            if (v >>> 7) {\n                this.array[this.pos++] = 0x80 | (v & 0x7f);\n                v = v >>> 7;\n            }\n            else {\n                this.array[this.pos++] = v;\n                break;\n            }\n        }\n    }\n    writeVarint32(v) {\n        this.writeVaruint32((v << 1) ^ (v >> 31));\n    }\n    writeString(v) {\n        const data = this.textEncoder.encode(v);\n        this.writeVaruint32(data.byteLength);\n        this.writeArray(data);\n    }\n    getData() {\n        return new Uint8Array(this.array.buffer, this.array.byteOffset, this.pos);\n    }\n}\nABIEncoder.__className = 'ABIEncoder';\n\nclass Struct {\n    /** @internal */\n    constructor(object) {\n        const self = this.constructor;\n        for (const field of self.structFields) {\n            this[field.name] = object[field.name];\n        }\n    }\n    static from(value) {\n        if (value[Resolved] === true) {\n            // objects already resolved\n            return new this(value);\n        }\n        if (isInstanceOf(value, this)) {\n            return value;\n        }\n        const object = {};\n        for (const field of this.structFields) {\n            const v = value[field.name] === undefined ? field.default : value[field.name];\n            if (v === undefined && !(field.optional === true || field.name.includes('?'))) {\n                throw new Error(`Missing value for non optional field: ${field.name}`);\n            }\n            object[field.name] = v;\n        }\n        return abiDecode({ object, type: this });\n    }\n    static get structFields() {\n        const rv = [];\n        const walk = (t) => {\n            if (t.abiBase) {\n                walk(t.abiBase);\n            }\n            for (const field of t.abiFields || []) {\n                rv.push(field);\n            }\n        };\n        walk(this);\n        return rv;\n    }\n    /**\n     * Return true if this struct equals the other.\n     *\n     * Note: This compares the ABI encoded bytes of both structs, subclasses\n     *       should implement their own fast equality check when possible.\n     */\n    equals(other) {\n        const self = this.constructor;\n        if (other.constructor &&\n            typeof other.constructor.abiName === 'string' &&\n            other.constructor.abiName !== self.abiName) {\n            return false;\n        }\n        return abiEncode({ object: this }).equals(abiEncode({ object: self.from(other) }));\n    }\n    /** @internal */\n    toJSON() {\n        const self = this.constructor;\n        const rv = {};\n        for (const field of self.structFields) {\n            rv[field.name] = this[field.name];\n        }\n        return rv;\n    }\n}\nStruct.abiName = '__struct';\n(function (Struct) {\n    const FieldsOwner = Symbol('FieldsOwner');\n    function type(name) {\n        return function (struct) {\n            struct.abiName = name;\n            return struct;\n        };\n    }\n    Struct.type = type;\n    function field(type, options) {\n        if (!options)\n            options = {};\n        return (target, name) => {\n            const ctor = target.constructor;\n            if (!ctor.abiFields) {\n                ctor.abiFields = [];\n                ctor.abiFields[FieldsOwner] = ctor;\n            }\n            else if (ctor.abiFields[FieldsOwner] !== ctor) {\n                // if the target class isn't the owner we set the base and start new fields\n                ctor.abiBase = ctor.abiFields[FieldsOwner];\n                ctor.abiFields = [];\n                ctor.abiFields[FieldsOwner] = ctor;\n            }\n            ctor.abiFields.push({ ...options, name, type });\n        };\n    }\n    Struct.field = field;\n})(Struct || (Struct = {}));\n\nfunction TypeAlias(name) {\n    return function (typeAlias) {\n        typeAlias.abiAlias = { type: Object.getPrototypeOf(typeAlias.prototype).constructor };\n        typeAlias.abiName = name;\n        return typeAlias;\n    };\n}\n\nclass Variant {\n    /** @internal */\n    constructor(variant) {\n        const abiVariant = this.constructor.abiVariant;\n        this.value = variant[1];\n        const variantIdx = abiVariant.map(abiTypeString).findIndex((t) => t === variant[0]);\n        if (0 > variantIdx || abiVariant.length <= variantIdx) {\n            throw new Error(`Unknown variant ${variant[0]}`);\n        }\n        this.variantIdx = variantIdx;\n    }\n    static from(object) {\n        if (object[Resolved]) {\n            return new this(object);\n        }\n        if (isInstanceOf(object, this)) {\n            return object;\n        }\n        return abiDecode({ object, type: this });\n    }\n    /**\n     * Return true if this variant equals the other.\n     *\n     * Note: This compares the ABI encoded bytes of both variants, subclasses\n     *       should implement their own fast equality check when possible.\n     */\n    equals(other) {\n        const self = this.constructor;\n        const otherVariant = self.from(other);\n        if (this.variantIdx !== otherVariant.variantIdx) {\n            return false;\n        }\n        return abiEncode({ object: this }).equals(abiEncode({ object: otherVariant }));\n    }\n    get variantName() {\n        const variant = this.constructor.abiVariant[this.variantIdx];\n        return abiTypeString(variant);\n    }\n    /** @internal */\n    toJSON() {\n        return [this.variantName, this.value];\n    }\n}\nVariant.abiName = '__variant';\nVariant.abiVariant = [];\n(function (Variant) {\n    function type(name, types) {\n        return function (variant) {\n            variant.abiName = name;\n            variant.abiVariant = types.map(toTypeDescriptor);\n            return variant;\n        };\n    }\n    Variant.type = type;\n})(Variant || (Variant = {}));\n\nclass Float {\n    constructor(value) {\n        if (!Number.isFinite(value)) {\n            throw new Error('Invalid number');\n        }\n        this.value = value;\n    }\n    static from(value) {\n        if (isInstanceOf(value, this)) {\n            return value;\n        }\n        if (typeof value === 'string') {\n            value = Number.parseFloat(value);\n        }\n        else if (isInstanceOf(value, Float)) {\n            value = value.value;\n        }\n        return new this(value);\n    }\n    static fromABI(decoder) {\n        return new this(decoder.readFloat(this.byteWidth));\n    }\n    static random() {\n        const bytes = secureRandom(this.byteWidth);\n        const decoder = new ABIDecoder(bytes);\n        return this.fromABI(decoder);\n    }\n    equals(other) {\n        const self = this.constructor;\n        return this.value === self.from(other).value;\n    }\n    toABI(encoder) {\n        const self = this.constructor;\n        encoder.writeFloat(this.value, self.byteWidth);\n    }\n    toString() {\n        return this.value.toString();\n    }\n    toJSON() {\n        return this.toString();\n    }\n}\nFloat.abiName = '__float';\nclass Float32 extends Float {\n    toString() {\n        return this.value.toFixed(7);\n    }\n}\nFloat32.abiName = 'float32';\nFloat32.byteWidth = 4;\nclass Float64 extends Float {\n}\nFloat64.abiName = 'float64';\nFloat64.byteWidth = 8;\nclass Float128 {\n    constructor(data) {\n        if (data.array.length !== 16) {\n            throw new Error('Invalid float128');\n        }\n        this.data = data;\n    }\n    static from(value) {\n        if (isInstanceOf(value, this)) {\n            return value;\n        }\n        if (typeof value === 'string' && value.startsWith('0x')) {\n            value = value.slice(2);\n        }\n        return new this(Bytes.from(value));\n    }\n    static fromABI(decoder) {\n        return new this(new Bytes(decoder.readArray(this.byteWidth)));\n    }\n    static random() {\n        const bytes = secureRandom(16);\n        const decoder = new ABIDecoder(bytes);\n        return this.fromABI(decoder);\n    }\n    equals(other) {\n        const self = this.constructor;\n        return this.data.equals(self.from(other).data);\n    }\n    toABI(encoder) {\n        encoder.writeArray(this.data.array);\n    }\n    toString() {\n        // float128 uses 0x prefixed hex strings as opposed to everywhere else in where there is no prefix ¯\\_(ツ)_/¯\n        return '0x' + this.data.hexString;\n    }\n    toJSON() {\n        return this.toString();\n    }\n}\nFloat128.abiName = 'float128';\nFloat128.byteWidth = 16;\n\n/** EOSIO Name */\nclass Name {\n    constructor(rawValue) {\n        this.rawValue = rawValue;\n    }\n    /** Create a new Name instance from any of its representing types. */\n    static from(value) {\n        if (isInstanceOf(value, Name)) {\n            return value;\n        }\n        else if (typeof value === 'string') {\n            return new Name(stringToName(value));\n        }\n        else if (isInstanceOf(value, UInt64)) {\n            return new Name(value);\n        }\n        else {\n            throw new Error('Invalid name');\n        }\n    }\n    static fromABI(decoder) {\n        return new Name(UInt64.fromABI(decoder));\n    }\n    /** Return true if this name is equal to passed name. */\n    equals(other) {\n        return this.rawValue.equals(Name.from(other).rawValue);\n    }\n    /** Return string representation of this name. */\n    toString() {\n        return nameToString(this.rawValue);\n    }\n    toABI(encoder) {\n        this.rawValue.toABI(encoder);\n    }\n    /** @internal */\n    toJSON() {\n        return this.toString();\n    }\n}\nName.abiName = 'name';\n/** Regex pattern matching a EOSIO name, case-sensitive. */\nName.pattern = /^[a-z1-5.]{0,13}$/;\nfunction stringToName(s) {\n    function charToSymbol(c) {\n        if (c >= 'a'.charCodeAt(0) && c <= 'z'.charCodeAt(0)) {\n            return c - 'a'.charCodeAt(0) + 6;\n        }\n        if (c >= '1'.charCodeAt(0) && c <= '5'.charCodeAt(0)) {\n            return c - '1'.charCodeAt(0) + 1;\n        }\n        return 0;\n    }\n    const a = new Uint8Array(8);\n    let bit = 63;\n    for (let i = 0; i < s.length; ++i) {\n        let c = charToSymbol(s.charCodeAt(i));\n        if (bit < 5) {\n            c = c << 1;\n        }\n        for (let j = 4; j >= 0; --j) {\n            if (bit >= 0) {\n                a[Math.floor(bit / 8)] |= ((c >> j) & 1) << bit % 8;\n                --bit;\n            }\n        }\n    }\n    return UInt64.from(a);\n}\nfunction nameToString(n) {\n    const a = n.value.toArray('le', 8);\n    let result = '';\n    for (let bit = 63; bit >= 0;) {\n        let c = 0;\n        for (let i = 0; i < 5; ++i) {\n            if (bit >= 0) {\n                c = (c << 1) | ((a[Math.floor(bit / 8)] >> bit % 8) & 1);\n                --bit;\n            }\n        }\n        if (c >= 6) {\n            result += String.fromCharCode(c + 'a'.charCodeAt(0) - 6);\n        }\n        else if (c >= 1) {\n            result += String.fromCharCode(c + '1'.charCodeAt(0) - 1);\n        }\n        else {\n            result += '.';\n        }\n    }\n    while (result.endsWith('.')) {\n        result = result.substr(0, result.length - 1);\n    }\n    return result;\n}\n\nclass TimePointBase {\n    constructor(value) {\n        this.value = value;\n    }\n    static from(value) {\n        if (isInstanceOf(value, this)) {\n            return value;\n        }\n        if (isInstanceOf(value, TimePointBase)) {\n            // converting between types\n            return this.fromMilliseconds(value.toMilliseconds());\n        }\n        if (isInstanceOf(value, Date)) {\n            return this.fromDate(value);\n        }\n        if (typeof value === 'string') {\n            return this.fromString(value);\n        }\n        return this.fromInteger(value);\n    }\n    static fromString(string) {\n        const value = Date.parse(string + 'Z');\n        if (!Number.isFinite(value)) {\n            throw new Error('Invalid date string');\n        }\n        return this.fromMilliseconds(value);\n    }\n    static fromDate(date) {\n        return this.fromMilliseconds(date.getTime());\n    }\n    toABI(encoder) {\n        const self = this;\n        self.value.toABI(encoder);\n    }\n    equals(other) {\n        const self = this.constructor;\n        return this.toMilliseconds() === self.from(other).toMilliseconds();\n    }\n    toMilliseconds() {\n        throw new Error('Not implemented');\n    }\n    toDate() {\n        return new Date(this.toMilliseconds());\n    }\n    toJSON() {\n        return this.toString();\n    }\n}\nTimePointBase.abiName = '__time_point_base';\n/** Timestamp with microsecond accuracy. */\nclass TimePoint extends TimePointBase {\n    static fromMilliseconds(ms) {\n        return new TimePoint(Int64.from(Math.round(ms * 1000)));\n    }\n    static fromInteger(value) {\n        return new TimePoint(Int64.from(value));\n    }\n    static fromABI(decoder) {\n        return new this(Int64.fromABI(decoder));\n    }\n    toString() {\n        return this.toDate().toISOString().slice(0, -1);\n    }\n    toMilliseconds() {\n        return this.value.value.divRound(new BN(1000)).toNumber();\n    }\n}\nTimePoint.abiName = 'time_point';\n/** Timestamp with second accuracy. */\nclass TimePointSec extends TimePointBase {\n    static fromMilliseconds(ms) {\n        return new TimePointSec(UInt32.from(Math.round(ms / 1000)));\n    }\n    static fromInteger(value) {\n        return new TimePointSec(UInt32.from(value));\n    }\n    static fromABI(decoder) {\n        return new this(UInt32.fromABI(decoder));\n    }\n    toString() {\n        return this.toDate().toISOString().slice(0, -5);\n    }\n    toMilliseconds() {\n        return this.value.value * 1000;\n    }\n}\nTimePointSec.abiName = 'time_point_sec';\nclass BlockTimestamp extends TimePointBase {\n    static fromMilliseconds(ms) {\n        return new TimePointSec(UInt32.from(Math.round((ms - 946684800000) / 500)));\n    }\n    static fromInteger(value) {\n        return new TimePointSec(UInt32.from(value));\n    }\n    static fromABI(decoder) {\n        return new this(UInt32.fromABI(decoder));\n    }\n    toString() {\n        return this.toDate().toISOString().slice(0, -1);\n    }\n    toMilliseconds() {\n        return this.value.value * 500 + 946684800000;\n    }\n}\nBlockTimestamp.abiName = 'block_timestamp_type';\n\nclass ABI {\n    constructor(args) {\n        this.version = args.version || ABI.version;\n        this.types = args.types || [];\n        this.variants = args.variants || [];\n        this.structs = args.structs || [];\n        this.actions = args.actions || [];\n        this.tables = args.tables || [];\n        this.ricardian_clauses = args.ricardian_clauses || [];\n    }\n    static from(value) {\n        if (isInstanceOf(value, ABI)) {\n            return value;\n        }\n        if (typeof value === 'string') {\n            return new ABI(JSON.parse(value));\n        }\n        return new ABI(value);\n    }\n    resolveType(name) {\n        const types = {};\n        return this.resolve({ name, types }, { id: 0 });\n    }\n    resolveAll() {\n        const types = {};\n        const ctx = { id: 0 };\n        return {\n            types: this.types.map((t) => this.resolve({ name: t.new_type_name, types }, ctx)),\n            variants: this.variants.map((t) => this.resolve({ name: t.name, types }, ctx)),\n            structs: this.structs.map((t) => this.resolve({ name: t.name, types }, ctx)),\n        };\n    }\n    resolve({ name, types }, ctx) {\n        const existing = types[name];\n        if (existing) {\n            return existing;\n        }\n        const type = new ABI.ResolvedType(name, ++ctx.id);\n        types[type.typeName] = type;\n        const alias = this.types.find((typeDef) => typeDef.new_type_name == type.name);\n        if (alias) {\n            type.ref = this.resolve({ name: alias.type, types }, ctx);\n            return type;\n        }\n        const struct = this.getStruct(type.name);\n        if (struct) {\n            if (struct.base) {\n                type.base = this.resolve({ name: struct.base, types }, ctx);\n            }\n            type.fields = struct.fields.map((field) => {\n                return {\n                    name: field.name,\n                    type: this.resolve({ name: field.type, types }, ctx),\n                };\n            });\n            return type;\n        }\n        const variant = this.getVariant(type.name);\n        if (variant) {\n            type.variant = variant.types.map((name) => this.resolve({ name, types }, ctx));\n            return type;\n        }\n        // builtin or unknown type\n        return type;\n    }\n    getStruct(name) {\n        return this.structs.find((struct) => struct.name == name);\n    }\n    getVariant(name) {\n        return this.variants.find((variant) => variant.name == name);\n    }\n    /** Return arguments type of an action in this ABI. */\n    getActionType(actionName) {\n        const name = Name.from(actionName).toString();\n        const action = this.actions.find((a) => a.name.toString() === name);\n        if (action) {\n            return action.type;\n        }\n    }\n}\nABI.__className = 'ABI';\nABI.version = 'eosio::abi/1.1';\n(function (ABI) {\n    class ResolvedType {\n        constructor(fullName, id = 0) {\n            let name = fullName;\n            if (name.endsWith('$')) {\n                name = name.slice(0, -1);\n                this.isExtension = true;\n            }\n            else {\n                this.isExtension = false;\n            }\n            if (name.endsWith('?')) {\n                name = name.slice(0, -1);\n                this.isOptional = true;\n            }\n            else {\n                this.isOptional = false;\n            }\n            if (name.endsWith('[]')) {\n                name = name.slice(0, -2);\n                this.isArray = true;\n            }\n            else {\n                this.isArray = false;\n            }\n            this.id = id;\n            this.name = name;\n        }\n        /**\n         * Type name including suffixes: [] array, ? optional, $ binary ext\n         */\n        get typeName() {\n            let rv = this.name;\n            if (this.isArray) {\n                rv += '[]';\n            }\n            if (this.isOptional) {\n                rv += '?';\n            }\n            if (this.isExtension) {\n                rv += '$';\n            }\n            return rv;\n        }\n        /** All fields including base struct(s), undefined if not a struct type. */\n        get allFields() {\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            let current = this;\n            const rv = [];\n            const seen = new Set();\n            do {\n                if (!current.fields) {\n                    return; // invalid struct\n                }\n                if (seen.has(current.name)) {\n                    return; // circular ref\n                }\n                for (let i = current.fields.length - 1; i >= 0; i--) {\n                    rv.unshift(current.fields[i]);\n                }\n                seen.add(current.name);\n                current = current.base;\n            } while (current !== undefined);\n            return rv;\n        }\n    }\n    ABI.ResolvedType = ResolvedType;\n})(ABI || (ABI = {}));\n\nclass Asset {\n    constructor(units, symbol) {\n        this.units = units;\n        this.symbol = symbol;\n    }\n    static from(value, symbol) {\n        if (isInstanceOf(value, Asset)) {\n            return value;\n        }\n        switch (typeof value) {\n            case 'number':\n                if (!symbol) {\n                    throw new Error('Symbol is required when creating Asset from number');\n                }\n                return this.fromFloat(value, symbol);\n            case 'string':\n                return this.fromString(value);\n            default:\n                throw new Error('Invalid asset');\n        }\n    }\n    static fromString(value) {\n        const parts = (typeof value === 'string' ? value : '').split(' ');\n        if (parts.length !== 2) {\n            throw new Error('Invalid asset string');\n        }\n        const amount = parts[0].replace('.', '');\n        const precision = (parts[0].split('.')[1] || '').length;\n        const symbol = Asset.Symbol.fromParts(parts[1], precision);\n        return new Asset(Int64.from(amount), symbol);\n    }\n    static fromFloat(value, symbol) {\n        const s = Asset.Symbol.from(symbol);\n        return new Asset(s.convertFloat(value), s);\n    }\n    static fromUnits(value, symbol) {\n        return new Asset(Int64.from(value), Asset.Symbol.from(symbol));\n    }\n    static fromABI(decoder) {\n        const units = Int64.fromABI(decoder);\n        const symbol = Asset.Symbol.fromABI(decoder);\n        return new Asset(units, symbol);\n    }\n    equals(other) {\n        const { symbol, units } = Asset.from(other);\n        return this.symbol.value.equals(symbol.value) && this.units.equals(units);\n    }\n    get value() {\n        return this.symbol.convertUnits(this.units);\n    }\n    set value(newValue) {\n        this.units = this.symbol.convertFloat(newValue);\n    }\n    toABI(encoder) {\n        this.units.toABI(encoder);\n        this.symbol.toABI(encoder);\n    }\n    toString() {\n        const digits = this.units.toString().split('');\n        let negative = false;\n        if (digits[0] === '-') {\n            negative = true;\n            digits.shift();\n        }\n        const p = this.symbol.precision;\n        while (digits.length <= p) {\n            digits.unshift('0');\n        }\n        if (p > 0) {\n            digits.splice(digits.length - p, 0, '.');\n        }\n        let rv = digits.join('');\n        if (negative) {\n            rv = '-' + rv;\n        }\n        return rv + ' ' + this.symbol.name;\n    }\n    toJSON() {\n        return this.toString();\n    }\n}\nAsset.abiName = 'asset';\n(function (Asset) {\n    class Symbol {\n        constructor(value) {\n            if (toSymbolPrecision(value) > Symbol.maxPrecision) {\n                throw new Error('Invalid asset symbol, precision too large');\n            }\n            if (!Symbol.symbolNamePattern.test(toSymbolName(value))) {\n                throw new Error('Invalid asset symbol, name must be uppercase A-Z');\n            }\n            this.value = value;\n        }\n        static from(value) {\n            if (isInstanceOf(value, Symbol)) {\n                return value;\n            }\n            if (isInstanceOf(value, UInt64)) {\n                return new Symbol(value);\n            }\n            const parts = value.split(',');\n            if (parts.length !== 2) {\n                throw new Error('Invalid symbol string');\n            }\n            const precision = Number.parseInt(parts[0]);\n            return Symbol.fromParts(parts[1], precision);\n        }\n        static fromParts(name, precision) {\n            return new Symbol(toRawSymbol(name, precision));\n        }\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        static fromABI(decoder) {\n            return new Symbol(UInt64.fromABI(decoder));\n        }\n        equals(other) {\n            return this.value.equals(Symbol.from(other).value);\n        }\n        get name() {\n            return toSymbolName(this.value);\n        }\n        get precision() {\n            return toSymbolPrecision(this.value);\n        }\n        get code() {\n            return new SymbolCode(UInt64.from(this.value.value.clone().iushrn(8)));\n        }\n        toABI(encoder) {\n            this.value.toABI(encoder);\n        }\n        /**\n         * Convert units to floating point number according to symbol precision.\n         * @throws If the given units can't be represented in 53 bits.\n         **/\n        convertUnits(units) {\n            return units.value.toNumber() / Math.pow(10, this.precision);\n        }\n        /**\n         * Convert floating point to units according to symbol precision.\n         * Note that the value will be rounded to closest precision.\n         **/\n        convertFloat(float) {\n            return Int64.from(float.toFixed(this.precision).replace('.', ''));\n        }\n        toString() {\n            return `${this.precision},${this.name}`;\n        }\n        toJSON() {\n            return this.toString();\n        }\n    }\n    Symbol.abiName = 'symbol';\n    Symbol.symbolNamePattern = /^[A-Z]{1,7}$/;\n    Symbol.maxPrecision = 18;\n    Asset.Symbol = Symbol;\n    class SymbolCode {\n        constructor(value) {\n            this.value = value;\n        }\n        static from(value) {\n            if (isInstanceOf(value, SymbolCode)) {\n                return value;\n            }\n            if (typeof value === 'string') {\n                value = UInt64.from(new BN(toRawSymbolCode(value), 'le'));\n            }\n            return new this(UInt64.from(value));\n        }\n        static fromABI(decoder) {\n            return new SymbolCode(UInt64.fromABI(decoder));\n        }\n        equals(other) {\n            return this.value.equals(SymbolCode.from(other).value);\n        }\n        toABI(encoder) {\n            this.value.toABI(encoder);\n        }\n        toString() {\n            return charsToSymbolName(this.value.value.toArray('be'));\n        }\n        toJSON() {\n            return this.toString();\n        }\n    }\n    SymbolCode.abiName = 'symbol_code';\n    Asset.SymbolCode = SymbolCode;\n})(Asset || (Asset = {}));\nclass ExtendedAsset {\n    constructor(quantity, contract) {\n        this.quantity = quantity;\n        this.contract = contract;\n    }\n    static from(value) {\n        if (isInstanceOf(value, ExtendedAsset)) {\n            return value;\n        }\n        return new this(Asset.from(value.quantity), Name.from(value.contract));\n    }\n    static fromABI(decoder) {\n        return new ExtendedAsset(Asset.fromABI(decoder), Name.fromABI(decoder));\n    }\n    equals(other) {\n        return this.quantity.equals(other.quantity) && this.contract.equals(other.contract);\n    }\n    toABI(encoder) {\n        this.quantity.toABI(encoder);\n        this.contract.toABI(encoder);\n    }\n    toJSON() {\n        return {\n            quantity: this.quantity,\n            contract: this.contract,\n        };\n    }\n}\nExtendedAsset.abiName = 'extended_asset';\nfunction toSymbolPrecision(rawSymbol) {\n    return rawSymbol.value.and(UInt64.from(0xff).value).toNumber();\n}\nfunction toSymbolName(rawSymbol) {\n    const chars = rawSymbol.value.toArray('be').slice(0, -1);\n    return charsToSymbolName(chars);\n}\nfunction charsToSymbolName(chars) {\n    return chars\n        .map((char) => String.fromCharCode(char))\n        .reverse()\n        .join('');\n}\nfunction toRawSymbol(name, precision) {\n    const array = toRawSymbolCode(name);\n    array.unshift(precision);\n    return UInt64.from(new BN(array, 'le'));\n}\nfunction toRawSymbolCode(name) {\n    const array = [];\n    const length = Math.min(name.length, 7);\n    for (let i = 0; i < length; i++) {\n        array.push(name.charCodeAt(i));\n    }\n    return array;\n}\n\nvar Base58;\n(function (Base58) {\n    const chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n    const charMap = new Int16Array(0xff).fill(-1);\n    for (let i = 0; i < 58; ++i) {\n        charMap[chars.charCodeAt(i)] = i;\n    }\n    /** Decode a Base58 encoded string. */\n    function decode(s, size) {\n        if (size == null) {\n            return decodeVar(s);\n        }\n        const result = new Uint8Array(size);\n        for (let i = 0; i < s.length; ++i) {\n            let carry = charMap[s.charCodeAt(i)];\n            if (carry < 0) {\n                throw new Error('Invalid Base58 value');\n            }\n            for (let j = 0; j < size; ++j) {\n                const x = result[j] * 58 + carry;\n                result[j] = x;\n                carry = x >> 8;\n            }\n            if (carry) {\n                throw new Error('Base58 value is out of range');\n            }\n        }\n        result.reverse();\n        return new Bytes(result);\n    }\n    Base58.decode = decode;\n    /** Decode a Base58Check encoded string. */\n    function decodeCheck(encoded, size) {\n        const decoded = decode(encoded, size != null ? size + 4 : size);\n        const data = decoded.array.subarray(0, -4);\n        const checksum = decoded.array.subarray(-4);\n        if (!arrayEquals(checksum, dsha256Checksum(data))) {\n            throw new Error('Checksum mismatch');\n        }\n        return new Bytes(data);\n    }\n    Base58.decodeCheck = decodeCheck;\n    /** Decode a Base58Check encoded string that uses ripemd160 instead of double sha256 for the digest. */\n    function decodeRipemd160Check(encoded, size, suffix) {\n        const decoded = decode(encoded, size != null ? size + 4 : size);\n        const data = decoded.array.subarray(0, -4);\n        const checksum = decoded.array.subarray(-4);\n        if (!arrayEquals(checksum, ripemd160Checksum(data, suffix))) {\n            throw new Error('Checksum mismatch');\n        }\n        return new Bytes(data);\n    }\n    Base58.decodeRipemd160Check = decodeRipemd160Check;\n    /** Encode bytes to a Base58 string.  */\n    function encode(data) {\n        data = Bytes.from(data);\n        const result = [];\n        for (const byte of data.array) {\n            let carry = byte;\n            for (let j = 0; j < result.length; ++j) {\n                const x = (charMap[result[j]] << 8) + carry;\n                result[j] = chars.charCodeAt(x % 58);\n                carry = (x / 58) | 0;\n            }\n            while (carry) {\n                result.push(chars.charCodeAt(carry % 58));\n                carry = (carry / 58) | 0;\n            }\n        }\n        for (const byte of data.array) {\n            if (byte) {\n                break;\n            }\n            else {\n                result.push('1'.charCodeAt(0));\n            }\n        }\n        result.reverse();\n        return String.fromCharCode(...result);\n    }\n    Base58.encode = encode;\n    function encodeCheck(data) {\n        data = Bytes.from(data);\n        data = data.appending(dsha256Checksum(data.array));\n        return encode(data);\n    }\n    Base58.encodeCheck = encodeCheck;\n    function encodeRipemd160Check(data, suffix) {\n        data = Bytes.from(data);\n        data = data.appending(ripemd160Checksum(data.array, suffix));\n        return encode(data);\n    }\n    Base58.encodeRipemd160Check = encodeRipemd160Check;\n    /** @internal */\n    function decodeVar(s) {\n        const result = [];\n        for (let i = 0; i < s.length; ++i) {\n            let carry = charMap[s.charCodeAt(i)];\n            if (carry < 0) {\n                throw new Error('Invalid Base58 value');\n            }\n            for (let j = 0; j < result.length; ++j) {\n                const x = result[j] * 58 + carry;\n                result[j] = x & 0xff;\n                carry = x >> 8;\n            }\n            if (carry) {\n                result.push(carry);\n            }\n        }\n        for (const ch of s) {\n            if (ch === '1') {\n                result.push(0);\n            }\n            else {\n                break;\n            }\n        }\n        result.reverse();\n        return Bytes.from(result);\n    }\n    /** @internal */\n    function ripemd160Checksum(data, suffix) {\n        const hash = ripemd160().update(data);\n        if (suffix) {\n            hash.update(suffix);\n        }\n        return hash.digest().slice(0, 4);\n    }\n    /** @internal */\n    function dsha256Checksum(data) {\n        const round1 = sha256().update(data).digest();\n        const round2 = sha256().update(round1).digest();\n        return round2.slice(0, 4);\n    }\n})(Base58 || (Base58 = {}));\n\nclass PublicKey {\n    /** @internal */\n    constructor(type, data) {\n        this.type = type;\n        this.data = data;\n    }\n    /** Create PublicKey object from representing types. */\n    static from(value) {\n        if (isInstanceOf(value, PublicKey)) {\n            return value;\n        }\n        if (typeof value === 'object' && value.type && value.compressed) {\n            return new PublicKey(CurveType.from(value.type), new Bytes(value.compressed));\n        }\n        if (typeof value !== 'string') {\n            throw new Error('Invalid public key');\n        }\n        if (value.startsWith('PUB_')) {\n            const parts = value.split('_');\n            if (parts.length !== 3) {\n                throw new Error('Invalid public key string');\n            }\n            const type = CurveType.from(parts[1]);\n            const size = type === CurveType.K1 || type === CurveType.R1 ? 33 : undefined;\n            const data = Base58.decodeRipemd160Check(parts[2], size, type);\n            return new PublicKey(type, data);\n        }\n        else if (value.length >= 50) {\n            // Legacy EOS key\n            const data = Base58.decodeRipemd160Check(value.slice(-50));\n            return new PublicKey(CurveType.K1, data);\n        }\n        else {\n            throw new Error('Invalid public key string');\n        }\n    }\n    /** @internal */\n    static fromABI(decoder) {\n        const type = CurveType.from(decoder.readByte());\n        if (type == CurveType.WA) {\n            // \"WA\" keys pack some sort of metadata\n            // we probably need to restructure key data storage into containers like FC does\n            const data = new Bytes(decoder.readArray(33));\n            Bytes.fromABI(decoder); // throw away metadata for now\n            return new PublicKey(type, data);\n        }\n        return new PublicKey(type, new Bytes(decoder.readArray(33)));\n    }\n    equals(other) {\n        const otherKey = PublicKey.from(other);\n        return this.type === otherKey.type && this.data.equals(otherKey.data);\n    }\n    /**\n     * Return EOSIO legacy (`EOS<base58data>`) formatted key.\n     * @throws If the key type isn't `K1`\n     */\n    toLegacyString(prefix = 'EOS') {\n        if (this.type !== CurveType.K1) {\n            throw new Error('Unable to create legacy formatted string for non-K1 key');\n        }\n        return `${prefix}${Base58.encodeRipemd160Check(this.data)}`;\n    }\n    /** Return key in modern EOSIO format (`PUB_<type>_<base58data>`) */\n    toString() {\n        return `PUB_${this.type}_${Base58.encodeRipemd160Check(this.data, this.type)}`;\n    }\n    /** @internal */\n    toABI(encoder) {\n        if (this.type === CurveType.WA) {\n            throw new Error('WA keys are not supported yet');\n        }\n        encoder.writeByte(CurveType.indexFor(this.type));\n        encoder.writeArray(this.data.array);\n    }\n    /** @internal */\n    toJSON() {\n        return this.toString();\n    }\n}\nPublicKey.abiName = 'public_key';\n\nconst curves = {};\n/**\n * Get curve for key type.\n * @internal\n */\nfunction getCurve(type) {\n    let rv = curves[type];\n    if (!rv) {\n        if (type === 'K1') {\n            rv = curves[type] = new ec('secp256k1');\n        }\n        else if (type === 'R1') {\n            rv = curves[type] = new ec('p256');\n        }\n        else {\n            throw new Error(`Unknown curve type: ${type}`);\n        }\n    }\n    return rv;\n}\n\n/**\n * Recover public key from signature and recovery id.\n * @internal\n */\nfunction recover(signature, message, type) {\n    const curve = getCurve(type);\n    const recid = signature[0] - 31;\n    const r = signature.subarray(1, 33);\n    const s = signature.subarray(33);\n    const point = curve.recoverPubKey(message, { r, s }, recid);\n    return new Uint8Array(point.encodeCompressed());\n}\n\n/**\n * Verify signature using message and public key.\n * @internal\n */\nfunction verify(signature, message, pubkey, type) {\n    const curve = getCurve(type);\n    const r = signature.subarray(1, 33);\n    const s = signature.subarray(33);\n    return curve.verify(message, { r, s }, pubkey);\n}\n\nclass Signature {\n    /** @internal */\n    constructor(type, data) {\n        this.type = type;\n        this.data = data;\n    }\n    /** Create Signature object from representing types. */\n    static from(value) {\n        if (isInstanceOf(value, Signature)) {\n            return value;\n        }\n        if (typeof value === 'object' && value.r && value.s) {\n            const data = new Uint8Array(1 + 32 + 32);\n            let recid = value.recid;\n            const type = CurveType.from(value.type);\n            if (value.type === CurveType.K1 || value.type === CurveType.R1) {\n                recid += 31;\n            }\n            data[0] = recid;\n            data.set(value.r, 1);\n            data.set(value.s, 33);\n            return new Signature(type, new Bytes(data));\n        }\n        if (typeof value !== 'string') {\n            throw new Error('Invalid signature');\n        }\n        if (value.startsWith('SIG_')) {\n            const parts = value.split('_');\n            if (parts.length !== 3) {\n                throw new Error('Invalid signature string');\n            }\n            const type = CurveType.from(parts[1]);\n            const size = type === CurveType.K1 || type === CurveType.R1 ? 65 : undefined;\n            const data = Base58.decodeRipemd160Check(parts[2], size, type);\n            return new Signature(type, data);\n        }\n        else {\n            throw new Error('Invalid signature string');\n        }\n    }\n    /** @internal */\n    static fromABI(decoder) {\n        const type = CurveType.from(decoder.readByte());\n        if (type === CurveType.WA) {\n            // same as with public keys WA type has some extra data tacked on\n            const data = new Bytes(decoder.readArray(65)); // sig\n            Bytes.fromABI(decoder); // throw away for now\n            Bytes.fromABI(decoder);\n            return new Signature(CurveType.WA, data);\n        }\n        return new Signature(type, new Bytes(decoder.readArray(65)));\n    }\n    equals(other) {\n        const otherSig = Signature.from(other);\n        return this.type === otherSig.type && this.data.equals(otherSig.data);\n    }\n    /** Recover public key from given message digest. */\n    recoverDigest(digest) {\n        digest = Checksum256.from(digest);\n        const compressed = recover(this.data.array, digest.array, this.type);\n        return PublicKey.from({ compressed, type: this.type });\n    }\n    /** Recover public key from given message. */\n    recoverMessage(message) {\n        return this.recoverDigest(Checksum256.hash(message));\n    }\n    /** Verify this signature with given message digest and public key. */\n    verifyDigest(digest, publicKey) {\n        digest = Checksum256.from(digest);\n        return verify(this.data.array, digest.array, publicKey.data.array, this.type);\n    }\n    /** Verify this signature with given message and public key. */\n    verifyMessage(message, publicKey) {\n        return this.verifyDigest(Checksum256.hash(message), publicKey);\n    }\n    /** Base58check encoded string representation of this signature (`SIG_<type>_<data>`). */\n    toString() {\n        return `SIG_${this.type}_${Base58.encodeRipemd160Check(this.data, this.type)}`;\n    }\n    /** @internal */\n    toABI(encoder) {\n        if (this.type === CurveType.WA) {\n            throw new Error('WA signatures are not supported yet');\n        }\n        encoder.writeByte(CurveType.indexFor(this.type));\n        encoder.writeArray(this.data.array);\n    }\n    /** @internal */\n    toJSON() {\n        return this.toString();\n    }\n}\nSignature.abiName = 'signature';\n\n/**\n * Get public key corresponding to given private key.\n * @internal\n */\nfunction getPublic(privkey, type) {\n    const curve = getCurve(type);\n    const key = curve.keyFromPrivate(privkey);\n    const point = key.getPublic();\n    return new Uint8Array(point.encodeCompressed());\n}\n\n/**\n * Derive shared secret for key pair.\n * @internal\n */\nfunction sharedSecret(privkey, pubkey, type) {\n    const curve = getCurve(type);\n    const priv = curve.keyFromPrivate(privkey);\n    const pub = curve.keyFromPublic(pubkey).getPublic();\n    return priv.derive(pub).toArrayLike(Uint8Array, 'be');\n}\n\n/**\n * Sign digest using private key.\n * @internal\n */\nfunction sign(secret, message, type) {\n    const curve = getCurve(type);\n    const key = curve.keyFromPrivate(secret);\n    let sig;\n    let r;\n    let s;\n    if (type === 'K1') {\n        let attempt = 1;\n        do {\n            sig = key.sign(message, { canonical: true, pers: [attempt++] });\n            r = sig.r.toArrayLike(Uint8Array, 'be', 32);\n            s = sig.s.toArrayLike(Uint8Array, 'be', 32);\n        } while (!isCanonical(r, s));\n    }\n    else {\n        sig = key.sign(message, { canonical: true });\n        r = sig.r.toArrayLike(Uint8Array, 'be', 32);\n        s = sig.s.toArrayLike(Uint8Array, 'be', 32);\n    }\n    return { type, r, s, recid: sig.recoveryParam || 0 };\n}\n/**\n * Here be dragons\n * - https://github.com/steemit/steem/issues/1944\n * - https://github.com/EOSIO/eos/issues/6699\n * @internal\n */\nfunction isCanonical(r, s) {\n    return (!(r[0] & 0x80) &&\n        !(r[0] === 0 && !(r[1] & 0x80)) &&\n        !(s[0] & 0x80) &&\n        !(s[0] === 0 && !(s[1] & 0x80)));\n}\n\n/**\n * Generate a new private key for given type.\n * @internal\n */\nfunction generate(type) {\n    const curve = getCurve(type);\n    const privkey = curve.genKeyPair().getPrivate();\n    return privkey.toArrayLike(Uint8Array, 'be');\n}\n\nclass PrivateKey {\n    /** @internal */\n    constructor(type, data) {\n        this.type = type;\n        this.data = data;\n    }\n    /** Create PrivateKey object from representing types. */\n    static from(value) {\n        if (isInstanceOf(value, PrivateKey)) {\n            return value;\n        }\n        if (typeof value !== 'string') {\n            throw new Error('Invalid private key');\n        }\n        if (value.startsWith('PVT_')) {\n            // EOSIO format\n            const parts = value.split('_');\n            if (parts.length !== 3) {\n                throw new Error('Invalid private key string');\n            }\n            const type = CurveType.from(parts[1]);\n            let size;\n            switch (type) {\n                case CurveType.K1:\n                case CurveType.R1:\n                    size = 32;\n                    break;\n            }\n            const data = Base58.decodeRipemd160Check(parts[2], size, type);\n            return new PrivateKey(type, data);\n        }\n        else {\n            // WIF format\n            const type = CurveType.K1;\n            const data = Base58.decodeCheck(value);\n            if (data.array[0] !== 0x80) {\n                throw new Error('Invalid private key WIF');\n            }\n            return new PrivateKey(type, data.droppingFirst());\n        }\n    }\n    /**\n     * Generate new PrivateKey.\n     * @throws If a secure random source isn't available.\n     */\n    static generate(type) {\n        return new PrivateKey(CurveType.from(type), new Bytes(generate(type)));\n    }\n    /**\n     * Sign message digest using this key.\n     * @throws If the key type isn't R1 or K1.\n     */\n    signDigest(digest) {\n        digest = Checksum256.from(digest);\n        return Signature.from(sign(this.data.array, digest.array, this.type));\n    }\n    /**\n     * Sign message using this key.\n     * @throws If the key type isn't R1 or K1.\n     */\n    signMessage(message) {\n        return this.signDigest(Checksum256.hash(message));\n    }\n    /**\n     * Derive the shared secret between this private key and given public key.\n     * @throws If the key type isn't R1 or K1.\n     */\n    sharedSecret(publicKey) {\n        const shared = sharedSecret(this.data.array, publicKey.data.array, this.type);\n        return Checksum512.hash(shared);\n    }\n    /**\n     * Get the corresponding public key.\n     * @throws If the key type isn't R1 or K1.\n     */\n    toPublic() {\n        const compressed = getPublic(this.data.array, this.type);\n        return PublicKey.from({ compressed, type: this.type });\n    }\n    /**\n     * Return WIF representation of this private key\n     * @throws If the key type isn't K1.\n     */\n    toWif() {\n        if (this.type !== CurveType.K1) {\n            throw new Error('Unable to generate WIF for non-k1 key');\n        }\n        return Base58.encodeCheck(Bytes.from([0x80]).appending(this.data));\n    }\n    /**\n     * Return the key in EOSIO PVT_<type>_<base58check> format.\n     */\n    toString() {\n        return `PVT_${this.type}_${Base58.encodeRipemd160Check(this.data, this.type)}`;\n    }\n    toJSON() {\n        return this.toString();\n    }\n}\n\nvar PermissionLevel_1;\n/** EOSIO Permission Level, a.k.a \"auth\". */\nlet PermissionLevel = PermissionLevel_1 = class PermissionLevel extends Struct {\n    /** Create new permission level from representing types. Can be expressed as a string in the format `<actor>@<permission>`. */\n    static from(value) {\n        if (typeof value === 'string') {\n            const parts = value.split('@');\n            if (parts.length !== 2 && parts[0].length > 0 && parts[1].length > 0) {\n                throw new Error('Invalid permission level string, should be in the format <actor>@<permission>');\n            }\n            value = { actor: parts[0], permission: parts[1] };\n        }\n        return super.from(value);\n    }\n    /** Return true if this permission level equals other. */\n    equals(other) {\n        const otherPerm = PermissionLevel_1.from(other);\n        return this.actor.equals(otherPerm.actor) && this.permission.equals(otherPerm.permission);\n    }\n    toString() {\n        return `${this.actor}@${this.permission}`;\n    }\n};\n__decorate([\n    Struct.field('name')\n], PermissionLevel.prototype, \"actor\", void 0);\n__decorate([\n    Struct.field('name')\n], PermissionLevel.prototype, \"permission\", void 0);\nPermissionLevel = PermissionLevel_1 = __decorate([\n    Struct.type('permission_level')\n], PermissionLevel);\n\nvar Action_1;\nlet Action = Action_1 = class Action extends Struct {\n    static from(object, abi) {\n        const data = object.data;\n        if (!Bytes.isBytes(data)) {\n            let type;\n            if (abi) {\n                type = ABI.from(abi).getActionType(object.name);\n            }\n            else if (!data.constructor || data.constructor.abiName === undefined) {\n                throw new Error('Missing ABI definition when creating action with untyped action data');\n            }\n            object = {\n                ...object,\n                data: abiEncode({ object: data, type, abi }),\n            };\n        }\n        return super.from(object);\n    }\n    /** Return true if this Action is equal to given action. */\n    equals(other) {\n        const otherAction = Action_1.from(other);\n        return (this.account.equals(otherAction.account) &&\n            this.name.equals(otherAction.name) &&\n            arrayEquatableEquals(this.authorization, otherAction.authorization) &&\n            this.data.equals(otherAction.data));\n    }\n    decodeData(typeOrAbi) {\n        if (typeof typeOrAbi === 'string' || typeOrAbi.abiName) {\n            return abiDecode({\n                data: this.data,\n                type: typeOrAbi,\n            });\n        }\n        else {\n            const abi = ABI.from(typeOrAbi);\n            const type = abi.getActionType(this.name);\n            if (!type) {\n                throw new Error(`Action ${this.name} does not exist in provided ABI`);\n            }\n            return abiDecode({ data: this.data, type, abi });\n        }\n    }\n};\n__decorate([\n    Struct.field('name')\n], Action.prototype, \"account\", void 0);\n__decorate([\n    Struct.field('name')\n], Action.prototype, \"name\", void 0);\n__decorate([\n    Struct.field(PermissionLevel, { array: true })\n], Action.prototype, \"authorization\", void 0);\n__decorate([\n    Struct.field('bytes')\n], Action.prototype, \"data\", void 0);\nAction = Action_1 = __decorate([\n    Struct.type('action')\n], Action);\n\nvar Transaction_1;\nlet TransactionExtension = class TransactionExtension extends Struct {\n};\n__decorate([\n    Struct.field('uint16')\n], TransactionExtension.prototype, \"type\", void 0);\n__decorate([\n    Struct.field('bytes')\n], TransactionExtension.prototype, \"data\", void 0);\nTransactionExtension = __decorate([\n    Struct.type('transaction_extension')\n], TransactionExtension);\nlet TransactionHeader = class TransactionHeader extends Struct {\n    static from(object) {\n        return super.from(object);\n    }\n};\n__decorate([\n    Struct.field('time_point_sec')\n], TransactionHeader.prototype, \"expiration\", void 0);\n__decorate([\n    Struct.field('uint16')\n], TransactionHeader.prototype, \"ref_block_num\", void 0);\n__decorate([\n    Struct.field('uint32')\n], TransactionHeader.prototype, \"ref_block_prefix\", void 0);\n__decorate([\n    Struct.field('varuint32', { default: 0 })\n], TransactionHeader.prototype, \"max_net_usage_words\", void 0);\n__decorate([\n    Struct.field('uint8', { default: 0 })\n], TransactionHeader.prototype, \"max_cpu_usage_ms\", void 0);\n__decorate([\n    Struct.field('varuint32', { default: 0 })\n], TransactionHeader.prototype, \"delay_sec\", void 0);\nTransactionHeader = __decorate([\n    Struct.type('transaction_header')\n], TransactionHeader);\nlet Transaction = Transaction_1 = class Transaction extends TransactionHeader {\n    static from(object, abis) {\n        const abiFor = (contract) => {\n            if (!abis) {\n                return;\n            }\n            else if (Array.isArray(abis)) {\n                return abis\n                    .filter((abi) => Name.from(abi.contract).equals(contract))\n                    .map(({ abi }) => abi)[0];\n            }\n            else {\n                return abis;\n            }\n        };\n        const resolveAction = (action) => Action.from(action, abiFor(action.account));\n        const actions = (object.actions || []).map(resolveAction);\n        const context_free_actions = (object.context_free_actions || []).map(resolveAction);\n        const transaction = {\n            ...object,\n            context_free_actions,\n            actions,\n        };\n        return super.from(transaction);\n    }\n    /** Return true if this transaction is equal to given transaction. */\n    equals(other) {\n        const tx = Transaction_1.from(other);\n        return this.id.equals(tx.id);\n    }\n    get id() {\n        return Checksum256.hash(abiEncode({ object: this }));\n    }\n    signingDigest(chainId) {\n        let data = Bytes.from(Checksum256.from(chainId).array);\n        data = data.appending(abiEncode({ object: this }));\n        data = data.appending(new Uint8Array(32));\n        return Checksum256.hash(data);\n    }\n};\n__decorate([\n    Struct.field(Action, { array: true, default: [] })\n], Transaction.prototype, \"context_free_actions\", void 0);\n__decorate([\n    Struct.field(Action, { array: true, default: [] })\n], Transaction.prototype, \"actions\", void 0);\n__decorate([\n    Struct.field(TransactionExtension, { array: true, default: [] })\n], Transaction.prototype, \"transaction_extensions\", void 0);\nTransaction = Transaction_1 = __decorate([\n    Struct.type('transaction')\n], Transaction);\nlet SignedTransaction = class SignedTransaction extends Transaction {\n    static from(object) {\n        return super.from(object);\n    }\n};\n__decorate([\n    Struct.field('signature[]', { default: [] })\n], SignedTransaction.prototype, \"signatures\", void 0);\n__decorate([\n    Struct.field('bytes[]', { default: [] })\n], SignedTransaction.prototype, \"context_free_data\", void 0);\nSignedTransaction = __decorate([\n    Struct.type('signed_transaction')\n], SignedTransaction);\nlet PackedTransaction = class PackedTransaction extends Struct {\n    static fromSigned(signed) {\n        const tx = Transaction.from(signed);\n        return this.from({\n            signatures: signed.signatures,\n            packed_context_free_data: abiEncode({\n                object: signed.context_free_data,\n                type: 'bytes[]',\n            }),\n            packed_trx: abiEncode({ object: tx }),\n        });\n    }\n    getTransaction() {\n        if (this.compression.value !== 0) {\n            throw new Error('Transaction compression not supported yet');\n        }\n        return abiDecode({ data: this.packed_trx, type: Transaction });\n    }\n    getSignedTransaction() {\n        const transaction = this.getTransaction();\n        // TODO: decode context free data\n        return SignedTransaction.from({\n            ...transaction,\n            signatures: this.signatures,\n        });\n    }\n};\n__decorate([\n    Struct.field('signature[]')\n], PackedTransaction.prototype, \"signatures\", void 0);\n__decorate([\n    Struct.field('uint8', { default: 0 })\n], PackedTransaction.prototype, \"compression\", void 0);\n__decorate([\n    Struct.field('bytes')\n], PackedTransaction.prototype, \"packed_context_free_data\", void 0);\n__decorate([\n    Struct.field('bytes')\n], PackedTransaction.prototype, \"packed_trx\", void 0);\nPackedTransaction = __decorate([\n    Struct.type('packed_transaction')\n], PackedTransaction);\nlet TransactionReceipt = class TransactionReceipt extends Struct {\n};\n__decorate([\n    Struct.field('string')\n], TransactionReceipt.prototype, \"status\", void 0);\n__decorate([\n    Struct.field('uint32')\n], TransactionReceipt.prototype, \"cpu_usage_us\", void 0);\n__decorate([\n    Struct.field('uint32')\n], TransactionReceipt.prototype, \"net_usage_words\", void 0);\nTransactionReceipt = __decorate([\n    Struct.type('transaction_receipt')\n], TransactionReceipt);\n\nvar Authority_1;\nlet Weight = class Weight extends UInt16 {\n};\nWeight = __decorate([\n    TypeAlias('weight_type')\n], Weight);\nlet KeyWeight = class KeyWeight extends Struct {\n};\n__decorate([\n    Struct.field(PublicKey)\n], KeyWeight.prototype, \"key\", void 0);\n__decorate([\n    Struct.field(Weight)\n], KeyWeight.prototype, \"weight\", void 0);\nKeyWeight = __decorate([\n    Struct.type('key_weight')\n], KeyWeight);\nlet PermissionLevelWeight = class PermissionLevelWeight extends Struct {\n};\n__decorate([\n    Struct.field(PermissionLevel)\n], PermissionLevelWeight.prototype, \"permission\", void 0);\n__decorate([\n    Struct.field(Weight)\n], PermissionLevelWeight.prototype, \"weight\", void 0);\nPermissionLevelWeight = __decorate([\n    Struct.type('permission_level_weight')\n], PermissionLevelWeight);\nlet WaitWeight = class WaitWeight extends Struct {\n};\n__decorate([\n    Struct.field(UInt32)\n], WaitWeight.prototype, \"wait_sec\", void 0);\n__decorate([\n    Struct.field(Weight)\n], WaitWeight.prototype, \"weight\", void 0);\nWaitWeight = __decorate([\n    Struct.type('wait_weight')\n], WaitWeight);\nlet Authority = Authority_1 = class Authority extends Struct {\n    static from(value) {\n        if (isInstanceOf(value, Authority_1)) {\n            return value;\n        }\n        const rv = super.from({\n            keys: [],\n            accounts: [],\n            waits: [],\n            ...value,\n        });\n        rv.sort();\n        return rv;\n    }\n    /** Total weight of all waits. */\n    get waitThreshold() {\n        return this.waits.reduce((val, wait) => val + wait.weight.toNumber(), 0);\n    }\n    /** Weight a key needs to sign for this authority. */\n    get keyTreshhold() {\n        return this.threshold.toNumber() - this.waitThreshold;\n    }\n    /** Return the weight for given public key, or zero if it is not included in this authority. */\n    keyWeight(publicKey) {\n        const weight = this.keys.find(({ key }) => key.equals(publicKey));\n        return weight ? weight.weight.toNumber() : 0;\n    }\n    /**\n     * Check if given public key has permission in this authority,\n     * @attention Does not take indirect permissions for the key via account weights into account.\n     * @param publicKey The key to check.\n     * @param includePartial Whether to consider auths where the key is included but can't be reached alone (e.g. multisig).\n     */\n    hasPermission(publicKey, includePartial = false) {\n        const threshold = includePartial ? 1 : this.keyTreshhold;\n        const weight = this.keyWeight(publicKey);\n        return weight >= threshold;\n    }\n    /**\n     * Sorts the authority weights in place, should be called before including the authority in a `updateauth` action or it might be rejected.\n     */\n    sort() {\n        // This hack satisfies the constraints that authority weights, see: https://github.com/greymass/eosio-core/issues/8\n        this.keys.sort((a, b) => String(a.key).localeCompare(String(b.key)));\n        this.accounts.sort((a, b) => String(a.permission).localeCompare(String(b.permission)));\n        this.waits.sort((a, b) => String(a.wait_sec).localeCompare(String(b.wait_sec)));\n    }\n};\n__decorate([\n    Struct.field(UInt32)\n], Authority.prototype, \"threshold\", void 0);\n__decorate([\n    Struct.field(KeyWeight, { array: true })\n], Authority.prototype, \"keys\", void 0);\n__decorate([\n    Struct.field(PermissionLevelWeight, { array: true })\n], Authority.prototype, \"accounts\", void 0);\n__decorate([\n    Struct.field(WaitWeight, { array: true })\n], Authority.prototype, \"waits\", void 0);\nAuthority = Authority_1 = __decorate([\n    Struct.type('authority')\n], Authority);\n\nvar Serializer;\n(function (Serializer) {\n    Serializer.encode = abiEncode;\n    Serializer.decode = abiDecode;\n    /** Create an EOSIO ABI definition for given core type. */\n    function synthesize(type) {\n        return synthesizeABI(type).abi;\n    }\n    Serializer.synthesize = synthesize;\n    /** Create JSON representation of a core object. */\n    function stringify(object) {\n        return JSON.stringify(object);\n    }\n    Serializer.stringify = stringify;\n    /** Create a vanilla js representation of a core object. */\n    function objectify(object) {\n        return JSON.parse(JSON.stringify(object));\n    }\n    Serializer.objectify = objectify;\n})(Serializer || (Serializer = {}));\n\n/** Default provider that uses the Fetch API to call a single node. */\nclass FetchProvider {\n    constructor(url, options = {}) {\n        url = url.trim();\n        if (url.endsWith('/'))\n            url = url.slice(0, -1);\n        this.url = url;\n        if (!options.fetch) {\n            if (typeof window !== 'undefined' && window.fetch) {\n                this.fetch = window.fetch.bind(window);\n            }\n            else if (typeof global !== 'undefined' && global.fetch) {\n                this.fetch = global.fetch.bind(global);\n            }\n            else {\n                throw new Error('Missing fetch');\n            }\n        }\n        else {\n            this.fetch = options.fetch;\n        }\n    }\n    async call(path, params) {\n        const url = this.url + path;\n        const response = await this.fetch(url, {\n            method: 'POST',\n            body: params !== undefined ? JSON.stringify(params) : undefined,\n        });\n        try {\n            return response.json();\n        }\n        catch (error) {\n            if (!response.ok) {\n                throw Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n            error.message = `Unable to parse JSON response from server: ${error.message}`;\n            throw error;\n        }\n    }\n}\n\nlet AccountPermission = class AccountPermission extends Struct {\n};\n__decorate([\n    Struct.field('name')\n], AccountPermission.prototype, \"perm_name\", void 0);\n__decorate([\n    Struct.field('name')\n], AccountPermission.prototype, \"parent\", void 0);\n__decorate([\n    Struct.field(Authority)\n], AccountPermission.prototype, \"required_auth\", void 0);\nAccountPermission = __decorate([\n    Struct.type('account_permission')\n], AccountPermission);\nlet AccountResourceLimit = class AccountResourceLimit extends Struct {\n};\n__decorate([\n    Struct.field('uint64')\n], AccountResourceLimit.prototype, \"used\", void 0);\n__decorate([\n    Struct.field('uint64')\n], AccountResourceLimit.prototype, \"available\", void 0);\n__decorate([\n    Struct.field('uint64')\n], AccountResourceLimit.prototype, \"max\", void 0);\nAccountResourceLimit = __decorate([\n    Struct.type('account_resource_limit')\n], AccountResourceLimit);\nlet AccountTotalResources = class AccountTotalResources extends Struct {\n};\n__decorate([\n    Struct.field('name')\n], AccountTotalResources.prototype, \"owner\", void 0);\n__decorate([\n    Struct.field('asset')\n], AccountTotalResources.prototype, \"net_weight\", void 0);\n__decorate([\n    Struct.field('asset')\n], AccountTotalResources.prototype, \"cpu_weight\", void 0);\n__decorate([\n    Struct.field('uint64')\n], AccountTotalResources.prototype, \"ram_bytes\", void 0);\nAccountTotalResources = __decorate([\n    Struct.type('account_total_resources')\n], AccountTotalResources);\nlet AccountSelfDelegatedBandwidth = class AccountSelfDelegatedBandwidth extends Struct {\n};\n__decorate([\n    Struct.field('name')\n], AccountSelfDelegatedBandwidth.prototype, \"from\", void 0);\n__decorate([\n    Struct.field('name')\n], AccountSelfDelegatedBandwidth.prototype, \"to\", void 0);\n__decorate([\n    Struct.field('asset')\n], AccountSelfDelegatedBandwidth.prototype, \"net_weight\", void 0);\n__decorate([\n    Struct.field('asset')\n], AccountSelfDelegatedBandwidth.prototype, \"cpu_weight\", void 0);\nAccountSelfDelegatedBandwidth = __decorate([\n    Struct.type('account_self_delegated_bandwidth')\n], AccountSelfDelegatedBandwidth);\nlet AccountRefundRequest = class AccountRefundRequest extends Struct {\n};\n__decorate([\n    Struct.field('name')\n], AccountRefundRequest.prototype, \"owner\", void 0);\n__decorate([\n    Struct.field('time_point')\n], AccountRefundRequest.prototype, \"request_time\", void 0);\n__decorate([\n    Struct.field('asset')\n], AccountRefundRequest.prototype, \"net_amount\", void 0);\n__decorate([\n    Struct.field('asset')\n], AccountRefundRequest.prototype, \"cpu_amount\", void 0);\nAccountRefundRequest = __decorate([\n    Struct.type('account_refund_request')\n], AccountRefundRequest);\nlet AccountVoterInfo = class AccountVoterInfo extends Struct {\n};\n__decorate([\n    Struct.field('name')\n], AccountVoterInfo.prototype, \"owner\", void 0);\n__decorate([\n    Struct.field('name')\n], AccountVoterInfo.prototype, \"proxy\", void 0);\n__decorate([\n    Struct.field('name', { array: true })\n], AccountVoterInfo.prototype, \"producers\", void 0);\n__decorate([\n    Struct.field('int64', { optional: true })\n], AccountVoterInfo.prototype, \"staked\", void 0);\n__decorate([\n    Struct.field('bool')\n], AccountVoterInfo.prototype, \"is_proxy\", void 0);\n__decorate([\n    Struct.field('uint32', { optional: true })\n], AccountVoterInfo.prototype, \"flags1\", void 0);\n__decorate([\n    Struct.field('uint32')\n], AccountVoterInfo.prototype, \"reserved2\", void 0);\n__decorate([\n    Struct.field('string')\n], AccountVoterInfo.prototype, \"reserved3\", void 0);\nAccountVoterInfo = __decorate([\n    Struct.type('account_voter_info')\n], AccountVoterInfo);\nlet AccountRexInfoMaturities = class AccountRexInfoMaturities extends Struct {\n};\n__decorate([\n    Struct.field('time_point', { optional: true })\n], AccountRexInfoMaturities.prototype, \"key\", void 0);\n__decorate([\n    Struct.field('int64', { optional: true })\n], AccountRexInfoMaturities.prototype, \"value\", void 0);\n__decorate([\n    Struct.field('time_point', { optional: true })\n], AccountRexInfoMaturities.prototype, \"first\", void 0);\n__decorate([\n    Struct.field('int64', { optional: true })\n], AccountRexInfoMaturities.prototype, \"second\", void 0);\nAccountRexInfoMaturities = __decorate([\n    Struct.type('account_rex_info_maturities')\n], AccountRexInfoMaturities);\nlet AccountRexInfo = class AccountRexInfo extends Struct {\n};\n__decorate([\n    Struct.field('uint32')\n], AccountRexInfo.prototype, \"version\", void 0);\n__decorate([\n    Struct.field('name')\n], AccountRexInfo.prototype, \"owner\", void 0);\n__decorate([\n    Struct.field('asset')\n], AccountRexInfo.prototype, \"vote_stake\", void 0);\n__decorate([\n    Struct.field('asset')\n], AccountRexInfo.prototype, \"rex_balance\", void 0);\n__decorate([\n    Struct.field('int64')\n], AccountRexInfo.prototype, \"matured_rex\", void 0);\n__decorate([\n    Struct.field(AccountRexInfoMaturities, { array: true })\n], AccountRexInfo.prototype, \"rex_maturities\", void 0);\nAccountRexInfo = __decorate([\n    Struct.type('account_rex_info')\n], AccountRexInfo);\nlet AccountObject = class AccountObject extends Struct {\n    getPermission(permission) {\n        const name = Name.from(permission);\n        const match = this.permissions.find((p) => p.perm_name.equals(name));\n        if (!match) {\n            throw new Error(`Unknown permission ${name} on account ${this.account_name}.`);\n        }\n        return match;\n    }\n};\n__decorate([\n    Struct.field('name')\n], AccountObject.prototype, \"account_name\", void 0);\n__decorate([\n    Struct.field('uint32')\n], AccountObject.prototype, \"head_block_num\", void 0);\n__decorate([\n    Struct.field('time_point')\n], AccountObject.prototype, \"head_block_time\", void 0);\n__decorate([\n    Struct.field('bool')\n], AccountObject.prototype, \"privileged\", void 0);\n__decorate([\n    Struct.field('time_point')\n], AccountObject.prototype, \"last_code_update\", void 0);\n__decorate([\n    Struct.field('time_point')\n], AccountObject.prototype, \"created\", void 0);\n__decorate([\n    Struct.field('asset?')\n], AccountObject.prototype, \"core_liquid_balance\", void 0);\n__decorate([\n    Struct.field('int64')\n], AccountObject.prototype, \"ram_quota\", void 0);\n__decorate([\n    Struct.field('int64')\n], AccountObject.prototype, \"net_weight\", void 0);\n__decorate([\n    Struct.field('int64')\n], AccountObject.prototype, \"cpu_weight\", void 0);\n__decorate([\n    Struct.field(AccountResourceLimit)\n], AccountObject.prototype, \"net_limit\", void 0);\n__decorate([\n    Struct.field(AccountResourceLimit)\n], AccountObject.prototype, \"cpu_limit\", void 0);\n__decorate([\n    Struct.field('uint64')\n], AccountObject.prototype, \"ram_usage\", void 0);\n__decorate([\n    Struct.field(AccountPermission, { array: true })\n], AccountObject.prototype, \"permissions\", void 0);\n__decorate([\n    Struct.field(AccountTotalResources)\n], AccountObject.prototype, \"total_resources\", void 0);\n__decorate([\n    Struct.field(AccountSelfDelegatedBandwidth, { optional: true })\n], AccountObject.prototype, \"self_delegated_bandwidth\", void 0);\n__decorate([\n    Struct.field(AccountRefundRequest, { optional: true })\n], AccountObject.prototype, \"refund_request\", void 0);\n__decorate([\n    Struct.field(AccountVoterInfo, { optional: true })\n], AccountObject.prototype, \"voter_info\", void 0);\n__decorate([\n    Struct.field(AccountRexInfo, { optional: true })\n], AccountObject.prototype, \"rex_info\", void 0);\nAccountObject = __decorate([\n    Struct.type('account_object')\n], AccountObject);\nlet NewProducersEntry = class NewProducersEntry extends Struct {\n};\n__decorate([\n    Struct.field('name')\n], NewProducersEntry.prototype, \"producer_name\", void 0);\n__decorate([\n    Struct.field('public_key')\n], NewProducersEntry.prototype, \"block_signing_key\", void 0);\nNewProducersEntry = __decorate([\n    Struct.type('new_producers_entry')\n], NewProducersEntry);\nlet NewProducers = class NewProducers extends Struct {\n};\n__decorate([\n    Struct.field('uint32')\n], NewProducers.prototype, \"version\", void 0);\n__decorate([\n    Struct.field(NewProducersEntry, { array: true })\n], NewProducers.prototype, \"producers\", void 0);\nNewProducers = __decorate([\n    Struct.type('new_producers')\n], NewProducers);\nlet BlockExtension = class BlockExtension extends Struct {\n};\n__decorate([\n    Struct.field('uint16')\n], BlockExtension.prototype, \"type\", void 0);\n__decorate([\n    Struct.field('bytes')\n], BlockExtension.prototype, \"data\", void 0);\nBlockExtension = __decorate([\n    Struct.type('block_extension')\n], BlockExtension);\nlet HeaderExtension = class HeaderExtension extends Struct {\n};\n__decorate([\n    Struct.field('uint16')\n], HeaderExtension.prototype, \"type\", void 0);\n__decorate([\n    Struct.field('bytes')\n], HeaderExtension.prototype, \"data\", void 0);\nHeaderExtension = __decorate([\n    Struct.type('header_extension')\n], HeaderExtension);\nlet GetBlockResponse = class GetBlockResponse extends Struct {\n};\n__decorate([\n    Struct.field('time_point')\n], GetBlockResponse.prototype, \"timestamp\", void 0);\n__decorate([\n    Struct.field('name')\n], GetBlockResponse.prototype, \"producer\", void 0);\n__decorate([\n    Struct.field('uint16')\n], GetBlockResponse.prototype, \"confirmed\", void 0);\n__decorate([\n    Struct.field('checksum256')\n], GetBlockResponse.prototype, \"previous\", void 0);\n__decorate([\n    Struct.field('checksum256')\n], GetBlockResponse.prototype, \"transaction_mroot\", void 0);\n__decorate([\n    Struct.field('checksum256')\n], GetBlockResponse.prototype, \"action_mroot\", void 0);\n__decorate([\n    Struct.field('uint32')\n], GetBlockResponse.prototype, \"schedule_version\", void 0);\n__decorate([\n    Struct.field(NewProducers, { optional: true })\n], GetBlockResponse.prototype, \"new_producers\", void 0);\n__decorate([\n    Struct.field('header_extension', { optional: true })\n], GetBlockResponse.prototype, \"header_extensions\", void 0);\n__decorate([\n    Struct.field('any', { optional: true })\n], GetBlockResponse.prototype, \"new_protocol_features\", void 0);\n__decorate([\n    Struct.field('signature')\n], GetBlockResponse.prototype, \"producer_signature\", void 0);\n__decorate([\n    Struct.field(TransactionReceipt, { array: true })\n], GetBlockResponse.prototype, \"transactions\", void 0);\n__decorate([\n    Struct.field('block_extension', { optional: true })\n], GetBlockResponse.prototype, \"block_extensions\", void 0);\n__decorate([\n    Struct.field('checksum256')\n], GetBlockResponse.prototype, \"id\", void 0);\n__decorate([\n    Struct.field('uint32')\n], GetBlockResponse.prototype, \"block_num\", void 0);\n__decorate([\n    Struct.field('uint32')\n], GetBlockResponse.prototype, \"ref_block_prefix\", void 0);\nGetBlockResponse = __decorate([\n    Struct.type('get_block_response')\n], GetBlockResponse);\nlet ActiveScheduleProducerAuthority = class ActiveScheduleProducerAuthority extends Struct {\n};\n__decorate([\n    Struct.field('name')\n], ActiveScheduleProducerAuthority.prototype, \"producer_name\", void 0);\n__decorate([\n    Struct.field('any')\n], ActiveScheduleProducerAuthority.prototype, \"authority\", void 0);\nActiveScheduleProducerAuthority = __decorate([\n    Struct.type('active_schedule_producer_authority')\n], ActiveScheduleProducerAuthority);\nlet ActiveScheduleProducer = class ActiveScheduleProducer extends Struct {\n};\n__decorate([\n    Struct.field('name')\n], ActiveScheduleProducer.prototype, \"producer_name\", void 0);\n__decorate([\n    Struct.field(ActiveScheduleProducerAuthority)\n], ActiveScheduleProducer.prototype, \"authority\", void 0);\nActiveScheduleProducer = __decorate([\n    Struct.type('active_schedule_producer')\n], ActiveScheduleProducer);\nlet ActiveSchedule = class ActiveSchedule extends Struct {\n};\n__decorate([\n    Struct.field('uint32')\n], ActiveSchedule.prototype, \"version\", void 0);\n__decorate([\n    Struct.field(ActiveScheduleProducer, { array: true })\n], ActiveSchedule.prototype, \"producers\", void 0);\nActiveSchedule = __decorate([\n    Struct.type('active_schedule')\n], ActiveSchedule);\nlet BlockStateHeader = class BlockStateHeader extends Struct {\n};\n__decorate([\n    Struct.field('time_point')\n], BlockStateHeader.prototype, \"timestamp\", void 0);\n__decorate([\n    Struct.field('name')\n], BlockStateHeader.prototype, \"producer\", void 0);\n__decorate([\n    Struct.field('uint16')\n], BlockStateHeader.prototype, \"confirmed\", void 0);\n__decorate([\n    Struct.field('checksum256')\n], BlockStateHeader.prototype, \"previous\", void 0);\n__decorate([\n    Struct.field('checksum256')\n], BlockStateHeader.prototype, \"transaction_mroot\", void 0);\n__decorate([\n    Struct.field('checksum256')\n], BlockStateHeader.prototype, \"action_mroot\", void 0);\n__decorate([\n    Struct.field('uint32')\n], BlockStateHeader.prototype, \"schedule_version\", void 0);\n__decorate([\n    Struct.field(HeaderExtension, { array: true, optional: true })\n], BlockStateHeader.prototype, \"header_extensions\", void 0);\n__decorate([\n    Struct.field('signature')\n], BlockStateHeader.prototype, \"producer_signature\", void 0);\nBlockStateHeader = __decorate([\n    Struct.type('block_state_header')\n], BlockStateHeader);\nlet GetBlockHeaderStateResponse = class GetBlockHeaderStateResponse extends Struct {\n};\n__decorate([\n    Struct.field('uint32')\n], GetBlockHeaderStateResponse.prototype, \"block_num\", void 0);\n__decorate([\n    Struct.field('uint32')\n], GetBlockHeaderStateResponse.prototype, \"dpos_proposed_irreversible_blocknum\", void 0);\n__decorate([\n    Struct.field('uint32')\n], GetBlockHeaderStateResponse.prototype, \"dpos_irreversible_blocknum\", void 0);\n__decorate([\n    Struct.field('checksum256')\n], GetBlockHeaderStateResponse.prototype, \"id\", void 0);\n__decorate([\n    Struct.field(BlockStateHeader)\n], GetBlockHeaderStateResponse.prototype, \"header\", void 0);\n__decorate([\n    Struct.field('any')\n], GetBlockHeaderStateResponse.prototype, \"active_schedule\", void 0);\n__decorate([\n    Struct.field('any')\n], GetBlockHeaderStateResponse.prototype, \"blockroot_merkle\", void 0);\n__decorate([\n    Struct.field('any')\n], GetBlockHeaderStateResponse.prototype, \"producer_to_last_produced\", void 0);\n__decorate([\n    Struct.field('any')\n], GetBlockHeaderStateResponse.prototype, \"producer_to_last_implied_irb\", void 0);\n__decorate([\n    Struct.field('any')\n], GetBlockHeaderStateResponse.prototype, \"valid_block_signing_authority\", void 0);\n__decorate([\n    Struct.field('any')\n], GetBlockHeaderStateResponse.prototype, \"confirm_count\", void 0);\n__decorate([\n    Struct.field('any')\n], GetBlockHeaderStateResponse.prototype, \"pending_schedule\", void 0);\n__decorate([\n    Struct.field('any')\n], GetBlockHeaderStateResponse.prototype, \"activated_protocol_features\", void 0);\n__decorate([\n    Struct.field('any')\n], GetBlockHeaderStateResponse.prototype, \"additional_signatures\", void 0);\nGetBlockHeaderStateResponse = __decorate([\n    Struct.type('get_block_header_state_response')\n], GetBlockHeaderStateResponse);\nlet GetInfoResponse = class GetInfoResponse extends Struct {\n    getTransactionHeader(secondsAhead = 120) {\n        const expiration = TimePointSec.fromMilliseconds(this.head_block_time.toMilliseconds() + secondsAhead * 1000);\n        const id = this.last_irreversible_block_id;\n        const prefixArray = id.array.subarray(8, 12);\n        const prefix = new Uint32Array(prefixArray.buffer, prefixArray.byteOffset, 1)[0];\n        return TransactionHeader.from({\n            expiration,\n            ref_block_num: this.last_irreversible_block_num.value & 0xffff,\n            ref_block_prefix: prefix,\n        });\n    }\n};\n__decorate([\n    Struct.field('string')\n], GetInfoResponse.prototype, \"server_version\", void 0);\n__decorate([\n    Struct.field('checksum256')\n], GetInfoResponse.prototype, \"chain_id\", void 0);\n__decorate([\n    Struct.field('uint32')\n], GetInfoResponse.prototype, \"head_block_num\", void 0);\n__decorate([\n    Struct.field('uint32')\n], GetInfoResponse.prototype, \"last_irreversible_block_num\", void 0);\n__decorate([\n    Struct.field('checksum256')\n], GetInfoResponse.prototype, \"last_irreversible_block_id\", void 0);\n__decorate([\n    Struct.field('checksum256')\n], GetInfoResponse.prototype, \"head_block_id\", void 0);\n__decorate([\n    Struct.field('time_point')\n], GetInfoResponse.prototype, \"head_block_time\", void 0);\n__decorate([\n    Struct.field('name')\n], GetInfoResponse.prototype, \"head_block_producer\", void 0);\n__decorate([\n    Struct.field('uint64')\n], GetInfoResponse.prototype, \"virtual_block_cpu_limit\", void 0);\n__decorate([\n    Struct.field('uint64')\n], GetInfoResponse.prototype, \"virtual_block_net_limit\", void 0);\n__decorate([\n    Struct.field('uint64')\n], GetInfoResponse.prototype, \"block_cpu_limit\", void 0);\n__decorate([\n    Struct.field('uint64')\n], GetInfoResponse.prototype, \"block_net_limit\", void 0);\n__decorate([\n    Struct.field('string?')\n], GetInfoResponse.prototype, \"server_version_string\", void 0);\n__decorate([\n    Struct.field('uint32?')\n], GetInfoResponse.prototype, \"fork_db_head_block_num\", void 0);\n__decorate([\n    Struct.field('checksum256?')\n], GetInfoResponse.prototype, \"fork_db_head_block_id\", void 0);\nGetInfoResponse = __decorate([\n    Struct.type('get_info_response')\n], GetInfoResponse);\n\nvar types$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    get AccountPermission () { return AccountPermission; },\n    get AccountResourceLimit () { return AccountResourceLimit; },\n    get AccountTotalResources () { return AccountTotalResources; },\n    get AccountSelfDelegatedBandwidth () { return AccountSelfDelegatedBandwidth; },\n    get AccountRefundRequest () { return AccountRefundRequest; },\n    get AccountVoterInfo () { return AccountVoterInfo; },\n    get AccountRexInfoMaturities () { return AccountRexInfoMaturities; },\n    get AccountRexInfo () { return AccountRexInfo; },\n    get AccountObject () { return AccountObject; },\n    get NewProducersEntry () { return NewProducersEntry; },\n    get NewProducers () { return NewProducers; },\n    get BlockExtension () { return BlockExtension; },\n    get HeaderExtension () { return HeaderExtension; },\n    get GetBlockResponse () { return GetBlockResponse; },\n    get ActiveScheduleProducerAuthority () { return ActiveScheduleProducerAuthority; },\n    get ActiveScheduleProducer () { return ActiveScheduleProducer; },\n    get ActiveSchedule () { return ActiveSchedule; },\n    get BlockStateHeader () { return BlockStateHeader; },\n    get GetBlockHeaderStateResponse () { return GetBlockHeaderStateResponse; },\n    get GetInfoResponse () { return GetInfoResponse; }\n});\n\nclass ChainAPI {\n    constructor(client) {\n        this.client = client;\n    }\n    async get_abi(accountName) {\n        return this.client.call({\n            path: '/v1/chain/get_abi',\n            params: { account_name: Name.from(accountName) },\n        });\n    }\n    async get_account(accountName) {\n        return this.client.call({\n            path: '/v1/chain/get_account',\n            params: { account_name: Name.from(accountName) },\n            responseType: AccountObject,\n        });\n    }\n    async get_block(block_num_or_id) {\n        return this.client.call({\n            path: '/v1/chain/get_block',\n            params: { block_num_or_id },\n            responseType: GetBlockResponse,\n        });\n    }\n    async get_block_header_state(block_num_or_id) {\n        return this.client.call({\n            path: '/v1/chain/get_block_header_state',\n            params: { block_num_or_id },\n            responseType: GetBlockHeaderStateResponse,\n        });\n    }\n    async get_currency_balance(contract, accountName, symbol) {\n        const params = {\n            account: Name.from(accountName),\n            code: Name.from(contract),\n        };\n        if (symbol) {\n            params.symbol = symbol;\n        }\n        return this.client.call({\n            path: '/v1/chain/get_currency_balance',\n            params,\n            responseType: 'asset[]',\n        });\n    }\n    async get_info() {\n        return this.client.call({\n            path: '/v1/chain/get_info',\n            responseType: GetInfoResponse,\n        });\n    }\n    async push_transaction(tx) {\n        if (!isInstanceOf(tx, PackedTransaction)) {\n            tx = PackedTransaction.fromSigned(SignedTransaction.from(tx));\n        }\n        return this.client.call({\n            path: '/v1/chain/push_transaction',\n            params: tx,\n        });\n    }\n    async get_table_rows(params) {\n        const type = params.type;\n        let key_type = params.key_type;\n        const someBound = params.lower_bound || params.upper_bound;\n        if (!key_type && someBound) {\n            // determine key type from bounds type\n            if (isInstanceOf(someBound, Int64)) {\n                key_type = 'i64';\n            }\n            else if (isInstanceOf(someBound, Int128)) {\n                key_type = 'i128';\n            }\n            else if (isInstanceOf(someBound, Checksum256)) {\n                key_type = 'sha256';\n            }\n            else if (isInstanceOf(someBound, Checksum160)) {\n                key_type = 'ripemd160';\n            }\n        }\n        if (!key_type) {\n            key_type = 'name';\n        }\n        let json = params.json;\n        if (json === undefined) {\n            // if we know the row type don't ask the node to perform abi decoding\n            json = type === undefined;\n        }\n        let upper_bound = params.upper_bound;\n        if (upper_bound && typeof upper_bound !== 'string') {\n            upper_bound = String(upper_bound);\n        }\n        let lower_bound = params.lower_bound;\n        if (lower_bound && typeof lower_bound !== 'string') {\n            lower_bound = String(lower_bound);\n        }\n        let scope = params.scope;\n        if (typeof scope === 'undefined') {\n            scope = String(Name.from(params.code));\n        }\n        // eslint-disable-next-line prefer-const\n        let { rows, more, next_key } = await this.client.call({\n            path: '/v1/chain/get_table_rows',\n            params: {\n                code: Name.from(params.code),\n                table: Name.from(params.table),\n                limit: params.limit !== undefined ? UInt32.from(params.limit) : undefined,\n                scope,\n                key_type,\n                json,\n                upper_bound,\n                lower_bound,\n            },\n        });\n        if (type) {\n            if (json) {\n                rows = rows.map((value) => {\n                    if (typeof value === 'string' && Bytes.isBytes(value)) {\n                        // this handles the case where nodeos bails on abi decoding and just returns a hex string\n                        return Serializer.decode({ data: Bytes.from(value), type });\n                    }\n                    else {\n                        return Serializer.decode({ object: value, type });\n                    }\n                });\n            }\n            else {\n                rows = rows\n                    .map((hex) => Bytes.from(hex))\n                    .map((data) => Serializer.decode({ data, type }));\n            }\n        }\n        if (next_key && next_key.length > 0) {\n            let indexType;\n            // set index type so we can decode next_key in the response if present\n            switch (key_type) {\n                case 'i64':\n                    indexType = Int64;\n                    break;\n                case 'i128':\n                    indexType = Int128;\n                    break;\n                case 'name':\n                    indexType = Name;\n                    break;\n                case 'float64':\n                    indexType = Float64;\n                    break;\n                case 'float128':\n                    indexType = Float128;\n                    break;\n                case 'sha256':\n                    indexType = Checksum256;\n                    break;\n                case 'ripemd160':\n                    indexType = Checksum160;\n                    break;\n                default:\n                    throw new Error(`Unsupported key type: ${key_type}`);\n            }\n            if (indexType === Name) {\n                // names are sent back as an uint64 string instead of a name string..\n                next_key = Name.from(Serializer.decode({ object: next_key, type: UInt64 }));\n            }\n            else {\n                next_key = Serializer.decode({ object: next_key, type: indexType });\n            }\n        }\n        else {\n            next_key = undefined;\n        }\n        return { rows, more, next_key };\n    }\n}\n\nclass APIError extends Error {\n    constructor(path, error) {\n        super(`${APIError.formatError(error)} at ${path}`);\n        this.path = path;\n        this.error = error;\n    }\n    static formatError(error) {\n        if (error.what === 'unspecified' && error.details && error.details.length > 0) {\n            return error.details[0].message;\n        }\n        else if (error.what && error.what.length > 0) {\n            return error.what;\n        }\n        else {\n            return 'Unknown API error';\n        }\n    }\n    /** The nodeos error name, e.g. `tx_net_usage_exceeded` */\n    get name() {\n        return this.error.name || 'unspecified';\n    }\n    /** The nodeos error code, e.g. `3080002`. */\n    get code() {\n        return this.error.code || 0;\n    }\n    /** List of exceptions, if any. */\n    get details() {\n        return this.error.details;\n    }\n}\nAPIError.__className = 'APIError';\nclass APIClient {\n    constructor(options) {\n        this.v1 = {\n            chain: new ChainAPI(this),\n        };\n        if (options.provider) {\n            this.provider = options.provider;\n        }\n        else if (options.url) {\n            this.provider = new FetchProvider(options.url, options);\n        }\n        else {\n            throw new Error('Missing url or provider');\n        }\n    }\n    async call(args) {\n        const response = (await this.provider.call(args.path, args.params));\n        if (response.error) {\n            throw new APIError(args.path, response.error);\n        }\n        if (args.responseType) {\n            return abiDecode({ type: args.responseType, object: response });\n        }\n        return response;\n    }\n}\nAPIClient.__className = 'APIClient';\n\nvar types = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    v1: types$1\n});\n\nexport { ABI, ABIDecoder, ABIEncoder, types as API, APIClient, APIError, Action, Asset, Authority, Base58, BlockTimestamp, Bytes, Checksum160, Checksum256, Checksum512, CurveType, ExtendedAsset, FetchProvider, Float128, Float32, Float64, Int128, Int16, Int32, Int64, Int8, Name, PackedTransaction, PermissionLevel, PrivateKey, PublicKey, Serializer, Signature, SignedTransaction, Struct, TimePoint, TimePointSec, Transaction, TransactionExtension, TransactionHeader, TransactionReceipt, TypeAlias, UInt128, UInt16, UInt32, UInt64, UInt8, VarInt, VarUInt, Variant, isInstanceOf };\n//# sourceMappingURL=eosio-core.m.js.map\n"]},"metadata":{},"sourceType":"module"}