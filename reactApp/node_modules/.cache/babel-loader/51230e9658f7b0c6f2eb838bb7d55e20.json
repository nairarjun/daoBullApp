{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/turbo/devel/MyGame/contracts/decentralize-io-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"/home/turbo/devel/MyGame/contracts/decentralize-io-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"/home/turbo/devel/MyGame/contracts/decentralize-io-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _regeneratorRuntime from \"/home/turbo/devel/MyGame/contracts/decentralize-io-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/turbo/devel/MyGame/contracts/decentralize-io-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _createClass from \"/home/turbo/devel/MyGame/contracts/decentralize-io-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/home/turbo/devel/MyGame/contracts/decentralize-io-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _inherits from \"/home/turbo/devel/MyGame/contracts/decentralize-io-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/turbo/devel/MyGame/contracts/decentralize-io-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _wrapNativeSuper from \"/home/turbo/devel/MyGame/contracts/decentralize-io-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\n\n/**\n * Anchor Link v3.2.2\n * https://github.com/greymass/anchor-link\n *\n * @license\n * Copyright (c) 2020 Greymass Inc. All Rights Reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \n *  1. Redistribution of source code must retain the above copyright notice, this\n *     list of conditions and the following disclaimer.\n * \n *  2. Redistribution in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n * \n *  3. Neither the name of the copyright holder nor the names of its contributors\n *     may be used to endorse or promote products derived from this software without\n *     specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE\n * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.\n */\nimport zlib from 'pako';\nimport { Struct, UInt64, Checksum512, Serializer, Bytes, Checksum256, PermissionLevel, PublicKey, Name, PrivateKey, APIClient, Signature, SignedTransaction } from '@greymass/eosio';\nexport * from '@greymass/eosio';\nimport { ChainId, SigningRequest, ResolvedSigningRequest, PlaceholderName, PlaceholderPermission } from 'eosio-signing-request';\nexport * from 'eosio-signing-request';\nexport { ChainId, ChainName, IdentityProof } from 'eosio-signing-request';\nimport { __decorate } from 'tslib';\nimport makeFetch from 'fetch-ponyfill';\nimport { AES_CBC } from 'asmcrypto.js';\nimport { v4 } from 'uuid';\nimport WebSocket from 'isomorphic-ws';\n/**\n * Error that is thrown if a [[LinkTransport]] cancels a request.\n * @internal\n */\n\nvar CancelError = /*#__PURE__*/function (_Error) {\n  _inherits(CancelError, _Error);\n\n  var _super = _createSuper(CancelError);\n\n  function CancelError(reason) {\n    var _this;\n\n    _classCallCheck(this, CancelError);\n\n    _this = _super.call(this, \"User canceled request \".concat(reason ? '(' + reason + ')' : ''));\n    _this.code = 'E_CANCEL';\n    return _this;\n  }\n\n  return CancelError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\n * Error that is thrown if an identity request fails to verify.\n * @internal\n */\n\n\nvar IdentityError = /*#__PURE__*/function (_Error2) {\n  _inherits(IdentityError, _Error2);\n\n  var _super2 = _createSuper(IdentityError);\n\n  function IdentityError(reason) {\n    var _this2;\n\n    _classCallCheck(this, IdentityError);\n\n    _this2 = _super2.call(this, \"Unable to verify identity \".concat(reason ? '(' + reason + ')' : ''));\n    _this2.code = 'E_IDENTITY';\n    return _this2;\n  }\n\n  return IdentityError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\n * Error originating from a [[LinkSession]].\n * @internal\n */\n\n\nvar SessionError = /*#__PURE__*/function (_Error3) {\n  _inherits(SessionError, _Error3);\n\n  var _super3 = _createSuper(SessionError);\n\n  function SessionError(reason, code) {\n    var _this3;\n\n    _classCallCheck(this, SessionError);\n\n    _this3 = _super3.call(this, reason);\n    _this3.code = code;\n    return _this3;\n  }\n\n  return SessionError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/** @internal */\n\n\nvar LinkOptions;\n\n(function (LinkOptions) {\n  /** @internal */\n  LinkOptions.defaults = {\n    service: 'https://cb.anchor.link',\n    verifyProofs: false,\n    encodeChainIds: true\n  };\n})(LinkOptions || (LinkOptions = {}));\n\nvar SealedMessage = /*#__PURE__*/function (_Struct) {\n  _inherits(SealedMessage, _Struct);\n\n  var _super4 = _createSuper(SealedMessage);\n\n  function SealedMessage() {\n    _classCallCheck(this, SealedMessage);\n\n    return _super4.apply(this, arguments);\n  }\n\n  return SealedMessage;\n}(Struct);\n\n__decorate([Struct.field('public_key')], SealedMessage.prototype, \"from\", void 0);\n\n__decorate([Struct.field('uint64')], SealedMessage.prototype, \"nonce\", void 0);\n\n__decorate([Struct.field('bytes')], SealedMessage.prototype, \"ciphertext\", void 0);\n\n__decorate([Struct.field('uint32')], SealedMessage.prototype, \"checksum\", void 0);\n\nSealedMessage = __decorate([Struct.type('sealed_message')], SealedMessage);\n\nvar LinkCreate = /*#__PURE__*/function (_Struct2) {\n  _inherits(LinkCreate, _Struct2);\n\n  var _super5 = _createSuper(LinkCreate);\n\n  function LinkCreate() {\n    _classCallCheck(this, LinkCreate);\n\n    return _super5.apply(this, arguments);\n  }\n\n  return LinkCreate;\n}(Struct);\n\n__decorate([Struct.field('name')], LinkCreate.prototype, \"session_name\", void 0);\n\n__decorate([Struct.field('public_key')], LinkCreate.prototype, \"request_key\", void 0);\n\n__decorate([Struct.field('string', {\n  extension: true\n})], LinkCreate.prototype, \"user_agent\", void 0);\n\nLinkCreate = __decorate([Struct.type('link_create')], LinkCreate);\n\nvar LinkInfo = /*#__PURE__*/function (_Struct3) {\n  _inherits(LinkInfo, _Struct3);\n\n  var _super6 = _createSuper(LinkInfo);\n\n  function LinkInfo() {\n    _classCallCheck(this, LinkInfo);\n\n    return _super6.apply(this, arguments);\n  }\n\n  return LinkInfo;\n}(Struct);\n\n__decorate([Struct.field('time_point_sec')], LinkInfo.prototype, \"expiration\", void 0);\n\nLinkInfo = __decorate([Struct.type('link_info')], LinkInfo);\n/** @internal */\n\nvar fetch = makeFetch().fetch;\n/**\n * Encrypt a message using AES and shared secret derived from given keys.\n * @internal\n */\n\nfunction sealMessage(message, privateKey, publicKey, nonce) {\n  var secret = privateKey.sharedSecret(publicKey);\n\n  if (!nonce) {\n    nonce = UInt64.random();\n  }\n\n  var key = Checksum512.hash(Serializer.encode({\n    object: nonce\n  }).appending(secret.array));\n  var cbc = new AES_CBC(key.array.slice(0, 32), key.array.slice(32, 48));\n  var ciphertext = Bytes.from(cbc.encrypt(Bytes.from(message, 'utf8').array));\n  var checksumView = new DataView(Checksum256.hash(key.array).array.buffer);\n  var checksum = checksumView.getUint32(0, true);\n  return SealedMessage.from({\n    from: privateKey.toPublic(),\n    nonce: nonce,\n    ciphertext: ciphertext,\n    checksum: checksum\n  });\n}\n/**\n * Type describing a link session that can create a eosjs compatible\n * signature provider and transact for a specific auth.\n */\n\n\nvar LinkSession = /*#__PURE__*/function () {\n  /** @internal */\n  function LinkSession() {\n    _classCallCheck(this, LinkSession);\n  } // eslint-disable-line @typescript-eslint/no-empty-function\n\n  /**\n   * Convenience, remove this session from associated [[Link]] storage if set.\n   * Equivalent to:\n   * ```ts\n   * session.link.removeSession(session.identifier, session.auth, session.chainId)\n   * ```\n   */\n\n\n  _createClass(LinkSession, [{\n    key: \"remove\",\n    value: function () {\n      var _remove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.link.storage) {\n                  _context.next = 3;\n                  break;\n                }\n\n                _context.next = 3;\n                return this.link.removeSession(this.identifier, this.auth, this.chainId);\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function remove() {\n        return _remove.apply(this, arguments);\n      }\n\n      return remove;\n    }()\n    /** API client for the chain this session is valid on. */\n\n  }, {\n    key: \"client\",\n    get: function get() {\n      return this.link.getChain(this.chainId).client;\n    }\n    /** Restore a previously serialized session. */\n\n  }], [{\n    key: \"restore\",\n    value: function restore(link, data) {\n      switch (data.type) {\n        case 'channel':\n          return new LinkChannelSession(link, data.data, data.metadata);\n\n        case 'fallback':\n          return new LinkFallbackSession(link, data.data, data.metadata);\n\n        default:\n          throw new Error('Unable to restore, session data invalid');\n      }\n    }\n  }]);\n\n  return LinkSession;\n}();\n/**\n * Link session that pushes requests over a channel.\n * @internal\n */\n\n\nvar LinkChannelSession = /*#__PURE__*/function (_LinkSession) {\n  _inherits(LinkChannelSession, _LinkSession);\n\n  var _super7 = _createSuper(LinkChannelSession);\n\n  function LinkChannelSession(link, data, metadata) {\n    var _this4;\n\n    _classCallCheck(this, LinkChannelSession);\n\n    _this4 = _super7.call(this);\n    _this4.type = 'channel';\n    _this4.timeout = 2 * 60 * 1000; // ms\n\n    _this4.link = link;\n    _this4.chainId = ChainId.from(data.chainId);\n    _this4.auth = PermissionLevel.from(data.auth);\n    _this4.publicKey = PublicKey.from(data.publicKey);\n    _this4.channel = data.channel;\n    _this4.identifier = Name.from(data.identifier);\n    var privateKey = PrivateKey.from(data.requestKey);\n    var publicKey = PublicKey.from(data.channel.key);\n\n    _this4.encrypt = function (request) {\n      return sealMessage(request.encode(true, false), privateKey, publicKey);\n    };\n\n    _this4.metadata = _objectSpread(_objectSpread({}, metadata || {}), {}, {\n      timeout: _this4.timeout,\n      name: _this4.channel.name\n    });\n\n    _this4.serialize = function () {\n      return {\n        type: 'channel',\n        data: data,\n        metadata: _this4.metadata\n      };\n    };\n\n    return _this4;\n  }\n\n  _createClass(LinkChannelSession, [{\n    key: \"onSuccess\",\n    value: function onSuccess(request, result) {\n      if (this.link.transport.onSuccess) {\n        this.link.transport.onSuccess(request, result);\n      }\n    }\n  }, {\n    key: \"onFailure\",\n    value: function onFailure(request, error) {\n      if (this.link.transport.onFailure) {\n        this.link.transport.onFailure(request, error);\n      }\n    }\n  }, {\n    key: \"onRequest\",\n    value: function onRequest(request, cancel) {\n      var info = LinkInfo.from({\n        expiration: new Date(Date.now() + this.timeout).toISOString().slice(0, -1)\n      });\n\n      if (this.link.transport.onSessionRequest) {\n        this.link.transport.onSessionRequest(this, request, cancel);\n      }\n\n      setTimeout(function () {\n        cancel(new SessionError('Wallet did not respond in time', 'E_TIMEOUT'));\n      }, this.timeout + 500);\n      request.setInfoKey('link', info);\n      var payloadSent = false;\n      var payload = Serializer.encode({\n        object: this.encrypt(request)\n      });\n\n      if (this.link.transport.sendSessionPayload) {\n        try {\n          payloadSent = this.link.transport.sendSessionPayload(payload, this);\n        } catch (error) {\n          // eslint-disable-next-line no-console\n          console.warn('Unexpected error when transport tried to send session payload', error);\n        }\n      }\n\n      if (payloadSent) {\n        return;\n      }\n\n      fetch(this.channel.url, {\n        method: 'POST',\n        headers: {\n          'X-Buoy-Wait': (this.timeout / 1000).toFixed(0)\n        },\n        body: payload.array\n      }).then(function (response) {\n        if (response.status !== 200) {\n          cancel(new SessionError('Unable to push message', 'E_DELIVERY'));\n        }\n      }).catch(function (error) {\n        cancel(new SessionError(\"Unable to reach link service (\".concat(error.message || String(error), \")\"), 'E_DELIVERY'));\n      });\n    }\n  }, {\n    key: \"prepare\",\n    value: function prepare(request) {\n      if (this.link.transport.prepare) {\n        return this.link.transport.prepare(request, this);\n      }\n\n      return Promise.resolve(request);\n    }\n  }, {\n    key: \"showLoading\",\n    value: function showLoading() {\n      if (this.link.transport.showLoading) {\n        return this.link.transport.showLoading();\n      }\n    }\n  }, {\n    key: \"makeSignatureProvider\",\n    value: function makeSignatureProvider() {\n      return this.link.makeSignatureProvider([this.publicKey.toString()], this.chainId, this);\n    }\n  }, {\n    key: \"transact\",\n    value: function transact(args, options) {\n      return this.link.transact(args, _objectSpread(_objectSpread({}, options), {}, {\n        chain: this.chainId\n      }), this);\n    }\n  }]);\n\n  return LinkChannelSession;\n}(LinkSession);\n/**\n * Link session that sends every request over the transport.\n * @internal\n */\n\n\nvar LinkFallbackSession = /*#__PURE__*/function (_LinkSession2) {\n  _inherits(LinkFallbackSession, _LinkSession2);\n\n  var _super8 = _createSuper(LinkFallbackSession);\n\n  function LinkFallbackSession(link, data, metadata) {\n    var _this5;\n\n    _classCallCheck(this, LinkFallbackSession);\n\n    _this5 = _super8.call(this);\n    _this5.type = 'fallback';\n    _this5.link = link;\n    _this5.auth = PermissionLevel.from(data.auth);\n    _this5.publicKey = PublicKey.from(data.publicKey);\n    _this5.chainId = ChainId.from(data.chainId);\n    _this5.metadata = metadata || {};\n    _this5.identifier = Name.from(data.identifier);\n\n    _this5.serialize = function () {\n      return {\n        type: _this5.type,\n        data: data,\n        metadata: _this5.metadata\n      };\n    };\n\n    return _this5;\n  }\n\n  _createClass(LinkFallbackSession, [{\n    key: \"onSuccess\",\n    value: function onSuccess(request, result) {\n      if (this.link.transport.onSuccess) {\n        this.link.transport.onSuccess(request, result);\n      }\n    }\n  }, {\n    key: \"onFailure\",\n    value: function onFailure(request, error) {\n      if (this.link.transport.onFailure) {\n        this.link.transport.onFailure(request, error);\n      }\n    }\n  }, {\n    key: \"onRequest\",\n    value: function onRequest(request, cancel) {\n      if (this.link.transport.onSessionRequest) {\n        this.link.transport.onSessionRequest(this, request, cancel);\n      } else {\n        this.link.transport.onRequest(request, cancel);\n      }\n    }\n  }, {\n    key: \"prepare\",\n    value: function prepare(request) {\n      if (this.link.transport.prepare) {\n        return this.link.transport.prepare(request, this);\n      }\n\n      return Promise.resolve(request);\n    }\n  }, {\n    key: \"showLoading\",\n    value: function showLoading() {\n      if (this.link.transport.showLoading) {\n        return this.link.transport.showLoading();\n      }\n    }\n  }, {\n    key: \"makeSignatureProvider\",\n    value: function makeSignatureProvider() {\n      return this.link.makeSignatureProvider([this.publicKey.toString()], this.chainId, this);\n    }\n  }, {\n    key: \"transact\",\n    value: function transact(args, options) {\n      return this.link.transact(args, _objectSpread(_objectSpread({}, options), {}, {\n        chain: this.chainId\n      }), this);\n    }\n  }]);\n\n  return LinkFallbackSession;\n}(LinkSession);\n/** @internal */\n\n\nvar BuoyCallbackService = /*#__PURE__*/function () {\n  function BuoyCallbackService(address) {\n    _classCallCheck(this, BuoyCallbackService);\n\n    this.address = address.trim().replace(/\\/$/, '');\n  }\n\n  _createClass(BuoyCallbackService, [{\n    key: \"create\",\n    value: function create() {\n      var url = \"\".concat(this.address, \"/\").concat(v4());\n      return new BuoyCallback(url);\n    }\n  }]);\n\n  return BuoyCallbackService;\n}();\n/** @internal */\n\n\nvar BuoyCallback = /*#__PURE__*/function () {\n  function BuoyCallback(url) {\n    _classCallCheck(this, BuoyCallback);\n\n    this.url = url;\n    this.ctx = {};\n  }\n\n  _createClass(BuoyCallback, [{\n    key: \"wait\",\n    value: function wait() {\n      if (this.url.includes('hyperbuoy')) {\n        return pollForCallback(this.url, this.ctx);\n      } else {\n        return waitForCallback(this.url, this.ctx);\n      }\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (this.ctx.cancel) {\n        this.ctx.cancel();\n      }\n    }\n  }]);\n\n  return BuoyCallback;\n}();\n/**\n * Connect to a WebSocket channel and wait for a message.\n * @internal\n */\n\n\nfunction waitForCallback(url, ctx) {\n  return new Promise(function (resolve, reject) {\n    var active = true;\n    var retries = 0;\n    var socketUrl = url.replace(/^http/, 'ws');\n\n    var handleResponse = function handleResponse(response) {\n      try {\n        resolve(JSON.parse(response));\n      } catch (error) {\n        error.message = 'Unable to parse callback JSON: ' + error.message;\n        reject(error);\n      }\n    };\n\n    var connect = function connect() {\n      var socket = new WebSocket(socketUrl);\n\n      ctx.cancel = function () {\n        active = false;\n\n        if (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING) {\n          socket.close();\n        }\n      };\n\n      socket.onmessage = function (event) {\n        active = false;\n\n        if (socket.readyState === WebSocket.OPEN) {\n          socket.close();\n        }\n\n        if (typeof Blob !== 'undefined' && event.data instanceof Blob) {\n          var reader = new FileReader();\n\n          reader.onload = function () {\n            handleResponse(reader.result);\n          };\n\n          reader.onerror = function (error) {\n            reject(error);\n          };\n\n          reader.readAsText(event.data);\n        } else {\n          if (typeof event.data === 'string') {\n            handleResponse(event.data);\n          } else {\n            handleResponse(event.data.toString());\n          }\n        }\n      };\n\n      socket.onopen = function () {\n        retries = 0;\n      };\n\n      socket.onclose = function () {\n        if (active) {\n          setTimeout(connect, backoff(retries++));\n        }\n      };\n    };\n\n    connect();\n  });\n}\n/**\n * Long-poll for message.\n * @internal\n */\n\n\nfunction pollForCallback(_x, _x2) {\n  return _pollForCallback.apply(this, arguments);\n}\n/**\n * Exponential backoff function that caps off at 10s after 10 tries.\n * https://i.imgur.com/IrUDcJp.png\n * @internal\n */\n\n\nfunction _pollForCallback() {\n  _pollForCallback = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(url, ctx) {\n    var active, res;\n    return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n      while (1) {\n        switch (_context16.prev = _context16.next) {\n          case 0:\n            active = true;\n\n            ctx.cancel = function () {\n              active = false;\n            };\n\n          case 2:\n            if (!active) {\n              _context16.next = 27;\n              break;\n            }\n\n            _context16.prev = 3;\n            _context16.next = 6;\n            return fetch(url);\n\n          case 6:\n            res = _context16.sent;\n\n            if (!(res.status === 408)) {\n              _context16.next = 11;\n              break;\n            }\n\n            return _context16.abrupt(\"continue\", 2);\n\n          case 11:\n            if (!(res.status === 200)) {\n              _context16.next = 17;\n              break;\n            }\n\n            _context16.next = 14;\n            return res.json();\n\n          case 14:\n            return _context16.abrupt(\"return\", _context16.sent);\n\n          case 17:\n            throw new Error(\"HTTP \".concat(res.status, \": \").concat(res.statusText));\n\n          case 18:\n            _context16.next = 23;\n            break;\n\n          case 20:\n            _context16.prev = 20;\n            _context16.t0 = _context16[\"catch\"](3);\n            // eslint-disable-next-line no-console\n            console.warn('Unexpected hyperbuoy error', _context16.t0);\n\n          case 23:\n            _context16.next = 25;\n            return sleep(1000);\n\n          case 25:\n            _context16.next = 2;\n            break;\n\n          case 27:\n            return _context16.abrupt(\"return\", null);\n\n          case 28:\n          case \"end\":\n            return _context16.stop();\n        }\n      }\n    }, _callee16, null, [[3, 20]]);\n  }));\n  return _pollForCallback.apply(this, arguments);\n}\n\nfunction backoff(tries) {\n  return Math.min(Math.pow(tries * 10, 2), 10 * 1000);\n}\n/**\n * Return promise that resolves after given milliseconds.\n * @internal\n */\n\n\nfunction sleep(ms) {\n  return new Promise(function (resolve) {\n    setTimeout(resolve, ms);\n  });\n}\n/**\n * Class representing a EOSIO chain.\n */\n\n\nvar LinkChain = /*#__PURE__*/function () {\n  /** @internal */\n  function LinkChain(chainId, clientOrUrl) {\n    _classCallCheck(this, LinkChain);\n\n    this.abiCache = new Map();\n    this.pendingAbis = new Map();\n    this.chainId = ChainId.from(chainId);\n    this.client = typeof clientOrUrl === 'string' ? new APIClient({\n      url: clientOrUrl\n    }) : clientOrUrl;\n  }\n  /**\n   * Fetch the ABI for given account, cached.\n   * @internal\n   */\n\n\n  _createClass(LinkChain, [{\n    key: \"getAbi\",\n    value: function () {\n      var _getAbi = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(account) {\n        var key, rv, _getAbi2;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                key = String(account);\n                rv = this.abiCache.get(key);\n\n                if (rv) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                _getAbi2 = this.pendingAbis.get(key);\n\n                if (!_getAbi2) {\n                  _getAbi2 = this.client.v1.chain.get_abi(account);\n                  this.pendingAbis.set(key, _getAbi2);\n                }\n\n                _context2.next = 7;\n                return _getAbi2;\n\n              case 7:\n                rv = _context2.sent.abi;\n                this.pendingAbis.delete(key);\n\n                if (rv) {\n                  this.abiCache.set(key, rv);\n                }\n\n              case 10:\n                return _context2.abrupt(\"return\", rv);\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getAbi(_x3) {\n        return _getAbi.apply(this, arguments);\n      }\n\n      return getAbi;\n    }()\n  }]);\n\n  return LinkChain;\n}();\n/**\n * Anchor Link main class.\n *\n * @example\n *\n * ```ts\n * import AnchorLink from 'anchor-link'\n * import ConsoleTransport from 'anchor-link-console-transport'\n *\n * const link = new AnchorLink({\n *     transport: new ConsoleTransport(),\n *     chains: [\n *         {\n *             chainId: 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906',\n *             nodeUrl: 'https://eos.greymass.com',\n *         },\n *     ],\n * })\n *\n * const result = await link.transact({actions: myActions})\n * ```\n */\n\n\nvar Link = /*#__PURE__*/function () {\n  /** Create a new link instance. */\n  function Link(options) {\n    _classCallCheck(this, Link);\n\n    if (typeof options !== 'object') {\n      throw new TypeError('Missing options object');\n    }\n\n    if (!options.transport) {\n      throw new TypeError('options.transport is required');\n    }\n\n    var chains = options.chains || [];\n\n    if (options.chainId && options.client) {\n      chains = [{\n        chainId: options.chainId,\n        nodeUrl: options.client\n      }];\n    }\n\n    if (chains.length === 0) {\n      throw new TypeError('options.chains is required');\n    }\n\n    this.chains = chains.map(function (_ref) {\n      var chainId = _ref.chainId,\n          nodeUrl = _ref.nodeUrl;\n\n      if (!chainId) {\n        throw new Error('options.chains[].chainId is required');\n      }\n\n      if (!nodeUrl) {\n        throw new Error('options.chains[].nodeUrl is required');\n      }\n\n      return new LinkChain(chainId, nodeUrl);\n    });\n\n    if (options.service === undefined || typeof options.service === 'string') {\n      this.callbackService = new BuoyCallbackService(options.service || LinkOptions.defaults.service);\n    } else {\n      this.callbackService = options.service;\n    }\n\n    this.transport = options.transport;\n\n    if (options.storage !== null) {\n      this.storage = options.storage || this.transport.storage;\n    }\n\n    this.verifyProofs = options.verifyProofs !== undefined ? options.verifyProofs : LinkOptions.defaults.verifyProofs;\n    this.encodeChainIds = options.encodeChainIds !== undefined ? options.encodeChainIds : LinkOptions.defaults.encodeChainIds;\n  }\n  /**\n   * The APIClient instance for communicating with the node.\n   * @note This returns the first APIClient when link is configured with multiple chains.\n   */\n\n\n  _createClass(Link, [{\n    key: \"client\",\n    get: function get() {\n      return this.chains[0].client;\n    }\n    /**\n     * Return a [[LinkChain]] object for given chainId or chain reference.\n     * @throws If this link instance has no configured chain for given reference.\n     * @internal\n     */\n\n  }, {\n    key: \"getChain\",\n    value: function getChain(chain) {\n      if (chain instanceof LinkChain) {\n        return chain;\n      }\n\n      if (typeof chain === 'number') {\n        var _rv = this.chains[chain];\n\n        if (!_rv) {\n          throw new Error(\"Invalid chain index: \".concat(chain));\n        }\n\n        return _rv;\n      }\n\n      var id = ChainId.from(chain);\n      var rv = this.chains.find(function (c) {\n        return c.chainId.equals(id);\n      });\n\n      if (!rv) {\n        throw new Error(\"Unsupported chain: \".concat(id));\n      }\n\n      return rv;\n    }\n    /**\n     * Create a SigningRequest instance configured for this link.\n     * @internal\n     */\n\n  }, {\n    key: \"createRequest\",\n    value: function () {\n      var _createRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(args, chain, transport) {\n        var t, request, c, callback;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                t = transport || this.transport;\n\n                if (!(chain || this.chains.length === 1)) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                c = chain || this.chains[0];\n                _context3.next = 5;\n                return SigningRequest.create(_objectSpread(_objectSpread({}, args), {}, {\n                  chainId: c.chainId,\n                  broadcast: false\n                }), {\n                  abiProvider: c,\n                  zlib: zlib\n                });\n\n              case 5:\n                request = _context3.sent;\n                _context3.next = 11;\n                break;\n\n              case 8:\n                _context3.next = 10;\n                return SigningRequest.create(_objectSpread(_objectSpread({}, args), {}, {\n                  chainId: null,\n                  chainIds: this.encodeChainIds ? this.chains.map(function (c) {\n                    return c.chainId;\n                  }) : undefined,\n                  broadcast: false\n                }), // abi's will be pulled from the first chain and assumed to be identical on all chains\n                {\n                  abiProvider: this.chains[0],\n                  zlib: zlib\n                });\n\n              case 10:\n                request = _context3.sent;\n\n              case 11:\n                if (!t.prepare) {\n                  _context3.next = 15;\n                  break;\n                }\n\n                _context3.next = 14;\n                return t.prepare(request);\n\n              case 14:\n                request = _context3.sent;\n\n              case 15:\n                callback = this.callbackService.create();\n                request.setCallback(callback.url, true);\n                return _context3.abrupt(\"return\", {\n                  request: request,\n                  callback: callback\n                });\n\n              case 18:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function createRequest(_x4, _x5, _x6) {\n        return _createRequest.apply(this, arguments);\n      }\n\n      return createRequest;\n    }()\n    /**\n     * Send a SigningRequest instance using this link.\n     * @internal\n     */\n\n  }, {\n    key: \"sendRequest\",\n    value: function () {\n      var _sendRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(request, callback, chain, transport) {\n        var broadcast,\n            t,\n            linkUrl,\n            cancel,\n            callbackResponse,\n            payload,\n            signer,\n            signatures,\n            c,\n            resolved,\n            cosignerSig,\n            result,\n            signedTx,\n            res,\n            _args4 = arguments;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                broadcast = _args4.length > 4 && _args4[4] !== undefined ? _args4[4] : false;\n                t = transport || this.transport;\n                _context4.prev = 2;\n                linkUrl = request.data.callback;\n\n                if (!(linkUrl !== callback.url)) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                throw new Error('Invalid request callback');\n\n              case 6:\n                if (!(request.data.flags.broadcast === true || request.data.flags.background === false)) {\n                  _context4.next = 8;\n                  break;\n                }\n\n                throw new Error('Invalid request flags');\n\n              case 8:\n                // wait for callback or user cancel\n                cancel = new Promise(function (resolve, reject) {\n                  t.onRequest(request, function (reason) {\n                    callback.cancel();\n\n                    if (typeof reason === 'string') {\n                      reject(new CancelError(reason));\n                    } else {\n                      reject(reason);\n                    }\n                  });\n                });\n                _context4.next = 11;\n                return Promise.race([callback.wait(), cancel]);\n\n              case 11:\n                callbackResponse = _context4.sent;\n\n                if (!(typeof callbackResponse.rejected === 'string')) {\n                  _context4.next = 14;\n                  break;\n                }\n\n                throw new CancelError(callbackResponse.rejected);\n\n              case 14:\n                payload = callbackResponse;\n                signer = PermissionLevel.from({\n                  actor: payload.sa,\n                  permission: payload.sp\n                });\n                signatures = Object.keys(payload).filter(function (key) {\n                  return key.startsWith('sig') && key !== 'sig0';\n                }).map(function (key) {\n                  return Signature.from(payload[key]);\n                });\n\n                if (!(!chain && this.chains.length > 1)) {\n                  _context4.next = 23;\n                  break;\n                }\n\n                if (payload.cid) {\n                  _context4.next = 20;\n                  break;\n                }\n\n                throw new Error('Multi chain response payload must specify resolved chain id (cid)');\n\n              case 20:\n                c = this.getChain(payload.cid);\n                _context4.next = 26;\n                break;\n\n              case 23:\n                c = chain || this.getChain(0);\n\n                if (!(payload.cid && !c.chainId.equals(payload.cid))) {\n                  _context4.next = 26;\n                  break;\n                }\n\n                throw new Error('Got response for wrong chain id');\n\n              case 26:\n                _context4.next = 28;\n                return ResolvedSigningRequest.fromPayload(payload, {\n                  zlib: zlib,\n                  abiProvider: c\n                });\n\n              case 28:\n                resolved = _context4.sent;\n                // prepend cosigner signature if present\n                cosignerSig = resolved.request.getInfoKey('cosig', {\n                  type: Signature,\n                  array: true\n                });\n\n                if (cosignerSig) {\n                  signatures.unshift.apply(signatures, _toConsumableArray(cosignerSig));\n                }\n\n                result = {\n                  resolved: resolved,\n                  chain: c,\n                  transaction: resolved.transaction,\n                  resolvedTransaction: resolved.resolvedTransaction,\n                  signatures: signatures,\n                  payload: payload,\n                  signer: signer\n                };\n\n                if (!broadcast) {\n                  _context4.next = 38;\n                  break;\n                }\n\n                signedTx = SignedTransaction.from(_objectSpread(_objectSpread({}, resolved.transaction), {}, {\n                  signatures: signatures\n                }));\n                _context4.next = 36;\n                return c.client.v1.chain.push_transaction(signedTx);\n\n              case 36:\n                res = _context4.sent;\n                result.processed = res.processed;\n\n              case 38:\n                if (t.onSuccess) {\n                  t.onSuccess(request, result);\n                }\n\n                return _context4.abrupt(\"return\", result);\n\n              case 42:\n                _context4.prev = 42;\n                _context4.t0 = _context4[\"catch\"](2);\n\n                if (t.onFailure) {\n                  t.onFailure(request, _context4.t0);\n                }\n\n                throw _context4.t0;\n\n              case 46:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[2, 42]]);\n      }));\n\n      function sendRequest(_x7, _x8, _x9, _x10) {\n        return _sendRequest.apply(this, arguments);\n      }\n\n      return sendRequest;\n    }()\n    /**\n     * Sign and optionally broadcast a EOSIO transaction, action or actions.\n     *\n     * Example:\n     *\n     * ```ts\n     * let result = await myLink.transact({transaction: myTx})\n     * ```\n     *\n     * @param args The action, actions or transaction to use.\n     * @param options Options for this transact call.\n     * @param transport Transport override, for internal use.\n     */\n\n  }, {\n    key: \"transact\",\n    value: function () {\n      var _transact = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(args, options, transport) {\n        var o, t, c, broadcast, noModify, anyArgs, _yield$this$createReq, request, callback, result;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                o = options || {};\n                t = transport || this.transport;\n                c = o.chain !== undefined ? this.getChain(o.chain) : undefined;\n                broadcast = o.broadcast !== false;\n                noModify = o.noModify !== undefined ? o.noModify : !broadcast; // Initialize the loading state of the transport\n\n                if (t && t.showLoading) {\n                  t.showLoading();\n                } // eosjs transact compat: upgrade to transaction if args have any header fields\n\n\n                anyArgs = args;\n\n                if (args.actions && (anyArgs.expiration || anyArgs.ref_block_num || anyArgs.ref_block_prefix || anyArgs.max_net_usage_words || anyArgs.max_cpu_usage_ms || anyArgs.delay_sec)) {\n                  args = {\n                    transaction: _objectSpread({\n                      expiration: '1970-01-01T00:00:00',\n                      ref_block_num: 0,\n                      ref_block_prefix: 0,\n                      max_net_usage_words: 0,\n                      max_cpu_usage_ms: 0,\n                      delay_sec: 0\n                    }, anyArgs)\n                  };\n                }\n\n                _context5.next = 10;\n                return this.createRequest(args, c, t);\n\n              case 10:\n                _yield$this$createReq = _context5.sent;\n                request = _yield$this$createReq.request;\n                callback = _yield$this$createReq.callback;\n\n                if (noModify) {\n                  request.setInfoKey('no_modify', true, 'bool');\n                }\n\n                _context5.next = 16;\n                return this.sendRequest(request, callback, c, t, broadcast);\n\n              case 16:\n                result = _context5.sent;\n                return _context5.abrupt(\"return\", result);\n\n              case 18:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function transact(_x11, _x12, _x13) {\n        return _transact.apply(this, arguments);\n      }\n\n      return transact;\n    }()\n    /**\n     * Send an identity request and verify the identity proof if [[LinkOptions.verifyProofs]] is true.\n     * @param args.scope The scope of the identity request.\n     * @param args.requestPermission Optional request permission if the request is for a specific account or permission.\n     * @param args.info Metadata to add to the request.\n     * @note This is for advanced use-cases, you probably want to use [[Link.login]] instead.\n     */\n\n  }, {\n    key: \"identify\",\n    value: function () {\n      var _identify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(args) {\n        var _yield$this$createReq2, request, callback, res, account, proof, accountPermission, proofValid, perm;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.createRequest({\n                  identity: {\n                    permission: args.requestPermission,\n                    scope: args.scope\n                  },\n                  info: args.info\n                });\n\n              case 2:\n                _yield$this$createReq2 = _context6.sent;\n                request = _yield$this$createReq2.request;\n                callback = _yield$this$createReq2.callback;\n                _context6.next = 7;\n                return this.sendRequest(request, callback);\n\n              case 7:\n                res = _context6.sent;\n\n                if (res.resolved.request.isIdentity()) {\n                  _context6.next = 10;\n                  break;\n                }\n\n                throw new IdentityError('Unexpected response');\n\n              case 10:\n                proof = res.resolved.getIdentityProof(res.signatures[0]);\n\n                if (!this.verifyProofs) {\n                  _context6.next = 23;\n                  break;\n                }\n\n                _context6.next = 14;\n                return res.chain.client.v1.chain.get_account(res.signer.actor);\n\n              case 14:\n                account = _context6.sent;\n\n                if (account) {\n                  _context6.next = 17;\n                  break;\n                }\n\n                throw new IdentityError(\"Signature from unknown account: \".concat(proof.signer.actor));\n\n              case 17:\n                accountPermission = account.permissions.find(function (_ref2) {\n                  var perm_name = _ref2.perm_name;\n                  return proof.signer.permission.equals(perm_name);\n                });\n\n                if (accountPermission) {\n                  _context6.next = 20;\n                  break;\n                }\n\n                throw new IdentityError(\"\".concat(proof.signer.actor, \" signed for unknown permission: \").concat(proof.signer.permission));\n\n              case 20:\n                proofValid = proof.verify(accountPermission.required_auth, account.head_block_time);\n\n                if (proofValid) {\n                  _context6.next = 23;\n                  break;\n                }\n\n                throw new IdentityError(\"Invalid identify proof for: \".concat(proof.signer));\n\n              case 23:\n                if (!args.requestPermission) {\n                  _context6.next = 27;\n                  break;\n                }\n\n                perm = PermissionLevel.from(args.requestPermission);\n\n                if (!(!perm.actor.equals(PlaceholderName) && !perm.actor.equals(proof.signer.actor) || !perm.permission.equals(PlaceholderPermission) && !perm.permission.equals(proof.signer.permission))) {\n                  _context6.next = 27;\n                  break;\n                }\n\n                throw new IdentityError(\"Identity proof singed by \".concat(proof.signer, \", expected: \").concat(formatAuth(perm), \" \"));\n\n              case 27:\n                return _context6.abrupt(\"return\", _objectSpread(_objectSpread({}, res), {}, {\n                  account: account,\n                  proof: proof\n                }));\n\n              case 28:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function identify(_x14) {\n        return _identify.apply(this, arguments);\n      }\n\n      return identify;\n    }()\n    /**\n     * Login and create a persistent session.\n     * @param identifier The session identifier, an EOSIO name (`[a-z1-5]{1,12}`).\n     *                   Should be set to the contract account if applicable.\n     */\n\n  }, {\n    key: \"login\",\n    value: function () {\n      var _login = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(identifier) {\n        var privateKey, requestKey, createInfo, res, metadata, parsed, _i, _Object$keys, key, signerKey, session;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                privateKey = PrivateKey.generate('K1');\n                requestKey = privateKey.toPublic();\n                createInfo = LinkCreate.from({\n                  session_name: identifier,\n                  request_key: requestKey,\n                  user_agent: this.getUserAgent()\n                });\n                _context7.next = 5;\n                return this.identify({\n                  scope: identifier,\n                  info: {\n                    link: createInfo,\n                    scope: identifier\n                  }\n                });\n\n              case 5:\n                res = _context7.sent;\n                metadata = {\n                  // backwards compat, can be removed next major release\n                  sameDevice: res.resolved.request.getRawInfo()['return_path'] !== undefined\n                }; // append extra metadata from the signer\n\n                if (res.payload.link_meta) {\n                  try {\n                    parsed = JSON.parse(res.payload.link_meta);\n\n                    for (_i = 0, _Object$keys = Object.keys(parsed); _i < _Object$keys.length; _i++) {\n                      key = _Object$keys[_i];\n                      // normalize key names to camelCase\n                      metadata[snakeToCamel(key)] = parsed[key];\n                    }\n                  } catch (error) {\n                    // eslint-disable-next-line no-console\n                    console.warn('Unable to parse link metadata', error, res.payload.link_meta);\n                  }\n                }\n\n                signerKey = res.proof.recover();\n\n                if (res.payload.link_ch && res.payload.link_key && res.payload.link_name) {\n                  session = new LinkChannelSession(this, {\n                    identifier: identifier,\n                    chainId: res.chain.chainId,\n                    auth: res.signer,\n                    publicKey: signerKey,\n                    channel: {\n                      url: res.payload.link_ch,\n                      key: res.payload.link_key,\n                      name: res.payload.link_name\n                    },\n                    requestKey: privateKey\n                  }, metadata);\n                } else {\n                  session = new LinkFallbackSession(this, {\n                    identifier: identifier,\n                    chainId: res.chain.chainId,\n                    auth: res.signer,\n                    publicKey: signerKey\n                  }, metadata);\n                }\n\n                if (!this.storage) {\n                  _context7.next = 13;\n                  break;\n                }\n\n                _context7.next = 13;\n                return this.storeSession(identifier, session);\n\n              case 13:\n                return _context7.abrupt(\"return\", _objectSpread(_objectSpread({}, res), {}, {\n                  session: session\n                }));\n\n              case 14:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function login(_x15) {\n        return _login.apply(this, arguments);\n      }\n\n      return login;\n    }()\n    /**\n     * Restore previous session, use [[login]] to create a new session.\n     * @param identifier The session identifier, must be same as what was used when creating the session with [[login]].\n     * @param auth A specific session auth to restore, if omitted the most recently used session will be restored.\n     * @param chainId If given function will only consider that specific chain when restoring session.\n     * @returns A [[LinkSession]] instance or null if no session can be found.\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session data.\n     **/\n\n  }, {\n    key: \"restoreSession\",\n    value: function () {\n      var _restoreSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(identifier, auth, chainId) {\n        var key, list, id, latest, data, sessionData, session;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (this.storage) {\n                  _context8.next = 2;\n                  break;\n                }\n\n                throw new Error('Unable to restore session: No storage adapter configured');\n\n              case 2:\n                if (!(auth && chainId)) {\n                  _context8.next = 6;\n                  break;\n                }\n\n                // both auth and chain id given, we can look up on specific key\n                key = this.sessionKey(identifier, formatAuth(PermissionLevel.from(auth)), String(ChainId.from(chainId)));\n                _context8.next = 15;\n                break;\n\n              case 6:\n                _context8.next = 8;\n                return this.listSessions(identifier);\n\n              case 8:\n                list = _context8.sent;\n\n                if (auth) {\n                  list = list.filter(function (item) {\n                    return item.auth.equals(auth);\n                  });\n                }\n\n                if (chainId) {\n                  id = ChainId.from(chainId);\n                  list = list.filter(function (item) {\n                    return item.chainId.equals(id);\n                  });\n                }\n\n                latest = list[0];\n\n                if (latest) {\n                  _context8.next = 14;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", null);\n\n              case 14:\n                key = this.sessionKey(identifier, formatAuth(latest.auth), String(latest.chainId));\n\n              case 15:\n                _context8.next = 17;\n                return this.storage.read(key);\n\n              case 17:\n                data = _context8.sent;\n\n                if (data) {\n                  _context8.next = 20;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", null);\n\n              case 20:\n                _context8.prev = 20;\n                sessionData = JSON.parse(data);\n                _context8.next = 27;\n                break;\n\n              case 24:\n                _context8.prev = 24;\n                _context8.t0 = _context8[\"catch\"](20);\n                throw new Error(\"Unable to restore session: Stored JSON invalid (\".concat(_context8.t0.message || String(_context8.t0), \")\"));\n\n              case 27:\n                session = LinkSession.restore(this, sessionData);\n\n                if (!(auth || chainId)) {\n                  _context8.next = 31;\n                  break;\n                }\n\n                _context8.next = 31;\n                return this.touchSession(identifier, session.auth, session.chainId);\n\n              case 31:\n                return _context8.abrupt(\"return\", session);\n\n              case 32:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[20, 24]]);\n      }));\n\n      function restoreSession(_x16, _x17, _x18) {\n        return _restoreSession.apply(this, arguments);\n      }\n\n      return restoreSession;\n    }()\n    /**\n     * List stored session auths for given identifier.\n     * The most recently used session is at the top (index 0).\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session list.\n     **/\n\n  }, {\n    key: \"listSessions\",\n    value: function () {\n      var _listSessions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(identifier) {\n        var key, list;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (this.storage) {\n                  _context9.next = 2;\n                  break;\n                }\n\n                throw new Error('Unable to list sessions: No storage adapter configured');\n\n              case 2:\n                key = this.sessionKey(identifier, 'list');\n                _context9.prev = 3;\n                _context9.t0 = JSON;\n                _context9.next = 7;\n                return this.storage.read(key);\n\n              case 7:\n                _context9.t1 = _context9.sent;\n\n                if (_context9.t1) {\n                  _context9.next = 10;\n                  break;\n                }\n\n                _context9.t1 = '[]';\n\n              case 10:\n                _context9.t2 = _context9.t1;\n                list = _context9.t0.parse.call(_context9.t0, _context9.t2);\n                _context9.next = 17;\n                break;\n\n              case 14:\n                _context9.prev = 14;\n                _context9.t3 = _context9[\"catch\"](3);\n                throw new Error(\"Unable to list sessions: \".concat(_context9.t3.message || String(_context9.t3)));\n\n              case 17:\n                return _context9.abrupt(\"return\", list.map(function (_ref3) {\n                  var auth = _ref3.auth,\n                      chainId = _ref3.chainId;\n                  return {\n                    auth: PermissionLevel.from(auth),\n                    chainId: ChainId.from(chainId)\n                  };\n                }));\n\n              case 18:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[3, 14]]);\n      }));\n\n      function listSessions(_x19) {\n        return _listSessions.apply(this, arguments);\n      }\n\n      return listSessions;\n    }()\n    /**\n     * Remove stored session for given identifier and auth.\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.\n     */\n\n  }, {\n    key: \"removeSession\",\n    value: function () {\n      var _removeSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(identifier, auth, chainId) {\n        var key;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (this.storage) {\n                  _context10.next = 2;\n                  break;\n                }\n\n                throw new Error('Unable to remove session: No storage adapter configured');\n\n              case 2:\n                key = this.sessionKey(identifier, formatAuth(auth), String(chainId));\n                _context10.next = 5;\n                return this.storage.remove(key);\n\n              case 5:\n                _context10.next = 7;\n                return this.touchSession(identifier, auth, chainId, true);\n\n              case 7:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function removeSession(_x20, _x21, _x22) {\n        return _removeSession.apply(this, arguments);\n      }\n\n      return removeSession;\n    }()\n    /**\n     * Remove all stored sessions for given identifier.\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.\n     */\n\n  }, {\n    key: \"clearSessions\",\n    value: function () {\n      var _clearSessions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(identifier) {\n        var _iterator, _step, _step$value, auth, chainId;\n\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (this.storage) {\n                  _context11.next = 2;\n                  break;\n                }\n\n                throw new Error('Unable to clear sessions: No storage adapter configured');\n\n              case 2:\n                _context11.t0 = _createForOfIteratorHelper;\n                _context11.next = 5;\n                return this.listSessions(identifier);\n\n              case 5:\n                _context11.t1 = _context11.sent;\n                _iterator = (0, _context11.t0)(_context11.t1);\n                _context11.prev = 7;\n\n                _iterator.s();\n\n              case 9:\n                if ((_step = _iterator.n()).done) {\n                  _context11.next = 15;\n                  break;\n                }\n\n                _step$value = _step.value, auth = _step$value.auth, chainId = _step$value.chainId;\n                _context11.next = 13;\n                return this.removeSession(identifier, auth, chainId);\n\n              case 13:\n                _context11.next = 9;\n                break;\n\n              case 15:\n                _context11.next = 20;\n                break;\n\n              case 17:\n                _context11.prev = 17;\n                _context11.t2 = _context11[\"catch\"](7);\n\n                _iterator.e(_context11.t2);\n\n              case 20:\n                _context11.prev = 20;\n\n                _iterator.f();\n\n                return _context11.finish(20);\n\n              case 23:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[7, 17, 20, 23]]);\n      }));\n\n      function clearSessions(_x23) {\n        return _clearSessions.apply(this, arguments);\n      }\n\n      return clearSessions;\n    }()\n    /**\n     * Create an eosjs compatible signature provider using this link.\n     * @param availableKeys Keys the created provider will claim to be able to sign for.\n     * @param chain Chain to use when configured with multiple chains.\n     * @param transport (internal) Transport override for this call.\n     * @note We don't know what keys are available so those have to be provided,\n     *       to avoid this use [[LinkSession.makeSignatureProvider]] instead. Sessions can be created with [[Link.login]].\n     */\n\n  }, {\n    key: \"makeSignatureProvider\",\n    value: function makeSignatureProvider(availableKeys, chain, transport) {\n      var _this6 = this;\n\n      return {\n        getAvailableKeys: function () {\n          var _getAvailableKeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n            return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n              while (1) {\n                switch (_context12.prev = _context12.next) {\n                  case 0:\n                    return _context12.abrupt(\"return\", availableKeys);\n\n                  case 1:\n                  case \"end\":\n                    return _context12.stop();\n                }\n              }\n            }, _callee12);\n          }));\n\n          function getAvailableKeys() {\n            return _getAvailableKeys.apply(this, arguments);\n          }\n\n          return getAvailableKeys;\n        }(),\n        sign: function () {\n          var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(args) {\n            var t, c, request, callback, _yield$_this6$sendReq, transaction, signatures, serializedTransaction;\n\n            return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n              while (1) {\n                switch (_context13.prev = _context13.next) {\n                  case 0:\n                    t = transport || _this6.transport;\n                    c = chain ? _this6.getChain(chain) : _this6.chains[0];\n                    request = SigningRequest.fromTransaction(args.chainId, args.serializedTransaction, {\n                      abiProvider: c,\n                      zlib: zlib\n                    });\n                    callback = _this6.callbackService.create();\n                    request.setCallback(callback.url, true);\n                    request.setBroadcast(false);\n\n                    if (!t.prepare) {\n                      _context13.next = 10;\n                      break;\n                    }\n\n                    _context13.next = 9;\n                    return t.prepare(request);\n\n                  case 9:\n                    request = _context13.sent;\n\n                  case 10:\n                    _context13.next = 12;\n                    return _this6.sendRequest(request, callback, c, t);\n\n                  case 12:\n                    _yield$_this6$sendReq = _context13.sent;\n                    transaction = _yield$_this6$sendReq.transaction;\n                    signatures = _yield$_this6$sendReq.signatures;\n                    serializedTransaction = Serializer.encode({\n                      object: transaction\n                    });\n                    return _context13.abrupt(\"return\", _objectSpread(_objectSpread({}, args), {}, {\n                      serializedTransaction: serializedTransaction,\n                      signatures: signatures\n                    }));\n\n                  case 17:\n                  case \"end\":\n                    return _context13.stop();\n                }\n              }\n            }, _callee13);\n          }));\n\n          function sign(_x24) {\n            return _sign.apply(this, arguments);\n          }\n\n          return sign;\n        }()\n      };\n    }\n    /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */\n\n  }, {\n    key: \"touchSession\",\n    value: function () {\n      var _touchSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(identifier, auth, chainId) {\n        var remove,\n            list,\n            existing,\n            key,\n            _args14 = arguments;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                remove = _args14.length > 3 && _args14[3] !== undefined ? _args14[3] : false;\n                _context14.next = 3;\n                return this.listSessions(identifier);\n\n              case 3:\n                list = _context14.sent;\n                existing = list.findIndex(function (item) {\n                  return item.auth.equals(auth) && item.chainId.equals(chainId);\n                });\n\n                if (existing >= 0) {\n                  list.splice(existing, 1);\n                }\n\n                if (remove === false) {\n                  list.unshift({\n                    auth: auth,\n                    chainId: chainId\n                  });\n                }\n\n                key = this.sessionKey(identifier, 'list');\n                _context14.next = 10;\n                return this.storage.write(key, JSON.stringify(list));\n\n              case 10:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function touchSession(_x25, _x26, _x27) {\n        return _touchSession.apply(this, arguments);\n      }\n\n      return touchSession;\n    }()\n    /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */\n\n  }, {\n    key: \"storeSession\",\n    value: function () {\n      var _storeSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(identifier, session) {\n        var key, data;\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                key = this.sessionKey(identifier, formatAuth(session.auth), String(session.chainId));\n                data = JSON.stringify(session.serialize());\n                _context15.next = 4;\n                return this.storage.write(key, data);\n\n              case 4:\n                _context15.next = 6;\n                return this.touchSession(identifier, session.auth, session.chainId);\n\n              case 6:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function storeSession(_x28, _x29) {\n        return _storeSession.apply(this, arguments);\n      }\n\n      return storeSession;\n    }()\n    /** Session storage key for identifier and suffix. */\n\n  }, {\n    key: \"sessionKey\",\n    value: function sessionKey(identifier) {\n      for (var _len = arguments.length, suffix = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        suffix[_key - 1] = arguments[_key];\n      }\n\n      return [String(Name.from(identifier))].concat(suffix).join('-');\n    }\n    /** Return user agent of this link. */\n\n  }, {\n    key: \"getUserAgent\",\n    value: function getUserAgent() {\n      var rv = \"AnchorLink/\".concat(Link.version);\n\n      if (this.transport.userAgent) {\n        rv += ' ' + this.transport.userAgent();\n      }\n\n      return rv;\n    }\n  }]);\n\n  return Link;\n}();\n/** Package version. */\n\n\nLink.version = '3.2.2'; // eslint-disable-line @typescript-eslint/no-inferrable-types\n\n/**\n * Format a EOSIO permission level in the format `actor@permission` taking placeholders into consideration.\n * @internal\n */\n\nfunction formatAuth(auth) {\n  var a = PermissionLevel.from(auth);\n  var actor = a.actor.equals(PlaceholderName) ? '<any>' : String(a.actor);\n  var permission;\n\n  if (a.permission.equals(PlaceholderName) || a.permission.equals(PlaceholderPermission)) {\n    permission = '<any>';\n  } else {\n    permission = String(a.permission);\n  }\n\n  return \"\".concat(actor, \"@\").concat(permission);\n}\n/**\n * Return PascalCase version of snake_case string.\n * @internal\n */\n\n\nfunction snakeToPascal(name) {\n  return name.split('_').map(function (v) {\n    return (v[0] ? v[0].toUpperCase() : '_') + v.slice(1);\n  }).join('');\n}\n/**\n * Return camelCase version of snake_case string.\n * @internal\n */\n\n\nfunction snakeToCamel(name) {\n  var pascal = snakeToPascal(name);\n  return pascal[0].toLowerCase() + pascal.slice(1);\n} // export library\n\n\nexport default Link;\nexport { CancelError, IdentityError, Link, LinkChain, LinkChannelSession, LinkFallbackSession, LinkSession, SessionError };","map":{"version":3,"sources":["../src/errors.ts","../src/link-options.ts","../src/link-types.ts","../src/utils.ts","../src/link-session.ts","../src/link-callback.ts","../src/link.ts","../src/index.ts"],"names":["uuid"],"mappings":"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","sourcesContent":["/**\n * Anchor Link v3.2.2\n * https://github.com/greymass/anchor-link\n *\n * @license\n * Copyright (c) 2020 Greymass Inc. All Rights Reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \n *  1. Redistribution of source code must retain the above copyright notice, this\n *     list of conditions and the following disclaimer.\n * \n *  2. Redistribution in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n * \n *  3. Neither the name of the copyright holder nor the names of its contributors\n *     may be used to endorse or promote products derived from this software without\n *     specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE\n * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.\n */\nimport zlib from 'pako';\nimport { Struct, UInt64, Checksum512, Serializer, Bytes, Checksum256, PermissionLevel, PublicKey, Name, PrivateKey, APIClient, Signature, SignedTransaction } from '@greymass/eosio';\nexport * from '@greymass/eosio';\nimport { ChainId, SigningRequest, ResolvedSigningRequest, PlaceholderName, PlaceholderPermission } from 'eosio-signing-request';\nexport * from 'eosio-signing-request';\nexport { ChainId, ChainName, IdentityProof } from 'eosio-signing-request';\nimport { __decorate } from 'tslib';\nimport makeFetch from 'fetch-ponyfill';\nimport { AES_CBC } from 'asmcrypto.js';\nimport { v4 } from 'uuid';\nimport WebSocket from 'isomorphic-ws';\n\n/**\n * Error that is thrown if a [[LinkTransport]] cancels a request.\n * @internal\n */\nclass CancelError extends Error {\n    constructor(reason) {\n        super(`User canceled request ${reason ? '(' + reason + ')' : ''}`);\n        this.code = 'E_CANCEL';\n    }\n}\n/**\n * Error that is thrown if an identity request fails to verify.\n * @internal\n */\nclass IdentityError extends Error {\n    constructor(reason) {\n        super(`Unable to verify identity ${reason ? '(' + reason + ')' : ''}`);\n        this.code = 'E_IDENTITY';\n    }\n}\n/**\n * Error originating from a [[LinkSession]].\n * @internal\n */\nclass SessionError extends Error {\n    constructor(reason, code) {\n        super(reason);\n        this.code = code;\n    }\n}\n\n/** @internal */\nvar LinkOptions;\n(function (LinkOptions) {\n    /** @internal */\n    LinkOptions.defaults = {\n        service: 'https://cb.anchor.link',\n        verifyProofs: false,\n        encodeChainIds: true,\n    };\n})(LinkOptions || (LinkOptions = {}));\n\nlet SealedMessage = class SealedMessage extends Struct {\n};\n__decorate([\n    Struct.field('public_key')\n], SealedMessage.prototype, \"from\", void 0);\n__decorate([\n    Struct.field('uint64')\n], SealedMessage.prototype, \"nonce\", void 0);\n__decorate([\n    Struct.field('bytes')\n], SealedMessage.prototype, \"ciphertext\", void 0);\n__decorate([\n    Struct.field('uint32')\n], SealedMessage.prototype, \"checksum\", void 0);\nSealedMessage = __decorate([\n    Struct.type('sealed_message')\n], SealedMessage);\nlet LinkCreate = class LinkCreate extends Struct {\n};\n__decorate([\n    Struct.field('name')\n], LinkCreate.prototype, \"session_name\", void 0);\n__decorate([\n    Struct.field('public_key')\n], LinkCreate.prototype, \"request_key\", void 0);\n__decorate([\n    Struct.field('string', { extension: true })\n], LinkCreate.prototype, \"user_agent\", void 0);\nLinkCreate = __decorate([\n    Struct.type('link_create')\n], LinkCreate);\nlet LinkInfo = class LinkInfo extends Struct {\n};\n__decorate([\n    Struct.field('time_point_sec')\n], LinkInfo.prototype, \"expiration\", void 0);\nLinkInfo = __decorate([\n    Struct.type('link_info')\n], LinkInfo);\n\n/** @internal */\nconst fetch = makeFetch().fetch;\n/**\n * Encrypt a message using AES and shared secret derived from given keys.\n * @internal\n */\nfunction sealMessage(message, privateKey, publicKey, nonce) {\n    const secret = privateKey.sharedSecret(publicKey);\n    if (!nonce) {\n        nonce = UInt64.random();\n    }\n    const key = Checksum512.hash(Serializer.encode({ object: nonce }).appending(secret.array));\n    const cbc = new AES_CBC(key.array.slice(0, 32), key.array.slice(32, 48));\n    const ciphertext = Bytes.from(cbc.encrypt(Bytes.from(message, 'utf8').array));\n    const checksumView = new DataView(Checksum256.hash(key.array).array.buffer);\n    const checksum = checksumView.getUint32(0, true);\n    return SealedMessage.from({\n        from: privateKey.toPublic(),\n        nonce,\n        ciphertext,\n        checksum,\n    });\n}\n\n/**\n * Type describing a link session that can create a eosjs compatible\n * signature provider and transact for a specific auth.\n */\nclass LinkSession {\n    /** @internal */\n    constructor() { } // eslint-disable-line @typescript-eslint/no-empty-function\n    /**\n     * Convenience, remove this session from associated [[Link]] storage if set.\n     * Equivalent to:\n     * ```ts\n     * session.link.removeSession(session.identifier, session.auth, session.chainId)\n     * ```\n     */\n    async remove() {\n        if (this.link.storage) {\n            await this.link.removeSession(this.identifier, this.auth, this.chainId);\n        }\n    }\n    /** API client for the chain this session is valid on. */\n    get client() {\n        return this.link.getChain(this.chainId).client;\n    }\n    /** Restore a previously serialized session. */\n    static restore(link, data) {\n        switch (data.type) {\n            case 'channel':\n                return new LinkChannelSession(link, data.data, data.metadata);\n            case 'fallback':\n                return new LinkFallbackSession(link, data.data, data.metadata);\n            default:\n                throw new Error('Unable to restore, session data invalid');\n        }\n    }\n}\n/**\n * Link session that pushes requests over a channel.\n * @internal\n */\nclass LinkChannelSession extends LinkSession {\n    constructor(link, data, metadata) {\n        super();\n        this.type = 'channel';\n        this.timeout = 2 * 60 * 1000; // ms\n        this.link = link;\n        this.chainId = ChainId.from(data.chainId);\n        this.auth = PermissionLevel.from(data.auth);\n        this.publicKey = PublicKey.from(data.publicKey);\n        this.channel = data.channel;\n        this.identifier = Name.from(data.identifier);\n        const privateKey = PrivateKey.from(data.requestKey);\n        const publicKey = PublicKey.from(data.channel.key);\n        this.encrypt = (request) => {\n            return sealMessage(request.encode(true, false), privateKey, publicKey);\n        };\n        this.metadata = {\n            ...(metadata || {}),\n            timeout: this.timeout,\n            name: this.channel.name,\n        };\n        this.serialize = () => ({\n            type: 'channel',\n            data,\n            metadata: this.metadata,\n        });\n    }\n    onSuccess(request, result) {\n        if (this.link.transport.onSuccess) {\n            this.link.transport.onSuccess(request, result);\n        }\n    }\n    onFailure(request, error) {\n        if (this.link.transport.onFailure) {\n            this.link.transport.onFailure(request, error);\n        }\n    }\n    onRequest(request, cancel) {\n        const info = LinkInfo.from({\n            expiration: new Date(Date.now() + this.timeout).toISOString().slice(0, -1),\n        });\n        if (this.link.transport.onSessionRequest) {\n            this.link.transport.onSessionRequest(this, request, cancel);\n        }\n        setTimeout(() => {\n            cancel(new SessionError('Wallet did not respond in time', 'E_TIMEOUT'));\n        }, this.timeout + 500);\n        request.setInfoKey('link', info);\n        let payloadSent = false;\n        const payload = Serializer.encode({ object: this.encrypt(request) });\n        if (this.link.transport.sendSessionPayload) {\n            try {\n                payloadSent = this.link.transport.sendSessionPayload(payload, this);\n            }\n            catch (error) {\n                // eslint-disable-next-line no-console\n                console.warn('Unexpected error when transport tried to send session payload', error);\n            }\n        }\n        if (payloadSent) {\n            return;\n        }\n        fetch(this.channel.url, {\n            method: 'POST',\n            headers: {\n                'X-Buoy-Wait': (this.timeout / 1000).toFixed(0),\n            },\n            body: payload.array,\n        })\n            .then((response) => {\n            if (response.status !== 200) {\n                cancel(new SessionError('Unable to push message', 'E_DELIVERY'));\n            }\n        })\n            .catch((error) => {\n            cancel(new SessionError(`Unable to reach link service (${error.message || String(error)})`, 'E_DELIVERY'));\n        });\n    }\n    prepare(request) {\n        if (this.link.transport.prepare) {\n            return this.link.transport.prepare(request, this);\n        }\n        return Promise.resolve(request);\n    }\n    showLoading() {\n        if (this.link.transport.showLoading) {\n            return this.link.transport.showLoading();\n        }\n    }\n    makeSignatureProvider() {\n        return this.link.makeSignatureProvider([this.publicKey.toString()], this.chainId, this);\n    }\n    transact(args, options) {\n        return this.link.transact(args, { ...options, chain: this.chainId }, this);\n    }\n}\n/**\n * Link session that sends every request over the transport.\n * @internal\n */\nclass LinkFallbackSession extends LinkSession {\n    constructor(link, data, metadata) {\n        super();\n        this.type = 'fallback';\n        this.link = link;\n        this.auth = PermissionLevel.from(data.auth);\n        this.publicKey = PublicKey.from(data.publicKey);\n        this.chainId = ChainId.from(data.chainId);\n        this.metadata = metadata || {};\n        this.identifier = Name.from(data.identifier);\n        this.serialize = () => ({\n            type: this.type,\n            data,\n            metadata: this.metadata,\n        });\n    }\n    onSuccess(request, result) {\n        if (this.link.transport.onSuccess) {\n            this.link.transport.onSuccess(request, result);\n        }\n    }\n    onFailure(request, error) {\n        if (this.link.transport.onFailure) {\n            this.link.transport.onFailure(request, error);\n        }\n    }\n    onRequest(request, cancel) {\n        if (this.link.transport.onSessionRequest) {\n            this.link.transport.onSessionRequest(this, request, cancel);\n        }\n        else {\n            this.link.transport.onRequest(request, cancel);\n        }\n    }\n    prepare(request) {\n        if (this.link.transport.prepare) {\n            return this.link.transport.prepare(request, this);\n        }\n        return Promise.resolve(request);\n    }\n    showLoading() {\n        if (this.link.transport.showLoading) {\n            return this.link.transport.showLoading();\n        }\n    }\n    makeSignatureProvider() {\n        return this.link.makeSignatureProvider([this.publicKey.toString()], this.chainId, this);\n    }\n    transact(args, options) {\n        return this.link.transact(args, { ...options, chain: this.chainId }, this);\n    }\n}\n\n/** @internal */\nclass BuoyCallbackService {\n    constructor(address) {\n        this.address = address.trim().replace(/\\/$/, '');\n    }\n    create() {\n        const url = `${this.address}/${v4()}`;\n        return new BuoyCallback(url);\n    }\n}\n/** @internal */\nclass BuoyCallback {\n    constructor(url) {\n        this.url = url;\n        this.ctx = {};\n    }\n    wait() {\n        if (this.url.includes('hyperbuoy')) {\n            return pollForCallback(this.url, this.ctx);\n        }\n        else {\n            return waitForCallback(this.url, this.ctx);\n        }\n    }\n    cancel() {\n        if (this.ctx.cancel) {\n            this.ctx.cancel();\n        }\n    }\n}\n/**\n * Connect to a WebSocket channel and wait for a message.\n * @internal\n */\nfunction waitForCallback(url, ctx) {\n    return new Promise((resolve, reject) => {\n        let active = true;\n        let retries = 0;\n        const socketUrl = url.replace(/^http/, 'ws');\n        const handleResponse = (response) => {\n            try {\n                resolve(JSON.parse(response));\n            }\n            catch (error) {\n                error.message = 'Unable to parse callback JSON: ' + error.message;\n                reject(error);\n            }\n        };\n        const connect = () => {\n            const socket = new WebSocket(socketUrl);\n            ctx.cancel = () => {\n                active = false;\n                if (socket.readyState === WebSocket.OPEN ||\n                    socket.readyState === WebSocket.CONNECTING) {\n                    socket.close();\n                }\n            };\n            socket.onmessage = (event) => {\n                active = false;\n                if (socket.readyState === WebSocket.OPEN) {\n                    socket.close();\n                }\n                if (typeof Blob !== 'undefined' && event.data instanceof Blob) {\n                    const reader = new FileReader();\n                    reader.onload = () => {\n                        handleResponse(reader.result);\n                    };\n                    reader.onerror = (error) => {\n                        reject(error);\n                    };\n                    reader.readAsText(event.data);\n                }\n                else {\n                    if (typeof event.data === 'string') {\n                        handleResponse(event.data);\n                    }\n                    else {\n                        handleResponse(event.data.toString());\n                    }\n                }\n            };\n            socket.onopen = () => {\n                retries = 0;\n            };\n            socket.onclose = () => {\n                if (active) {\n                    setTimeout(connect, backoff(retries++));\n                }\n            };\n        };\n        connect();\n    });\n}\n/**\n * Long-poll for message.\n * @internal\n */\nasync function pollForCallback(url, ctx) {\n    let active = true;\n    ctx.cancel = () => {\n        active = false;\n    };\n    while (active) {\n        try {\n            const res = await fetch(url);\n            if (res.status === 408) {\n                continue;\n            }\n            else if (res.status === 200) {\n                return await res.json();\n            }\n            else {\n                throw new Error(`HTTP ${res.status}: ${res.statusText}`);\n            }\n        }\n        catch (error) {\n            // eslint-disable-next-line no-console\n            console.warn('Unexpected hyperbuoy error', error);\n        }\n        await sleep(1000);\n    }\n    return null;\n}\n/**\n * Exponential backoff function that caps off at 10s after 10 tries.\n * https://i.imgur.com/IrUDcJp.png\n * @internal\n */\nfunction backoff(tries) {\n    return Math.min(Math.pow(tries * 10, 2), 10 * 1000);\n}\n/**\n * Return promise that resolves after given milliseconds.\n * @internal\n */\nfunction sleep(ms) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, ms);\n    });\n}\n\n/**\n * Class representing a EOSIO chain.\n */\nclass LinkChain {\n    /** @internal */\n    constructor(chainId, clientOrUrl) {\n        this.abiCache = new Map();\n        this.pendingAbis = new Map();\n        this.chainId = ChainId.from(chainId);\n        this.client =\n            typeof clientOrUrl === 'string' ? new APIClient({ url: clientOrUrl }) : clientOrUrl;\n    }\n    /**\n     * Fetch the ABI for given account, cached.\n     * @internal\n     */\n    async getAbi(account) {\n        const key = String(account);\n        let rv = this.abiCache.get(key);\n        if (!rv) {\n            let getAbi = this.pendingAbis.get(key);\n            if (!getAbi) {\n                getAbi = this.client.v1.chain.get_abi(account);\n                this.pendingAbis.set(key, getAbi);\n            }\n            rv = (await getAbi).abi;\n            this.pendingAbis.delete(key);\n            if (rv) {\n                this.abiCache.set(key, rv);\n            }\n        }\n        return rv;\n    }\n}\n/**\n * Anchor Link main class.\n *\n * @example\n *\n * ```ts\n * import AnchorLink from 'anchor-link'\n * import ConsoleTransport from 'anchor-link-console-transport'\n *\n * const link = new AnchorLink({\n *     transport: new ConsoleTransport(),\n *     chains: [\n *         {\n *             chainId: 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906',\n *             nodeUrl: 'https://eos.greymass.com',\n *         },\n *     ],\n * })\n *\n * const result = await link.transact({actions: myActions})\n * ```\n */\nclass Link {\n    /** Create a new link instance. */\n    constructor(options) {\n        if (typeof options !== 'object') {\n            throw new TypeError('Missing options object');\n        }\n        if (!options.transport) {\n            throw new TypeError('options.transport is required');\n        }\n        let chains = options.chains || [];\n        if (options.chainId && options.client) {\n            chains = [{ chainId: options.chainId, nodeUrl: options.client }];\n        }\n        if (chains.length === 0) {\n            throw new TypeError('options.chains is required');\n        }\n        this.chains = chains.map(({ chainId, nodeUrl }) => {\n            if (!chainId) {\n                throw new Error('options.chains[].chainId is required');\n            }\n            if (!nodeUrl) {\n                throw new Error('options.chains[].nodeUrl is required');\n            }\n            return new LinkChain(chainId, nodeUrl);\n        });\n        if (options.service === undefined || typeof options.service === 'string') {\n            this.callbackService = new BuoyCallbackService(options.service || LinkOptions.defaults.service);\n        }\n        else {\n            this.callbackService = options.service;\n        }\n        this.transport = options.transport;\n        if (options.storage !== null) {\n            this.storage = options.storage || this.transport.storage;\n        }\n        this.verifyProofs =\n            options.verifyProofs !== undefined\n                ? options.verifyProofs\n                : LinkOptions.defaults.verifyProofs;\n        this.encodeChainIds =\n            options.encodeChainIds !== undefined\n                ? options.encodeChainIds\n                : LinkOptions.defaults.encodeChainIds;\n    }\n    /**\n     * The APIClient instance for communicating with the node.\n     * @note This returns the first APIClient when link is configured with multiple chains.\n     */\n    get client() {\n        return this.chains[0].client;\n    }\n    /**\n     * Return a [[LinkChain]] object for given chainId or chain reference.\n     * @throws If this link instance has no configured chain for given reference.\n     * @internal\n     */\n    getChain(chain) {\n        if (chain instanceof LinkChain) {\n            return chain;\n        }\n        if (typeof chain === 'number') {\n            const rv = this.chains[chain];\n            if (!rv) {\n                throw new Error(`Invalid chain index: ${chain}`);\n            }\n            return rv;\n        }\n        const id = ChainId.from(chain);\n        const rv = this.chains.find((c) => c.chainId.equals(id));\n        if (!rv) {\n            throw new Error(`Unsupported chain: ${id}`);\n        }\n        return rv;\n    }\n    /**\n     * Create a SigningRequest instance configured for this link.\n     * @internal\n     */\n    async createRequest(args, chain, transport) {\n        const t = transport || this.transport;\n        let request;\n        if (chain || this.chains.length === 1) {\n            const c = chain || this.chains[0];\n            request = await SigningRequest.create({\n                ...args,\n                chainId: c.chainId,\n                broadcast: false,\n            }, { abiProvider: c, zlib });\n        }\n        else {\n            // multi-chain request\n            request = await SigningRequest.create({\n                ...args,\n                chainId: null,\n                chainIds: this.encodeChainIds ? this.chains.map((c) => c.chainId) : undefined,\n                broadcast: false,\n            }, \n            // abi's will be pulled from the first chain and assumed to be identical on all chains\n            { abiProvider: this.chains[0], zlib });\n        }\n        if (t.prepare) {\n            request = await t.prepare(request);\n        }\n        const callback = this.callbackService.create();\n        request.setCallback(callback.url, true);\n        return { request, callback };\n    }\n    /**\n     * Send a SigningRequest instance using this link.\n     * @internal\n     */\n    async sendRequest(request, callback, chain, transport, broadcast = false) {\n        const t = transport || this.transport;\n        try {\n            const linkUrl = request.data.callback;\n            if (linkUrl !== callback.url) {\n                throw new Error('Invalid request callback');\n            }\n            if (request.data.flags.broadcast === true || request.data.flags.background === false) {\n                throw new Error('Invalid request flags');\n            }\n            // wait for callback or user cancel\n            const cancel = new Promise((resolve, reject) => {\n                t.onRequest(request, (reason) => {\n                    callback.cancel();\n                    if (typeof reason === 'string') {\n                        reject(new CancelError(reason));\n                    }\n                    else {\n                        reject(reason);\n                    }\n                });\n            });\n            const callbackResponse = await Promise.race([callback.wait(), cancel]);\n            if (typeof callbackResponse.rejected === 'string') {\n                throw new CancelError(callbackResponse.rejected);\n            }\n            const payload = callbackResponse;\n            const signer = PermissionLevel.from({\n                actor: payload.sa,\n                permission: payload.sp,\n            });\n            const signatures = Object.keys(payload)\n                .filter((key) => key.startsWith('sig') && key !== 'sig0')\n                .map((key) => Signature.from(payload[key]));\n            let c;\n            if (!chain && this.chains.length > 1) {\n                if (!payload.cid) {\n                    throw new Error('Multi chain response payload must specify resolved chain id (cid)');\n                }\n                c = this.getChain(payload.cid);\n            }\n            else {\n                c = chain || this.getChain(0);\n                if (payload.cid && !c.chainId.equals(payload.cid)) {\n                    throw new Error('Got response for wrong chain id');\n                }\n            }\n            // recreate transaction from request response\n            const resolved = await ResolvedSigningRequest.fromPayload(payload, {\n                zlib,\n                abiProvider: c,\n            });\n            // prepend cosigner signature if present\n            const cosignerSig = resolved.request.getInfoKey('cosig', {\n                type: Signature,\n                array: true,\n            });\n            if (cosignerSig) {\n                signatures.unshift(...cosignerSig);\n            }\n            const result = {\n                resolved,\n                chain: c,\n                transaction: resolved.transaction,\n                resolvedTransaction: resolved.resolvedTransaction,\n                signatures,\n                payload,\n                signer,\n            };\n            if (broadcast) {\n                const signedTx = SignedTransaction.from({\n                    ...resolved.transaction,\n                    signatures,\n                });\n                const res = await c.client.v1.chain.push_transaction(signedTx);\n                result.processed = res.processed;\n            }\n            if (t.onSuccess) {\n                t.onSuccess(request, result);\n            }\n            return result;\n        }\n        catch (error) {\n            if (t.onFailure) {\n                t.onFailure(request, error);\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sign and optionally broadcast a EOSIO transaction, action or actions.\n     *\n     * Example:\n     *\n     * ```ts\n     * let result = await myLink.transact({transaction: myTx})\n     * ```\n     *\n     * @param args The action, actions or transaction to use.\n     * @param options Options for this transact call.\n     * @param transport Transport override, for internal use.\n     */\n    async transact(args, options, transport) {\n        const o = options || {};\n        const t = transport || this.transport;\n        const c = o.chain !== undefined ? this.getChain(o.chain) : undefined;\n        const broadcast = o.broadcast !== false;\n        const noModify = o.noModify !== undefined ? o.noModify : !broadcast;\n        // Initialize the loading state of the transport\n        if (t && t.showLoading) {\n            t.showLoading();\n        }\n        // eosjs transact compat: upgrade to transaction if args have any header fields\n        const anyArgs = args;\n        if (args.actions &&\n            (anyArgs.expiration ||\n                anyArgs.ref_block_num ||\n                anyArgs.ref_block_prefix ||\n                anyArgs.max_net_usage_words ||\n                anyArgs.max_cpu_usage_ms ||\n                anyArgs.delay_sec)) {\n            args = {\n                transaction: {\n                    expiration: '1970-01-01T00:00:00',\n                    ref_block_num: 0,\n                    ref_block_prefix: 0,\n                    max_net_usage_words: 0,\n                    max_cpu_usage_ms: 0,\n                    delay_sec: 0,\n                    ...anyArgs,\n                },\n            };\n        }\n        const { request, callback } = await this.createRequest(args, c, t);\n        if (noModify) {\n            request.setInfoKey('no_modify', true, 'bool');\n        }\n        const result = await this.sendRequest(request, callback, c, t, broadcast);\n        return result;\n    }\n    /**\n     * Send an identity request and verify the identity proof if [[LinkOptions.verifyProofs]] is true.\n     * @param args.scope The scope of the identity request.\n     * @param args.requestPermission Optional request permission if the request is for a specific account or permission.\n     * @param args.info Metadata to add to the request.\n     * @note This is for advanced use-cases, you probably want to use [[Link.login]] instead.\n     */\n    async identify(args) {\n        const { request, callback } = await this.createRequest({\n            identity: { permission: args.requestPermission, scope: args.scope },\n            info: args.info,\n        });\n        const res = await this.sendRequest(request, callback);\n        if (!res.resolved.request.isIdentity()) {\n            throw new IdentityError('Unexpected response');\n        }\n        let account;\n        const proof = res.resolved.getIdentityProof(res.signatures[0]);\n        if (this.verifyProofs) {\n            account = await res.chain.client.v1.chain.get_account(res.signer.actor);\n            if (!account) {\n                throw new IdentityError(`Signature from unknown account: ${proof.signer.actor}`);\n            }\n            const accountPermission = account.permissions.find(({ perm_name }) => proof.signer.permission.equals(perm_name));\n            if (!accountPermission) {\n                throw new IdentityError(`${proof.signer.actor} signed for unknown permission: ${proof.signer.permission}`);\n            }\n            const proofValid = proof.verify(accountPermission.required_auth, account.head_block_time);\n            if (!proofValid) {\n                throw new IdentityError(`Invalid identify proof for: ${proof.signer}`);\n            }\n        }\n        if (args.requestPermission) {\n            const perm = PermissionLevel.from(args.requestPermission);\n            if ((!perm.actor.equals(PlaceholderName) && !perm.actor.equals(proof.signer.actor)) ||\n                (!perm.permission.equals(PlaceholderPermission) &&\n                    !perm.permission.equals(proof.signer.permission))) {\n                throw new IdentityError(`Identity proof singed by ${proof.signer}, expected: ${formatAuth(perm)} `);\n            }\n        }\n        return {\n            ...res,\n            account,\n            proof,\n        };\n    }\n    /**\n     * Login and create a persistent session.\n     * @param identifier The session identifier, an EOSIO name (`[a-z1-5]{1,12}`).\n     *                   Should be set to the contract account if applicable.\n     */\n    async login(identifier) {\n        const privateKey = PrivateKey.generate('K1');\n        const requestKey = privateKey.toPublic();\n        const createInfo = LinkCreate.from({\n            session_name: identifier,\n            request_key: requestKey,\n            user_agent: this.getUserAgent(),\n        });\n        const res = await this.identify({\n            scope: identifier,\n            info: {\n                link: createInfo,\n                scope: identifier,\n            },\n        });\n        const metadata = {\n            // backwards compat, can be removed next major release\n            sameDevice: res.resolved.request.getRawInfo()['return_path'] !== undefined,\n        };\n        // append extra metadata from the signer\n        if (res.payload.link_meta) {\n            try {\n                const parsed = JSON.parse(res.payload.link_meta);\n                for (const key of Object.keys(parsed)) {\n                    // normalize key names to camelCase\n                    metadata[snakeToCamel(key)] = parsed[key];\n                }\n            }\n            catch (error) {\n                // eslint-disable-next-line no-console\n                console.warn('Unable to parse link metadata', error, res.payload.link_meta);\n            }\n        }\n        const signerKey = res.proof.recover();\n        let session;\n        if (res.payload.link_ch && res.payload.link_key && res.payload.link_name) {\n            session = new LinkChannelSession(this, {\n                identifier,\n                chainId: res.chain.chainId,\n                auth: res.signer,\n                publicKey: signerKey,\n                channel: {\n                    url: res.payload.link_ch,\n                    key: res.payload.link_key,\n                    name: res.payload.link_name,\n                },\n                requestKey: privateKey,\n            }, metadata);\n        }\n        else {\n            session = new LinkFallbackSession(this, {\n                identifier,\n                chainId: res.chain.chainId,\n                auth: res.signer,\n                publicKey: signerKey,\n            }, metadata);\n        }\n        if (this.storage) {\n            await this.storeSession(identifier, session);\n        }\n        return {\n            ...res,\n            session,\n        };\n    }\n    /**\n     * Restore previous session, use [[login]] to create a new session.\n     * @param identifier The session identifier, must be same as what was used when creating the session with [[login]].\n     * @param auth A specific session auth to restore, if omitted the most recently used session will be restored.\n     * @param chainId If given function will only consider that specific chain when restoring session.\n     * @returns A [[LinkSession]] instance or null if no session can be found.\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session data.\n     **/\n    async restoreSession(identifier, auth, chainId) {\n        if (!this.storage) {\n            throw new Error('Unable to restore session: No storage adapter configured');\n        }\n        let key;\n        if (auth && chainId) {\n            // both auth and chain id given, we can look up on specific key\n            key = this.sessionKey(identifier, formatAuth(PermissionLevel.from(auth)), String(ChainId.from(chainId)));\n        }\n        else {\n            // otherwise we use the session list to filter down to most recently used matching given params\n            let list = await this.listSessions(identifier);\n            if (auth) {\n                list = list.filter((item) => item.auth.equals(auth));\n            }\n            if (chainId) {\n                const id = ChainId.from(chainId);\n                list = list.filter((item) => item.chainId.equals(id));\n            }\n            const latest = list[0];\n            if (!latest) {\n                return null;\n            }\n            key = this.sessionKey(identifier, formatAuth(latest.auth), String(latest.chainId));\n        }\n        const data = await this.storage.read(key);\n        if (!data) {\n            return null;\n        }\n        let sessionData;\n        try {\n            sessionData = JSON.parse(data);\n        }\n        catch (error) {\n            throw new Error(`Unable to restore session: Stored JSON invalid (${error.message || String(error)})`);\n        }\n        const session = LinkSession.restore(this, sessionData);\n        if (auth || chainId) {\n            // update latest used\n            await this.touchSession(identifier, session.auth, session.chainId);\n        }\n        return session;\n    }\n    /**\n     * List stored session auths for given identifier.\n     * The most recently used session is at the top (index 0).\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session list.\n     **/\n    async listSessions(identifier) {\n        if (!this.storage) {\n            throw new Error('Unable to list sessions: No storage adapter configured');\n        }\n        const key = this.sessionKey(identifier, 'list');\n        let list;\n        try {\n            list = JSON.parse((await this.storage.read(key)) || '[]');\n        }\n        catch (error) {\n            throw new Error(`Unable to list sessions: ${error.message || String(error)}`);\n        }\n        return list.map(({ auth, chainId }) => ({\n            auth: PermissionLevel.from(auth),\n            chainId: ChainId.from(chainId),\n        }));\n    }\n    /**\n     * Remove stored session for given identifier and auth.\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.\n     */\n    async removeSession(identifier, auth, chainId) {\n        if (!this.storage) {\n            throw new Error('Unable to remove session: No storage adapter configured');\n        }\n        const key = this.sessionKey(identifier, formatAuth(auth), String(chainId));\n        await this.storage.remove(key);\n        await this.touchSession(identifier, auth, chainId, true);\n    }\n    /**\n     * Remove all stored sessions for given identifier.\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.\n     */\n    async clearSessions(identifier) {\n        if (!this.storage) {\n            throw new Error('Unable to clear sessions: No storage adapter configured');\n        }\n        for (const { auth, chainId } of await this.listSessions(identifier)) {\n            await this.removeSession(identifier, auth, chainId);\n        }\n    }\n    /**\n     * Create an eosjs compatible signature provider using this link.\n     * @param availableKeys Keys the created provider will claim to be able to sign for.\n     * @param chain Chain to use when configured with multiple chains.\n     * @param transport (internal) Transport override for this call.\n     * @note We don't know what keys are available so those have to be provided,\n     *       to avoid this use [[LinkSession.makeSignatureProvider]] instead. Sessions can be created with [[Link.login]].\n     */\n    makeSignatureProvider(availableKeys, chain, transport) {\n        return {\n            getAvailableKeys: async () => availableKeys,\n            sign: async (args) => {\n                const t = transport || this.transport;\n                const c = chain ? this.getChain(chain) : this.chains[0];\n                let request = SigningRequest.fromTransaction(args.chainId, args.serializedTransaction, { abiProvider: c, zlib });\n                const callback = this.callbackService.create();\n                request.setCallback(callback.url, true);\n                request.setBroadcast(false);\n                if (t.prepare) {\n                    request = await t.prepare(request);\n                }\n                const { transaction, signatures } = await this.sendRequest(request, callback, c, t);\n                const serializedTransaction = Serializer.encode({ object: transaction });\n                return {\n                    ...args,\n                    serializedTransaction,\n                    signatures,\n                };\n            },\n        };\n    }\n    /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */\n    async touchSession(identifier, auth, chainId, remove = false) {\n        const list = await this.listSessions(identifier);\n        const existing = list.findIndex((item) => item.auth.equals(auth) && item.chainId.equals(chainId));\n        if (existing >= 0) {\n            list.splice(existing, 1);\n        }\n        if (remove === false) {\n            list.unshift({ auth, chainId });\n        }\n        const key = this.sessionKey(identifier, 'list');\n        await this.storage.write(key, JSON.stringify(list));\n    }\n    /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */\n    async storeSession(identifier, session) {\n        const key = this.sessionKey(identifier, formatAuth(session.auth), String(session.chainId));\n        const data = JSON.stringify(session.serialize());\n        await this.storage.write(key, data);\n        await this.touchSession(identifier, session.auth, session.chainId);\n    }\n    /** Session storage key for identifier and suffix. */\n    sessionKey(identifier, ...suffix) {\n        return [String(Name.from(identifier)), ...suffix].join('-');\n    }\n    /** Return user agent of this link. */\n    getUserAgent() {\n        let rv = `AnchorLink/${Link.version}`;\n        if (this.transport.userAgent) {\n            rv += ' ' + this.transport.userAgent();\n        }\n        return rv;\n    }\n}\n/** Package version. */\nLink.version = '3.2.2'; // eslint-disable-line @typescript-eslint/no-inferrable-types\n/**\n * Format a EOSIO permission level in the format `actor@permission` taking placeholders into consideration.\n * @internal\n */\nfunction formatAuth(auth) {\n    const a = PermissionLevel.from(auth);\n    const actor = a.actor.equals(PlaceholderName) ? '<any>' : String(a.actor);\n    let permission;\n    if (a.permission.equals(PlaceholderName) || a.permission.equals(PlaceholderPermission)) {\n        permission = '<any>';\n    }\n    else {\n        permission = String(a.permission);\n    }\n    return `${actor}@${permission}`;\n}\n/**\n * Return PascalCase version of snake_case string.\n * @internal\n */\nfunction snakeToPascal(name) {\n    return name\n        .split('_')\n        .map((v) => (v[0] ? v[0].toUpperCase() : '_') + v.slice(1))\n        .join('');\n}\n/**\n * Return camelCase version of snake_case string.\n * @internal\n */\nfunction snakeToCamel(name) {\n    const pascal = snakeToPascal(name);\n    return pascal[0].toLowerCase() + pascal.slice(1);\n}\n\n// export library\n\nexport default Link;\nexport { CancelError, IdentityError, Link, LinkChain, LinkChannelSession, LinkFallbackSession, LinkSession, SessionError };\n//# sourceMappingURL=anchor-link.m.js.map\n"]},"metadata":{},"sourceType":"module"}