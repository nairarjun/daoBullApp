{"ast":null,"code":"/**\n * Anchor Link v3.2.2\n * https://github.com/greymass/anchor-link\n *\n * @license\n * Copyright (c) 2020 Greymass Inc. All Rights Reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \n *  1. Redistribution of source code must retain the above copyright notice, this\n *     list of conditions and the following disclaimer.\n * \n *  2. Redistribution in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n * \n *  3. Neither the name of the copyright holder nor the names of its contributors\n *     may be used to endorse or promote products derived from this software without\n *     specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE\n * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.\n */\nimport zlib from 'pako';\nimport { Struct, UInt64, Checksum512, Serializer, Bytes, Checksum256, PermissionLevel, PublicKey, Name, PrivateKey, APIClient, Signature, SignedTransaction } from '@greymass/eosio';\nexport * from '@greymass/eosio';\nimport { ChainId, SigningRequest, ResolvedSigningRequest, PlaceholderName, PlaceholderPermission } from 'eosio-signing-request';\nexport * from 'eosio-signing-request';\nexport { ChainId, ChainName, IdentityProof } from 'eosio-signing-request';\nimport { __decorate } from 'tslib';\nimport makeFetch from 'fetch-ponyfill';\nimport { AES_CBC } from 'asmcrypto.js';\nimport { v4 } from 'uuid';\nimport WebSocket from 'isomorphic-ws';\n/**\n * Error that is thrown if a [[LinkTransport]] cancels a request.\n * @internal\n */\n\nclass CancelError extends Error {\n  constructor(reason) {\n    super(`User canceled request ${reason ? '(' + reason + ')' : ''}`);\n    this.code = 'E_CANCEL';\n  }\n\n}\n/**\n * Error that is thrown if an identity request fails to verify.\n * @internal\n */\n\n\nclass IdentityError extends Error {\n  constructor(reason) {\n    super(`Unable to verify identity ${reason ? '(' + reason + ')' : ''}`);\n    this.code = 'E_IDENTITY';\n  }\n\n}\n/**\n * Error originating from a [[LinkSession]].\n * @internal\n */\n\n\nclass SessionError extends Error {\n  constructor(reason, code) {\n    super(reason);\n    this.code = code;\n  }\n\n}\n/** @internal */\n\n\nvar LinkOptions;\n\n(function (LinkOptions) {\n  /** @internal */\n  LinkOptions.defaults = {\n    service: 'https://cb.anchor.link',\n    verifyProofs: false,\n    encodeChainIds: true\n  };\n})(LinkOptions || (LinkOptions = {}));\n\nlet SealedMessage = class SealedMessage extends Struct {};\n\n__decorate([Struct.field('public_key')], SealedMessage.prototype, \"from\", void 0);\n\n__decorate([Struct.field('uint64')], SealedMessage.prototype, \"nonce\", void 0);\n\n__decorate([Struct.field('bytes')], SealedMessage.prototype, \"ciphertext\", void 0);\n\n__decorate([Struct.field('uint32')], SealedMessage.prototype, \"checksum\", void 0);\n\nSealedMessage = __decorate([Struct.type('sealed_message')], SealedMessage);\nlet LinkCreate = class LinkCreate extends Struct {};\n\n__decorate([Struct.field('name')], LinkCreate.prototype, \"session_name\", void 0);\n\n__decorate([Struct.field('public_key')], LinkCreate.prototype, \"request_key\", void 0);\n\n__decorate([Struct.field('string', {\n  extension: true\n})], LinkCreate.prototype, \"user_agent\", void 0);\n\nLinkCreate = __decorate([Struct.type('link_create')], LinkCreate);\nlet LinkInfo = class LinkInfo extends Struct {};\n\n__decorate([Struct.field('time_point_sec')], LinkInfo.prototype, \"expiration\", void 0);\n\nLinkInfo = __decorate([Struct.type('link_info')], LinkInfo);\n/** @internal */\n\nconst fetch = makeFetch().fetch;\n/**\n * Encrypt a message using AES and shared secret derived from given keys.\n * @internal\n */\n\nfunction sealMessage(message, privateKey, publicKey, nonce) {\n  const secret = privateKey.sharedSecret(publicKey);\n\n  if (!nonce) {\n    nonce = UInt64.random();\n  }\n\n  const key = Checksum512.hash(Serializer.encode({\n    object: nonce\n  }).appending(secret.array));\n  const cbc = new AES_CBC(key.array.slice(0, 32), key.array.slice(32, 48));\n  const ciphertext = Bytes.from(cbc.encrypt(Bytes.from(message, 'utf8').array));\n  const checksumView = new DataView(Checksum256.hash(key.array).array.buffer);\n  const checksum = checksumView.getUint32(0, true);\n  return SealedMessage.from({\n    from: privateKey.toPublic(),\n    nonce,\n    ciphertext,\n    checksum\n  });\n}\n/**\n * Type describing a link session that can create a eosjs compatible\n * signature provider and transact for a specific auth.\n */\n\n\nclass LinkSession {\n  /** @internal */\n  constructor() {} // eslint-disable-line @typescript-eslint/no-empty-function\n\n  /**\n   * Convenience, remove this session from associated [[Link]] storage if set.\n   * Equivalent to:\n   * ```ts\n   * session.link.removeSession(session.identifier, session.auth, session.chainId)\n   * ```\n   */\n\n\n  async remove() {\n    if (this.link.storage) {\n      await this.link.removeSession(this.identifier, this.auth, this.chainId);\n    }\n  }\n  /** API client for the chain this session is valid on. */\n\n\n  get client() {\n    return this.link.getChain(this.chainId).client;\n  }\n  /** Restore a previously serialized session. */\n\n\n  static restore(link, data) {\n    switch (data.type) {\n      case 'channel':\n        return new LinkChannelSession(link, data.data, data.metadata);\n\n      case 'fallback':\n        return new LinkFallbackSession(link, data.data, data.metadata);\n\n      default:\n        throw new Error('Unable to restore, session data invalid');\n    }\n  }\n\n}\n/**\n * Link session that pushes requests over a channel.\n * @internal\n */\n\n\nclass LinkChannelSession extends LinkSession {\n  constructor(link, data, metadata) {\n    super();\n    this.type = 'channel';\n    this.timeout = 2 * 60 * 1000; // ms\n\n    this.link = link;\n    this.chainId = ChainId.from(data.chainId);\n    this.auth = PermissionLevel.from(data.auth);\n    this.publicKey = PublicKey.from(data.publicKey);\n    this.channel = data.channel;\n    this.identifier = Name.from(data.identifier);\n    const privateKey = PrivateKey.from(data.requestKey);\n    const publicKey = PublicKey.from(data.channel.key);\n\n    this.encrypt = request => {\n      return sealMessage(request.encode(true, false), privateKey, publicKey);\n    };\n\n    this.metadata = { ...(metadata || {}),\n      timeout: this.timeout,\n      name: this.channel.name\n    };\n\n    this.serialize = () => ({\n      type: 'channel',\n      data,\n      metadata: this.metadata\n    });\n  }\n\n  onSuccess(request, result) {\n    if (this.link.transport.onSuccess) {\n      this.link.transport.onSuccess(request, result);\n    }\n  }\n\n  onFailure(request, error) {\n    if (this.link.transport.onFailure) {\n      this.link.transport.onFailure(request, error);\n    }\n  }\n\n  onRequest(request, cancel) {\n    const info = LinkInfo.from({\n      expiration: new Date(Date.now() + this.timeout).toISOString().slice(0, -1)\n    });\n\n    if (this.link.transport.onSessionRequest) {\n      this.link.transport.onSessionRequest(this, request, cancel);\n    }\n\n    setTimeout(() => {\n      cancel(new SessionError('Wallet did not respond in time', 'E_TIMEOUT'));\n    }, this.timeout + 500);\n    request.setInfoKey('link', info);\n    let payloadSent = false;\n    const payload = Serializer.encode({\n      object: this.encrypt(request)\n    });\n\n    if (this.link.transport.sendSessionPayload) {\n      try {\n        payloadSent = this.link.transport.sendSessionPayload(payload, this);\n      } catch (error) {\n        // eslint-disable-next-line no-console\n        console.warn('Unexpected error when transport tried to send session payload', error);\n      }\n    }\n\n    if (payloadSent) {\n      return;\n    }\n\n    fetch(this.channel.url, {\n      method: 'POST',\n      headers: {\n        'X-Buoy-Wait': (this.timeout / 1000).toFixed(0)\n      },\n      body: payload.array\n    }).then(response => {\n      if (response.status !== 200) {\n        cancel(new SessionError('Unable to push message', 'E_DELIVERY'));\n      }\n    }).catch(error => {\n      cancel(new SessionError(`Unable to reach link service (${error.message || String(error)})`, 'E_DELIVERY'));\n    });\n  }\n\n  prepare(request) {\n    if (this.link.transport.prepare) {\n      return this.link.transport.prepare(request, this);\n    }\n\n    return Promise.resolve(request);\n  }\n\n  showLoading() {\n    if (this.link.transport.showLoading) {\n      return this.link.transport.showLoading();\n    }\n  }\n\n  makeSignatureProvider() {\n    return this.link.makeSignatureProvider([this.publicKey.toString()], this.chainId, this);\n  }\n\n  transact(args, options) {\n    return this.link.transact(args, { ...options,\n      chain: this.chainId\n    }, this);\n  }\n\n}\n/**\n * Link session that sends every request over the transport.\n * @internal\n */\n\n\nclass LinkFallbackSession extends LinkSession {\n  constructor(link, data, metadata) {\n    super();\n    this.type = 'fallback';\n    this.link = link;\n    this.auth = PermissionLevel.from(data.auth);\n    this.publicKey = PublicKey.from(data.publicKey);\n    this.chainId = ChainId.from(data.chainId);\n    this.metadata = metadata || {};\n    this.identifier = Name.from(data.identifier);\n\n    this.serialize = () => ({\n      type: this.type,\n      data,\n      metadata: this.metadata\n    });\n  }\n\n  onSuccess(request, result) {\n    if (this.link.transport.onSuccess) {\n      this.link.transport.onSuccess(request, result);\n    }\n  }\n\n  onFailure(request, error) {\n    if (this.link.transport.onFailure) {\n      this.link.transport.onFailure(request, error);\n    }\n  }\n\n  onRequest(request, cancel) {\n    if (this.link.transport.onSessionRequest) {\n      this.link.transport.onSessionRequest(this, request, cancel);\n    } else {\n      this.link.transport.onRequest(request, cancel);\n    }\n  }\n\n  prepare(request) {\n    if (this.link.transport.prepare) {\n      return this.link.transport.prepare(request, this);\n    }\n\n    return Promise.resolve(request);\n  }\n\n  showLoading() {\n    if (this.link.transport.showLoading) {\n      return this.link.transport.showLoading();\n    }\n  }\n\n  makeSignatureProvider() {\n    return this.link.makeSignatureProvider([this.publicKey.toString()], this.chainId, this);\n  }\n\n  transact(args, options) {\n    return this.link.transact(args, { ...options,\n      chain: this.chainId\n    }, this);\n  }\n\n}\n/** @internal */\n\n\nclass BuoyCallbackService {\n  constructor(address) {\n    this.address = address.trim().replace(/\\/$/, '');\n  }\n\n  create() {\n    const url = `${this.address}/${v4()}`;\n    return new BuoyCallback(url);\n  }\n\n}\n/** @internal */\n\n\nclass BuoyCallback {\n  constructor(url) {\n    this.url = url;\n    this.ctx = {};\n  }\n\n  wait() {\n    if (this.url.includes('hyperbuoy')) {\n      return pollForCallback(this.url, this.ctx);\n    } else {\n      return waitForCallback(this.url, this.ctx);\n    }\n  }\n\n  cancel() {\n    if (this.ctx.cancel) {\n      this.ctx.cancel();\n    }\n  }\n\n}\n/**\n * Connect to a WebSocket channel and wait for a message.\n * @internal\n */\n\n\nfunction waitForCallback(url, ctx) {\n  return new Promise((resolve, reject) => {\n    let active = true;\n    let retries = 0;\n    const socketUrl = url.replace(/^http/, 'ws');\n\n    const handleResponse = response => {\n      try {\n        resolve(JSON.parse(response));\n      } catch (error) {\n        error.message = 'Unable to parse callback JSON: ' + error.message;\n        reject(error);\n      }\n    };\n\n    const connect = () => {\n      const socket = new WebSocket(socketUrl);\n\n      ctx.cancel = () => {\n        active = false;\n\n        if (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING) {\n          socket.close();\n        }\n      };\n\n      socket.onmessage = event => {\n        active = false;\n\n        if (socket.readyState === WebSocket.OPEN) {\n          socket.close();\n        }\n\n        if (typeof Blob !== 'undefined' && event.data instanceof Blob) {\n          const reader = new FileReader();\n\n          reader.onload = () => {\n            handleResponse(reader.result);\n          };\n\n          reader.onerror = error => {\n            reject(error);\n          };\n\n          reader.readAsText(event.data);\n        } else {\n          if (typeof event.data === 'string') {\n            handleResponse(event.data);\n          } else {\n            handleResponse(event.data.toString());\n          }\n        }\n      };\n\n      socket.onopen = () => {\n        retries = 0;\n      };\n\n      socket.onclose = () => {\n        if (active) {\n          setTimeout(connect, backoff(retries++));\n        }\n      };\n    };\n\n    connect();\n  });\n}\n/**\n * Long-poll for message.\n * @internal\n */\n\n\nasync function pollForCallback(url, ctx) {\n  let active = true;\n\n  ctx.cancel = () => {\n    active = false;\n  };\n\n  while (active) {\n    try {\n      const res = await fetch(url);\n\n      if (res.status === 408) {\n        continue;\n      } else if (res.status === 200) {\n        return await res.json();\n      } else {\n        throw new Error(`HTTP ${res.status}: ${res.statusText}`);\n      }\n    } catch (error) {\n      // eslint-disable-next-line no-console\n      console.warn('Unexpected hyperbuoy error', error);\n    }\n\n    await sleep(1000);\n  }\n\n  return null;\n}\n/**\n * Exponential backoff function that caps off at 10s after 10 tries.\n * https://i.imgur.com/IrUDcJp.png\n * @internal\n */\n\n\nfunction backoff(tries) {\n  return Math.min(Math.pow(tries * 10, 2), 10 * 1000);\n}\n/**\n * Return promise that resolves after given milliseconds.\n * @internal\n */\n\n\nfunction sleep(ms) {\n  return new Promise(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n/**\n * Class representing a EOSIO chain.\n */\n\n\nclass LinkChain {\n  /** @internal */\n  constructor(chainId, clientOrUrl) {\n    this.abiCache = new Map();\n    this.pendingAbis = new Map();\n    this.chainId = ChainId.from(chainId);\n    this.client = typeof clientOrUrl === 'string' ? new APIClient({\n      url: clientOrUrl\n    }) : clientOrUrl;\n  }\n  /**\n   * Fetch the ABI for given account, cached.\n   * @internal\n   */\n\n\n  async getAbi(account) {\n    const key = String(account);\n    let rv = this.abiCache.get(key);\n\n    if (!rv) {\n      let getAbi = this.pendingAbis.get(key);\n\n      if (!getAbi) {\n        getAbi = this.client.v1.chain.get_abi(account);\n        this.pendingAbis.set(key, getAbi);\n      }\n\n      rv = (await getAbi).abi;\n      this.pendingAbis.delete(key);\n\n      if (rv) {\n        this.abiCache.set(key, rv);\n      }\n    }\n\n    return rv;\n  }\n\n}\n/**\n * Anchor Link main class.\n *\n * @example\n *\n * ```ts\n * import AnchorLink from 'anchor-link'\n * import ConsoleTransport from 'anchor-link-console-transport'\n *\n * const link = new AnchorLink({\n *     transport: new ConsoleTransport(),\n *     chains: [\n *         {\n *             chainId: 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906',\n *             nodeUrl: 'https://eos.greymass.com',\n *         },\n *     ],\n * })\n *\n * const result = await link.transact({actions: myActions})\n * ```\n */\n\n\nclass Link {\n  /** Create a new link instance. */\n  constructor(options) {\n    if (typeof options !== 'object') {\n      throw new TypeError('Missing options object');\n    }\n\n    if (!options.transport) {\n      throw new TypeError('options.transport is required');\n    }\n\n    let chains = options.chains || [];\n\n    if (options.chainId && options.client) {\n      chains = [{\n        chainId: options.chainId,\n        nodeUrl: options.client\n      }];\n    }\n\n    if (chains.length === 0) {\n      throw new TypeError('options.chains is required');\n    }\n\n    this.chains = chains.map(({\n      chainId,\n      nodeUrl\n    }) => {\n      if (!chainId) {\n        throw new Error('options.chains[].chainId is required');\n      }\n\n      if (!nodeUrl) {\n        throw new Error('options.chains[].nodeUrl is required');\n      }\n\n      return new LinkChain(chainId, nodeUrl);\n    });\n\n    if (options.service === undefined || typeof options.service === 'string') {\n      this.callbackService = new BuoyCallbackService(options.service || LinkOptions.defaults.service);\n    } else {\n      this.callbackService = options.service;\n    }\n\n    this.transport = options.transport;\n\n    if (options.storage !== null) {\n      this.storage = options.storage || this.transport.storage;\n    }\n\n    this.verifyProofs = options.verifyProofs !== undefined ? options.verifyProofs : LinkOptions.defaults.verifyProofs;\n    this.encodeChainIds = options.encodeChainIds !== undefined ? options.encodeChainIds : LinkOptions.defaults.encodeChainIds;\n  }\n  /**\n   * The APIClient instance for communicating with the node.\n   * @note This returns the first APIClient when link is configured with multiple chains.\n   */\n\n\n  get client() {\n    return this.chains[0].client;\n  }\n  /**\n   * Return a [[LinkChain]] object for given chainId or chain reference.\n   * @throws If this link instance has no configured chain for given reference.\n   * @internal\n   */\n\n\n  getChain(chain) {\n    if (chain instanceof LinkChain) {\n      return chain;\n    }\n\n    if (typeof chain === 'number') {\n      const rv = this.chains[chain];\n\n      if (!rv) {\n        throw new Error(`Invalid chain index: ${chain}`);\n      }\n\n      return rv;\n    }\n\n    const id = ChainId.from(chain);\n    const rv = this.chains.find(c => c.chainId.equals(id));\n\n    if (!rv) {\n      throw new Error(`Unsupported chain: ${id}`);\n    }\n\n    return rv;\n  }\n  /**\n   * Create a SigningRequest instance configured for this link.\n   * @internal\n   */\n\n\n  async createRequest(args, chain, transport) {\n    const t = transport || this.transport;\n    let request;\n\n    if (chain || this.chains.length === 1) {\n      const c = chain || this.chains[0];\n      request = await SigningRequest.create({ ...args,\n        chainId: c.chainId,\n        broadcast: false\n      }, {\n        abiProvider: c,\n        zlib\n      });\n    } else {\n      // multi-chain request\n      request = await SigningRequest.create({ ...args,\n        chainId: null,\n        chainIds: this.encodeChainIds ? this.chains.map(c => c.chainId) : undefined,\n        broadcast: false\n      }, // abi's will be pulled from the first chain and assumed to be identical on all chains\n      {\n        abiProvider: this.chains[0],\n        zlib\n      });\n    }\n\n    if (t.prepare) {\n      request = await t.prepare(request);\n    }\n\n    const callback = this.callbackService.create();\n    request.setCallback(callback.url, true);\n    return {\n      request,\n      callback\n    };\n  }\n  /**\n   * Send a SigningRequest instance using this link.\n   * @internal\n   */\n\n\n  async sendRequest(request, callback, chain, transport, broadcast = false) {\n    const t = transport || this.transport;\n\n    try {\n      const linkUrl = request.data.callback;\n\n      if (linkUrl !== callback.url) {\n        throw new Error('Invalid request callback');\n      }\n\n      if (request.data.flags.broadcast === true || request.data.flags.background === false) {\n        throw new Error('Invalid request flags');\n      } // wait for callback or user cancel\n\n\n      const cancel = new Promise((resolve, reject) => {\n        t.onRequest(request, reason => {\n          callback.cancel();\n\n          if (typeof reason === 'string') {\n            reject(new CancelError(reason));\n          } else {\n            reject(reason);\n          }\n        });\n      });\n      const callbackResponse = await Promise.race([callback.wait(), cancel]);\n\n      if (typeof callbackResponse.rejected === 'string') {\n        throw new CancelError(callbackResponse.rejected);\n      }\n\n      const payload = callbackResponse;\n      const signer = PermissionLevel.from({\n        actor: payload.sa,\n        permission: payload.sp\n      });\n      const signatures = Object.keys(payload).filter(key => key.startsWith('sig') && key !== 'sig0').map(key => Signature.from(payload[key]));\n      let c;\n\n      if (!chain && this.chains.length > 1) {\n        if (!payload.cid) {\n          throw new Error('Multi chain response payload must specify resolved chain id (cid)');\n        }\n\n        c = this.getChain(payload.cid);\n      } else {\n        c = chain || this.getChain(0);\n\n        if (payload.cid && !c.chainId.equals(payload.cid)) {\n          throw new Error('Got response for wrong chain id');\n        }\n      } // recreate transaction from request response\n\n\n      const resolved = await ResolvedSigningRequest.fromPayload(payload, {\n        zlib,\n        abiProvider: c\n      }); // prepend cosigner signature if present\n\n      const cosignerSig = resolved.request.getInfoKey('cosig', {\n        type: Signature,\n        array: true\n      });\n\n      if (cosignerSig) {\n        signatures.unshift(...cosignerSig);\n      }\n\n      const result = {\n        resolved,\n        chain: c,\n        transaction: resolved.transaction,\n        resolvedTransaction: resolved.resolvedTransaction,\n        signatures,\n        payload,\n        signer\n      };\n\n      if (broadcast) {\n        const signedTx = SignedTransaction.from({ ...resolved.transaction,\n          signatures\n        });\n        const res = await c.client.v1.chain.push_transaction(signedTx);\n        result.processed = res.processed;\n      }\n\n      if (t.onSuccess) {\n        t.onSuccess(request, result);\n      }\n\n      return result;\n    } catch (error) {\n      if (t.onFailure) {\n        t.onFailure(request, error);\n      }\n\n      throw error;\n    }\n  }\n  /**\n   * Sign and optionally broadcast a EOSIO transaction, action or actions.\n   *\n   * Example:\n   *\n   * ```ts\n   * let result = await myLink.transact({transaction: myTx})\n   * ```\n   *\n   * @param args The action, actions or transaction to use.\n   * @param options Options for this transact call.\n   * @param transport Transport override, for internal use.\n   */\n\n\n  async transact(args, options, transport) {\n    const o = options || {};\n    const t = transport || this.transport;\n    const c = o.chain !== undefined ? this.getChain(o.chain) : undefined;\n    const broadcast = o.broadcast !== false;\n    const noModify = o.noModify !== undefined ? o.noModify : !broadcast; // Initialize the loading state of the transport\n\n    if (t && t.showLoading) {\n      t.showLoading();\n    } // eosjs transact compat: upgrade to transaction if args have any header fields\n\n\n    const anyArgs = args;\n\n    if (args.actions && (anyArgs.expiration || anyArgs.ref_block_num || anyArgs.ref_block_prefix || anyArgs.max_net_usage_words || anyArgs.max_cpu_usage_ms || anyArgs.delay_sec)) {\n      args = {\n        transaction: {\n          expiration: '1970-01-01T00:00:00',\n          ref_block_num: 0,\n          ref_block_prefix: 0,\n          max_net_usage_words: 0,\n          max_cpu_usage_ms: 0,\n          delay_sec: 0,\n          ...anyArgs\n        }\n      };\n    }\n\n    const {\n      request,\n      callback\n    } = await this.createRequest(args, c, t);\n\n    if (noModify) {\n      request.setInfoKey('no_modify', true, 'bool');\n    }\n\n    const result = await this.sendRequest(request, callback, c, t, broadcast);\n    return result;\n  }\n  /**\n   * Send an identity request and verify the identity proof if [[LinkOptions.verifyProofs]] is true.\n   * @param args.scope The scope of the identity request.\n   * @param args.requestPermission Optional request permission if the request is for a specific account or permission.\n   * @param args.info Metadata to add to the request.\n   * @note This is for advanced use-cases, you probably want to use [[Link.login]] instead.\n   */\n\n\n  async identify(args) {\n    const {\n      request,\n      callback\n    } = await this.createRequest({\n      identity: {\n        permission: args.requestPermission,\n        scope: args.scope\n      },\n      info: args.info\n    });\n    const res = await this.sendRequest(request, callback);\n\n    if (!res.resolved.request.isIdentity()) {\n      throw new IdentityError('Unexpected response');\n    }\n\n    let account;\n    const proof = res.resolved.getIdentityProof(res.signatures[0]);\n\n    if (this.verifyProofs) {\n      account = await res.chain.client.v1.chain.get_account(res.signer.actor);\n\n      if (!account) {\n        throw new IdentityError(`Signature from unknown account: ${proof.signer.actor}`);\n      }\n\n      const accountPermission = account.permissions.find(({\n        perm_name\n      }) => proof.signer.permission.equals(perm_name));\n\n      if (!accountPermission) {\n        throw new IdentityError(`${proof.signer.actor} signed for unknown permission: ${proof.signer.permission}`);\n      }\n\n      const proofValid = proof.verify(accountPermission.required_auth, account.head_block_time);\n\n      if (!proofValid) {\n        throw new IdentityError(`Invalid identify proof for: ${proof.signer}`);\n      }\n    }\n\n    if (args.requestPermission) {\n      const perm = PermissionLevel.from(args.requestPermission);\n\n      if (!perm.actor.equals(PlaceholderName) && !perm.actor.equals(proof.signer.actor) || !perm.permission.equals(PlaceholderPermission) && !perm.permission.equals(proof.signer.permission)) {\n        throw new IdentityError(`Identity proof singed by ${proof.signer}, expected: ${formatAuth(perm)} `);\n      }\n    }\n\n    return { ...res,\n      account,\n      proof\n    };\n  }\n  /**\n   * Login and create a persistent session.\n   * @param identifier The session identifier, an EOSIO name (`[a-z1-5]{1,12}`).\n   *                   Should be set to the contract account if applicable.\n   */\n\n\n  async login(identifier) {\n    const privateKey = PrivateKey.generate('K1');\n    const requestKey = privateKey.toPublic();\n    const createInfo = LinkCreate.from({\n      session_name: identifier,\n      request_key: requestKey,\n      user_agent: this.getUserAgent()\n    });\n    const res = await this.identify({\n      scope: identifier,\n      info: {\n        link: createInfo,\n        scope: identifier\n      }\n    });\n    const metadata = {\n      // backwards compat, can be removed next major release\n      sameDevice: res.resolved.request.getRawInfo()['return_path'] !== undefined\n    }; // append extra metadata from the signer\n\n    if (res.payload.link_meta) {\n      try {\n        const parsed = JSON.parse(res.payload.link_meta);\n\n        for (const key of Object.keys(parsed)) {\n          // normalize key names to camelCase\n          metadata[snakeToCamel(key)] = parsed[key];\n        }\n      } catch (error) {\n        // eslint-disable-next-line no-console\n        console.warn('Unable to parse link metadata', error, res.payload.link_meta);\n      }\n    }\n\n    const signerKey = res.proof.recover();\n    let session;\n\n    if (res.payload.link_ch && res.payload.link_key && res.payload.link_name) {\n      session = new LinkChannelSession(this, {\n        identifier,\n        chainId: res.chain.chainId,\n        auth: res.signer,\n        publicKey: signerKey,\n        channel: {\n          url: res.payload.link_ch,\n          key: res.payload.link_key,\n          name: res.payload.link_name\n        },\n        requestKey: privateKey\n      }, metadata);\n    } else {\n      session = new LinkFallbackSession(this, {\n        identifier,\n        chainId: res.chain.chainId,\n        auth: res.signer,\n        publicKey: signerKey\n      }, metadata);\n    }\n\n    if (this.storage) {\n      await this.storeSession(identifier, session);\n    }\n\n    return { ...res,\n      session\n    };\n  }\n  /**\n   * Restore previous session, use [[login]] to create a new session.\n   * @param identifier The session identifier, must be same as what was used when creating the session with [[login]].\n   * @param auth A specific session auth to restore, if omitted the most recently used session will be restored.\n   * @param chainId If given function will only consider that specific chain when restoring session.\n   * @returns A [[LinkSession]] instance or null if no session can be found.\n   * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session data.\n   **/\n\n\n  async restoreSession(identifier, auth, chainId) {\n    if (!this.storage) {\n      throw new Error('Unable to restore session: No storage adapter configured');\n    }\n\n    let key;\n\n    if (auth && chainId) {\n      // both auth and chain id given, we can look up on specific key\n      key = this.sessionKey(identifier, formatAuth(PermissionLevel.from(auth)), String(ChainId.from(chainId)));\n    } else {\n      // otherwise we use the session list to filter down to most recently used matching given params\n      let list = await this.listSessions(identifier);\n\n      if (auth) {\n        list = list.filter(item => item.auth.equals(auth));\n      }\n\n      if (chainId) {\n        const id = ChainId.from(chainId);\n        list = list.filter(item => item.chainId.equals(id));\n      }\n\n      const latest = list[0];\n\n      if (!latest) {\n        return null;\n      }\n\n      key = this.sessionKey(identifier, formatAuth(latest.auth), String(latest.chainId));\n    }\n\n    const data = await this.storage.read(key);\n\n    if (!data) {\n      return null;\n    }\n\n    let sessionData;\n\n    try {\n      sessionData = JSON.parse(data);\n    } catch (error) {\n      throw new Error(`Unable to restore session: Stored JSON invalid (${error.message || String(error)})`);\n    }\n\n    const session = LinkSession.restore(this, sessionData);\n\n    if (auth || chainId) {\n      // update latest used\n      await this.touchSession(identifier, session.auth, session.chainId);\n    }\n\n    return session;\n  }\n  /**\n   * List stored session auths for given identifier.\n   * The most recently used session is at the top (index 0).\n   * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session list.\n   **/\n\n\n  async listSessions(identifier) {\n    if (!this.storage) {\n      throw new Error('Unable to list sessions: No storage adapter configured');\n    }\n\n    const key = this.sessionKey(identifier, 'list');\n    let list;\n\n    try {\n      list = JSON.parse((await this.storage.read(key)) || '[]');\n    } catch (error) {\n      throw new Error(`Unable to list sessions: ${error.message || String(error)}`);\n    }\n\n    return list.map(({\n      auth,\n      chainId\n    }) => ({\n      auth: PermissionLevel.from(auth),\n      chainId: ChainId.from(chainId)\n    }));\n  }\n  /**\n   * Remove stored session for given identifier and auth.\n   * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.\n   */\n\n\n  async removeSession(identifier, auth, chainId) {\n    if (!this.storage) {\n      throw new Error('Unable to remove session: No storage adapter configured');\n    }\n\n    const key = this.sessionKey(identifier, formatAuth(auth), String(chainId));\n    await this.storage.remove(key);\n    await this.touchSession(identifier, auth, chainId, true);\n  }\n  /**\n   * Remove all stored sessions for given identifier.\n   * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.\n   */\n\n\n  async clearSessions(identifier) {\n    if (!this.storage) {\n      throw new Error('Unable to clear sessions: No storage adapter configured');\n    }\n\n    for (const {\n      auth,\n      chainId\n    } of await this.listSessions(identifier)) {\n      await this.removeSession(identifier, auth, chainId);\n    }\n  }\n  /**\n   * Create an eosjs compatible signature provider using this link.\n   * @param availableKeys Keys the created provider will claim to be able to sign for.\n   * @param chain Chain to use when configured with multiple chains.\n   * @param transport (internal) Transport override for this call.\n   * @note We don't know what keys are available so those have to be provided,\n   *       to avoid this use [[LinkSession.makeSignatureProvider]] instead. Sessions can be created with [[Link.login]].\n   */\n\n\n  makeSignatureProvider(availableKeys, chain, transport) {\n    return {\n      getAvailableKeys: async () => availableKeys,\n      sign: async args => {\n        const t = transport || this.transport;\n        const c = chain ? this.getChain(chain) : this.chains[0];\n        let request = SigningRequest.fromTransaction(args.chainId, args.serializedTransaction, {\n          abiProvider: c,\n          zlib\n        });\n        const callback = this.callbackService.create();\n        request.setCallback(callback.url, true);\n        request.setBroadcast(false);\n\n        if (t.prepare) {\n          request = await t.prepare(request);\n        }\n\n        const {\n          transaction,\n          signatures\n        } = await this.sendRequest(request, callback, c, t);\n        const serializedTransaction = Serializer.encode({\n          object: transaction\n        });\n        return { ...args,\n          serializedTransaction,\n          signatures\n        };\n      }\n    };\n  }\n  /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */\n\n\n  async touchSession(identifier, auth, chainId, remove = false) {\n    const list = await this.listSessions(identifier);\n    const existing = list.findIndex(item => item.auth.equals(auth) && item.chainId.equals(chainId));\n\n    if (existing >= 0) {\n      list.splice(existing, 1);\n    }\n\n    if (remove === false) {\n      list.unshift({\n        auth,\n        chainId\n      });\n    }\n\n    const key = this.sessionKey(identifier, 'list');\n    await this.storage.write(key, JSON.stringify(list));\n  }\n  /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */\n\n\n  async storeSession(identifier, session) {\n    const key = this.sessionKey(identifier, formatAuth(session.auth), String(session.chainId));\n    const data = JSON.stringify(session.serialize());\n    await this.storage.write(key, data);\n    await this.touchSession(identifier, session.auth, session.chainId);\n  }\n  /** Session storage key for identifier and suffix. */\n\n\n  sessionKey(identifier, ...suffix) {\n    return [String(Name.from(identifier)), ...suffix].join('-');\n  }\n  /** Return user agent of this link. */\n\n\n  getUserAgent() {\n    let rv = `AnchorLink/${Link.version}`;\n\n    if (this.transport.userAgent) {\n      rv += ' ' + this.transport.userAgent();\n    }\n\n    return rv;\n  }\n\n}\n/** Package version. */\n\n\nLink.version = '3.2.2'; // eslint-disable-line @typescript-eslint/no-inferrable-types\n\n/**\n * Format a EOSIO permission level in the format `actor@permission` taking placeholders into consideration.\n * @internal\n */\n\nfunction formatAuth(auth) {\n  const a = PermissionLevel.from(auth);\n  const actor = a.actor.equals(PlaceholderName) ? '<any>' : String(a.actor);\n  let permission;\n\n  if (a.permission.equals(PlaceholderName) || a.permission.equals(PlaceholderPermission)) {\n    permission = '<any>';\n  } else {\n    permission = String(a.permission);\n  }\n\n  return `${actor}@${permission}`;\n}\n/**\n * Return PascalCase version of snake_case string.\n * @internal\n */\n\n\nfunction snakeToPascal(name) {\n  return name.split('_').map(v => (v[0] ? v[0].toUpperCase() : '_') + v.slice(1)).join('');\n}\n/**\n * Return camelCase version of snake_case string.\n * @internal\n */\n\n\nfunction snakeToCamel(name) {\n  const pascal = snakeToPascal(name);\n  return pascal[0].toLowerCase() + pascal.slice(1);\n} // export library\n\n\nexport default Link;\nexport { CancelError, IdentityError, Link, LinkChain, LinkChannelSession, LinkFallbackSession, LinkSession, SessionError };","map":{"version":3,"sources":["../src/errors.ts","../src/link-options.ts","../src/link-types.ts","../src/utils.ts","../src/link-session.ts","../src/link-callback.ts","../src/link.ts","../src/index.ts"],"names":["uuid"],"mappings":"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","sourcesContent":["/**\n * Anchor Link v3.2.2\n * https://github.com/greymass/anchor-link\n *\n * @license\n * Copyright (c) 2020 Greymass Inc. All Rights Reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \n *  1. Redistribution of source code must retain the above copyright notice, this\n *     list of conditions and the following disclaimer.\n * \n *  2. Redistribution in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n * \n *  3. Neither the name of the copyright holder nor the names of its contributors\n *     may be used to endorse or promote products derived from this software without\n *     specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE\n * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.\n */\nimport zlib from 'pako';\nimport { Struct, UInt64, Checksum512, Serializer, Bytes, Checksum256, PermissionLevel, PublicKey, Name, PrivateKey, APIClient, Signature, SignedTransaction } from '@greymass/eosio';\nexport * from '@greymass/eosio';\nimport { ChainId, SigningRequest, ResolvedSigningRequest, PlaceholderName, PlaceholderPermission } from 'eosio-signing-request';\nexport * from 'eosio-signing-request';\nexport { ChainId, ChainName, IdentityProof } from 'eosio-signing-request';\nimport { __decorate } from 'tslib';\nimport makeFetch from 'fetch-ponyfill';\nimport { AES_CBC } from 'asmcrypto.js';\nimport { v4 } from 'uuid';\nimport WebSocket from 'isomorphic-ws';\n\n/**\n * Error that is thrown if a [[LinkTransport]] cancels a request.\n * @internal\n */\nclass CancelError extends Error {\n    constructor(reason) {\n        super(`User canceled request ${reason ? '(' + reason + ')' : ''}`);\n        this.code = 'E_CANCEL';\n    }\n}\n/**\n * Error that is thrown if an identity request fails to verify.\n * @internal\n */\nclass IdentityError extends Error {\n    constructor(reason) {\n        super(`Unable to verify identity ${reason ? '(' + reason + ')' : ''}`);\n        this.code = 'E_IDENTITY';\n    }\n}\n/**\n * Error originating from a [[LinkSession]].\n * @internal\n */\nclass SessionError extends Error {\n    constructor(reason, code) {\n        super(reason);\n        this.code = code;\n    }\n}\n\n/** @internal */\nvar LinkOptions;\n(function (LinkOptions) {\n    /** @internal */\n    LinkOptions.defaults = {\n        service: 'https://cb.anchor.link',\n        verifyProofs: false,\n        encodeChainIds: true,\n    };\n})(LinkOptions || (LinkOptions = {}));\n\nlet SealedMessage = class SealedMessage extends Struct {\n};\n__decorate([\n    Struct.field('public_key')\n], SealedMessage.prototype, \"from\", void 0);\n__decorate([\n    Struct.field('uint64')\n], SealedMessage.prototype, \"nonce\", void 0);\n__decorate([\n    Struct.field('bytes')\n], SealedMessage.prototype, \"ciphertext\", void 0);\n__decorate([\n    Struct.field('uint32')\n], SealedMessage.prototype, \"checksum\", void 0);\nSealedMessage = __decorate([\n    Struct.type('sealed_message')\n], SealedMessage);\nlet LinkCreate = class LinkCreate extends Struct {\n};\n__decorate([\n    Struct.field('name')\n], LinkCreate.prototype, \"session_name\", void 0);\n__decorate([\n    Struct.field('public_key')\n], LinkCreate.prototype, \"request_key\", void 0);\n__decorate([\n    Struct.field('string', { extension: true })\n], LinkCreate.prototype, \"user_agent\", void 0);\nLinkCreate = __decorate([\n    Struct.type('link_create')\n], LinkCreate);\nlet LinkInfo = class LinkInfo extends Struct {\n};\n__decorate([\n    Struct.field('time_point_sec')\n], LinkInfo.prototype, \"expiration\", void 0);\nLinkInfo = __decorate([\n    Struct.type('link_info')\n], LinkInfo);\n\n/** @internal */\nconst fetch = makeFetch().fetch;\n/**\n * Encrypt a message using AES and shared secret derived from given keys.\n * @internal\n */\nfunction sealMessage(message, privateKey, publicKey, nonce) {\n    const secret = privateKey.sharedSecret(publicKey);\n    if (!nonce) {\n        nonce = UInt64.random();\n    }\n    const key = Checksum512.hash(Serializer.encode({ object: nonce }).appending(secret.array));\n    const cbc = new AES_CBC(key.array.slice(0, 32), key.array.slice(32, 48));\n    const ciphertext = Bytes.from(cbc.encrypt(Bytes.from(message, 'utf8').array));\n    const checksumView = new DataView(Checksum256.hash(key.array).array.buffer);\n    const checksum = checksumView.getUint32(0, true);\n    return SealedMessage.from({\n        from: privateKey.toPublic(),\n        nonce,\n        ciphertext,\n        checksum,\n    });\n}\n\n/**\n * Type describing a link session that can create a eosjs compatible\n * signature provider and transact for a specific auth.\n */\nclass LinkSession {\n    /** @internal */\n    constructor() { } // eslint-disable-line @typescript-eslint/no-empty-function\n    /**\n     * Convenience, remove this session from associated [[Link]] storage if set.\n     * Equivalent to:\n     * ```ts\n     * session.link.removeSession(session.identifier, session.auth, session.chainId)\n     * ```\n     */\n    async remove() {\n        if (this.link.storage) {\n            await this.link.removeSession(this.identifier, this.auth, this.chainId);\n        }\n    }\n    /** API client for the chain this session is valid on. */\n    get client() {\n        return this.link.getChain(this.chainId).client;\n    }\n    /** Restore a previously serialized session. */\n    static restore(link, data) {\n        switch (data.type) {\n            case 'channel':\n                return new LinkChannelSession(link, data.data, data.metadata);\n            case 'fallback':\n                return new LinkFallbackSession(link, data.data, data.metadata);\n            default:\n                throw new Error('Unable to restore, session data invalid');\n        }\n    }\n}\n/**\n * Link session that pushes requests over a channel.\n * @internal\n */\nclass LinkChannelSession extends LinkSession {\n    constructor(link, data, metadata) {\n        super();\n        this.type = 'channel';\n        this.timeout = 2 * 60 * 1000; // ms\n        this.link = link;\n        this.chainId = ChainId.from(data.chainId);\n        this.auth = PermissionLevel.from(data.auth);\n        this.publicKey = PublicKey.from(data.publicKey);\n        this.channel = data.channel;\n        this.identifier = Name.from(data.identifier);\n        const privateKey = PrivateKey.from(data.requestKey);\n        const publicKey = PublicKey.from(data.channel.key);\n        this.encrypt = (request) => {\n            return sealMessage(request.encode(true, false), privateKey, publicKey);\n        };\n        this.metadata = {\n            ...(metadata || {}),\n            timeout: this.timeout,\n            name: this.channel.name,\n        };\n        this.serialize = () => ({\n            type: 'channel',\n            data,\n            metadata: this.metadata,\n        });\n    }\n    onSuccess(request, result) {\n        if (this.link.transport.onSuccess) {\n            this.link.transport.onSuccess(request, result);\n        }\n    }\n    onFailure(request, error) {\n        if (this.link.transport.onFailure) {\n            this.link.transport.onFailure(request, error);\n        }\n    }\n    onRequest(request, cancel) {\n        const info = LinkInfo.from({\n            expiration: new Date(Date.now() + this.timeout).toISOString().slice(0, -1),\n        });\n        if (this.link.transport.onSessionRequest) {\n            this.link.transport.onSessionRequest(this, request, cancel);\n        }\n        setTimeout(() => {\n            cancel(new SessionError('Wallet did not respond in time', 'E_TIMEOUT'));\n        }, this.timeout + 500);\n        request.setInfoKey('link', info);\n        let payloadSent = false;\n        const payload = Serializer.encode({ object: this.encrypt(request) });\n        if (this.link.transport.sendSessionPayload) {\n            try {\n                payloadSent = this.link.transport.sendSessionPayload(payload, this);\n            }\n            catch (error) {\n                // eslint-disable-next-line no-console\n                console.warn('Unexpected error when transport tried to send session payload', error);\n            }\n        }\n        if (payloadSent) {\n            return;\n        }\n        fetch(this.channel.url, {\n            method: 'POST',\n            headers: {\n                'X-Buoy-Wait': (this.timeout / 1000).toFixed(0),\n            },\n            body: payload.array,\n        })\n            .then((response) => {\n            if (response.status !== 200) {\n                cancel(new SessionError('Unable to push message', 'E_DELIVERY'));\n            }\n        })\n            .catch((error) => {\n            cancel(new SessionError(`Unable to reach link service (${error.message || String(error)})`, 'E_DELIVERY'));\n        });\n    }\n    prepare(request) {\n        if (this.link.transport.prepare) {\n            return this.link.transport.prepare(request, this);\n        }\n        return Promise.resolve(request);\n    }\n    showLoading() {\n        if (this.link.transport.showLoading) {\n            return this.link.transport.showLoading();\n        }\n    }\n    makeSignatureProvider() {\n        return this.link.makeSignatureProvider([this.publicKey.toString()], this.chainId, this);\n    }\n    transact(args, options) {\n        return this.link.transact(args, { ...options, chain: this.chainId }, this);\n    }\n}\n/**\n * Link session that sends every request over the transport.\n * @internal\n */\nclass LinkFallbackSession extends LinkSession {\n    constructor(link, data, metadata) {\n        super();\n        this.type = 'fallback';\n        this.link = link;\n        this.auth = PermissionLevel.from(data.auth);\n        this.publicKey = PublicKey.from(data.publicKey);\n        this.chainId = ChainId.from(data.chainId);\n        this.metadata = metadata || {};\n        this.identifier = Name.from(data.identifier);\n        this.serialize = () => ({\n            type: this.type,\n            data,\n            metadata: this.metadata,\n        });\n    }\n    onSuccess(request, result) {\n        if (this.link.transport.onSuccess) {\n            this.link.transport.onSuccess(request, result);\n        }\n    }\n    onFailure(request, error) {\n        if (this.link.transport.onFailure) {\n            this.link.transport.onFailure(request, error);\n        }\n    }\n    onRequest(request, cancel) {\n        if (this.link.transport.onSessionRequest) {\n            this.link.transport.onSessionRequest(this, request, cancel);\n        }\n        else {\n            this.link.transport.onRequest(request, cancel);\n        }\n    }\n    prepare(request) {\n        if (this.link.transport.prepare) {\n            return this.link.transport.prepare(request, this);\n        }\n        return Promise.resolve(request);\n    }\n    showLoading() {\n        if (this.link.transport.showLoading) {\n            return this.link.transport.showLoading();\n        }\n    }\n    makeSignatureProvider() {\n        return this.link.makeSignatureProvider([this.publicKey.toString()], this.chainId, this);\n    }\n    transact(args, options) {\n        return this.link.transact(args, { ...options, chain: this.chainId }, this);\n    }\n}\n\n/** @internal */\nclass BuoyCallbackService {\n    constructor(address) {\n        this.address = address.trim().replace(/\\/$/, '');\n    }\n    create() {\n        const url = `${this.address}/${v4()}`;\n        return new BuoyCallback(url);\n    }\n}\n/** @internal */\nclass BuoyCallback {\n    constructor(url) {\n        this.url = url;\n        this.ctx = {};\n    }\n    wait() {\n        if (this.url.includes('hyperbuoy')) {\n            return pollForCallback(this.url, this.ctx);\n        }\n        else {\n            return waitForCallback(this.url, this.ctx);\n        }\n    }\n    cancel() {\n        if (this.ctx.cancel) {\n            this.ctx.cancel();\n        }\n    }\n}\n/**\n * Connect to a WebSocket channel and wait for a message.\n * @internal\n */\nfunction waitForCallback(url, ctx) {\n    return new Promise((resolve, reject) => {\n        let active = true;\n        let retries = 0;\n        const socketUrl = url.replace(/^http/, 'ws');\n        const handleResponse = (response) => {\n            try {\n                resolve(JSON.parse(response));\n            }\n            catch (error) {\n                error.message = 'Unable to parse callback JSON: ' + error.message;\n                reject(error);\n            }\n        };\n        const connect = () => {\n            const socket = new WebSocket(socketUrl);\n            ctx.cancel = () => {\n                active = false;\n                if (socket.readyState === WebSocket.OPEN ||\n                    socket.readyState === WebSocket.CONNECTING) {\n                    socket.close();\n                }\n            };\n            socket.onmessage = (event) => {\n                active = false;\n                if (socket.readyState === WebSocket.OPEN) {\n                    socket.close();\n                }\n                if (typeof Blob !== 'undefined' && event.data instanceof Blob) {\n                    const reader = new FileReader();\n                    reader.onload = () => {\n                        handleResponse(reader.result);\n                    };\n                    reader.onerror = (error) => {\n                        reject(error);\n                    };\n                    reader.readAsText(event.data);\n                }\n                else {\n                    if (typeof event.data === 'string') {\n                        handleResponse(event.data);\n                    }\n                    else {\n                        handleResponse(event.data.toString());\n                    }\n                }\n            };\n            socket.onopen = () => {\n                retries = 0;\n            };\n            socket.onclose = () => {\n                if (active) {\n                    setTimeout(connect, backoff(retries++));\n                }\n            };\n        };\n        connect();\n    });\n}\n/**\n * Long-poll for message.\n * @internal\n */\nasync function pollForCallback(url, ctx) {\n    let active = true;\n    ctx.cancel = () => {\n        active = false;\n    };\n    while (active) {\n        try {\n            const res = await fetch(url);\n            if (res.status === 408) {\n                continue;\n            }\n            else if (res.status === 200) {\n                return await res.json();\n            }\n            else {\n                throw new Error(`HTTP ${res.status}: ${res.statusText}`);\n            }\n        }\n        catch (error) {\n            // eslint-disable-next-line no-console\n            console.warn('Unexpected hyperbuoy error', error);\n        }\n        await sleep(1000);\n    }\n    return null;\n}\n/**\n * Exponential backoff function that caps off at 10s after 10 tries.\n * https://i.imgur.com/IrUDcJp.png\n * @internal\n */\nfunction backoff(tries) {\n    return Math.min(Math.pow(tries * 10, 2), 10 * 1000);\n}\n/**\n * Return promise that resolves after given milliseconds.\n * @internal\n */\nfunction sleep(ms) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, ms);\n    });\n}\n\n/**\n * Class representing a EOSIO chain.\n */\nclass LinkChain {\n    /** @internal */\n    constructor(chainId, clientOrUrl) {\n        this.abiCache = new Map();\n        this.pendingAbis = new Map();\n        this.chainId = ChainId.from(chainId);\n        this.client =\n            typeof clientOrUrl === 'string' ? new APIClient({ url: clientOrUrl }) : clientOrUrl;\n    }\n    /**\n     * Fetch the ABI for given account, cached.\n     * @internal\n     */\n    async getAbi(account) {\n        const key = String(account);\n        let rv = this.abiCache.get(key);\n        if (!rv) {\n            let getAbi = this.pendingAbis.get(key);\n            if (!getAbi) {\n                getAbi = this.client.v1.chain.get_abi(account);\n                this.pendingAbis.set(key, getAbi);\n            }\n            rv = (await getAbi).abi;\n            this.pendingAbis.delete(key);\n            if (rv) {\n                this.abiCache.set(key, rv);\n            }\n        }\n        return rv;\n    }\n}\n/**\n * Anchor Link main class.\n *\n * @example\n *\n * ```ts\n * import AnchorLink from 'anchor-link'\n * import ConsoleTransport from 'anchor-link-console-transport'\n *\n * const link = new AnchorLink({\n *     transport: new ConsoleTransport(),\n *     chains: [\n *         {\n *             chainId: 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906',\n *             nodeUrl: 'https://eos.greymass.com',\n *         },\n *     ],\n * })\n *\n * const result = await link.transact({actions: myActions})\n * ```\n */\nclass Link {\n    /** Create a new link instance. */\n    constructor(options) {\n        if (typeof options !== 'object') {\n            throw new TypeError('Missing options object');\n        }\n        if (!options.transport) {\n            throw new TypeError('options.transport is required');\n        }\n        let chains = options.chains || [];\n        if (options.chainId && options.client) {\n            chains = [{ chainId: options.chainId, nodeUrl: options.client }];\n        }\n        if (chains.length === 0) {\n            throw new TypeError('options.chains is required');\n        }\n        this.chains = chains.map(({ chainId, nodeUrl }) => {\n            if (!chainId) {\n                throw new Error('options.chains[].chainId is required');\n            }\n            if (!nodeUrl) {\n                throw new Error('options.chains[].nodeUrl is required');\n            }\n            return new LinkChain(chainId, nodeUrl);\n        });\n        if (options.service === undefined || typeof options.service === 'string') {\n            this.callbackService = new BuoyCallbackService(options.service || LinkOptions.defaults.service);\n        }\n        else {\n            this.callbackService = options.service;\n        }\n        this.transport = options.transport;\n        if (options.storage !== null) {\n            this.storage = options.storage || this.transport.storage;\n        }\n        this.verifyProofs =\n            options.verifyProofs !== undefined\n                ? options.verifyProofs\n                : LinkOptions.defaults.verifyProofs;\n        this.encodeChainIds =\n            options.encodeChainIds !== undefined\n                ? options.encodeChainIds\n                : LinkOptions.defaults.encodeChainIds;\n    }\n    /**\n     * The APIClient instance for communicating with the node.\n     * @note This returns the first APIClient when link is configured with multiple chains.\n     */\n    get client() {\n        return this.chains[0].client;\n    }\n    /**\n     * Return a [[LinkChain]] object for given chainId or chain reference.\n     * @throws If this link instance has no configured chain for given reference.\n     * @internal\n     */\n    getChain(chain) {\n        if (chain instanceof LinkChain) {\n            return chain;\n        }\n        if (typeof chain === 'number') {\n            const rv = this.chains[chain];\n            if (!rv) {\n                throw new Error(`Invalid chain index: ${chain}`);\n            }\n            return rv;\n        }\n        const id = ChainId.from(chain);\n        const rv = this.chains.find((c) => c.chainId.equals(id));\n        if (!rv) {\n            throw new Error(`Unsupported chain: ${id}`);\n        }\n        return rv;\n    }\n    /**\n     * Create a SigningRequest instance configured for this link.\n     * @internal\n     */\n    async createRequest(args, chain, transport) {\n        const t = transport || this.transport;\n        let request;\n        if (chain || this.chains.length === 1) {\n            const c = chain || this.chains[0];\n            request = await SigningRequest.create({\n                ...args,\n                chainId: c.chainId,\n                broadcast: false,\n            }, { abiProvider: c, zlib });\n        }\n        else {\n            // multi-chain request\n            request = await SigningRequest.create({\n                ...args,\n                chainId: null,\n                chainIds: this.encodeChainIds ? this.chains.map((c) => c.chainId) : undefined,\n                broadcast: false,\n            }, \n            // abi's will be pulled from the first chain and assumed to be identical on all chains\n            { abiProvider: this.chains[0], zlib });\n        }\n        if (t.prepare) {\n            request = await t.prepare(request);\n        }\n        const callback = this.callbackService.create();\n        request.setCallback(callback.url, true);\n        return { request, callback };\n    }\n    /**\n     * Send a SigningRequest instance using this link.\n     * @internal\n     */\n    async sendRequest(request, callback, chain, transport, broadcast = false) {\n        const t = transport || this.transport;\n        try {\n            const linkUrl = request.data.callback;\n            if (linkUrl !== callback.url) {\n                throw new Error('Invalid request callback');\n            }\n            if (request.data.flags.broadcast === true || request.data.flags.background === false) {\n                throw new Error('Invalid request flags');\n            }\n            // wait for callback or user cancel\n            const cancel = new Promise((resolve, reject) => {\n                t.onRequest(request, (reason) => {\n                    callback.cancel();\n                    if (typeof reason === 'string') {\n                        reject(new CancelError(reason));\n                    }\n                    else {\n                        reject(reason);\n                    }\n                });\n            });\n            const callbackResponse = await Promise.race([callback.wait(), cancel]);\n            if (typeof callbackResponse.rejected === 'string') {\n                throw new CancelError(callbackResponse.rejected);\n            }\n            const payload = callbackResponse;\n            const signer = PermissionLevel.from({\n                actor: payload.sa,\n                permission: payload.sp,\n            });\n            const signatures = Object.keys(payload)\n                .filter((key) => key.startsWith('sig') && key !== 'sig0')\n                .map((key) => Signature.from(payload[key]));\n            let c;\n            if (!chain && this.chains.length > 1) {\n                if (!payload.cid) {\n                    throw new Error('Multi chain response payload must specify resolved chain id (cid)');\n                }\n                c = this.getChain(payload.cid);\n            }\n            else {\n                c = chain || this.getChain(0);\n                if (payload.cid && !c.chainId.equals(payload.cid)) {\n                    throw new Error('Got response for wrong chain id');\n                }\n            }\n            // recreate transaction from request response\n            const resolved = await ResolvedSigningRequest.fromPayload(payload, {\n                zlib,\n                abiProvider: c,\n            });\n            // prepend cosigner signature if present\n            const cosignerSig = resolved.request.getInfoKey('cosig', {\n                type: Signature,\n                array: true,\n            });\n            if (cosignerSig) {\n                signatures.unshift(...cosignerSig);\n            }\n            const result = {\n                resolved,\n                chain: c,\n                transaction: resolved.transaction,\n                resolvedTransaction: resolved.resolvedTransaction,\n                signatures,\n                payload,\n                signer,\n            };\n            if (broadcast) {\n                const signedTx = SignedTransaction.from({\n                    ...resolved.transaction,\n                    signatures,\n                });\n                const res = await c.client.v1.chain.push_transaction(signedTx);\n                result.processed = res.processed;\n            }\n            if (t.onSuccess) {\n                t.onSuccess(request, result);\n            }\n            return result;\n        }\n        catch (error) {\n            if (t.onFailure) {\n                t.onFailure(request, error);\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sign and optionally broadcast a EOSIO transaction, action or actions.\n     *\n     * Example:\n     *\n     * ```ts\n     * let result = await myLink.transact({transaction: myTx})\n     * ```\n     *\n     * @param args The action, actions or transaction to use.\n     * @param options Options for this transact call.\n     * @param transport Transport override, for internal use.\n     */\n    async transact(args, options, transport) {\n        const o = options || {};\n        const t = transport || this.transport;\n        const c = o.chain !== undefined ? this.getChain(o.chain) : undefined;\n        const broadcast = o.broadcast !== false;\n        const noModify = o.noModify !== undefined ? o.noModify : !broadcast;\n        // Initialize the loading state of the transport\n        if (t && t.showLoading) {\n            t.showLoading();\n        }\n        // eosjs transact compat: upgrade to transaction if args have any header fields\n        const anyArgs = args;\n        if (args.actions &&\n            (anyArgs.expiration ||\n                anyArgs.ref_block_num ||\n                anyArgs.ref_block_prefix ||\n                anyArgs.max_net_usage_words ||\n                anyArgs.max_cpu_usage_ms ||\n                anyArgs.delay_sec)) {\n            args = {\n                transaction: {\n                    expiration: '1970-01-01T00:00:00',\n                    ref_block_num: 0,\n                    ref_block_prefix: 0,\n                    max_net_usage_words: 0,\n                    max_cpu_usage_ms: 0,\n                    delay_sec: 0,\n                    ...anyArgs,\n                },\n            };\n        }\n        const { request, callback } = await this.createRequest(args, c, t);\n        if (noModify) {\n            request.setInfoKey('no_modify', true, 'bool');\n        }\n        const result = await this.sendRequest(request, callback, c, t, broadcast);\n        return result;\n    }\n    /**\n     * Send an identity request and verify the identity proof if [[LinkOptions.verifyProofs]] is true.\n     * @param args.scope The scope of the identity request.\n     * @param args.requestPermission Optional request permission if the request is for a specific account or permission.\n     * @param args.info Metadata to add to the request.\n     * @note This is for advanced use-cases, you probably want to use [[Link.login]] instead.\n     */\n    async identify(args) {\n        const { request, callback } = await this.createRequest({\n            identity: { permission: args.requestPermission, scope: args.scope },\n            info: args.info,\n        });\n        const res = await this.sendRequest(request, callback);\n        if (!res.resolved.request.isIdentity()) {\n            throw new IdentityError('Unexpected response');\n        }\n        let account;\n        const proof = res.resolved.getIdentityProof(res.signatures[0]);\n        if (this.verifyProofs) {\n            account = await res.chain.client.v1.chain.get_account(res.signer.actor);\n            if (!account) {\n                throw new IdentityError(`Signature from unknown account: ${proof.signer.actor}`);\n            }\n            const accountPermission = account.permissions.find(({ perm_name }) => proof.signer.permission.equals(perm_name));\n            if (!accountPermission) {\n                throw new IdentityError(`${proof.signer.actor} signed for unknown permission: ${proof.signer.permission}`);\n            }\n            const proofValid = proof.verify(accountPermission.required_auth, account.head_block_time);\n            if (!proofValid) {\n                throw new IdentityError(`Invalid identify proof for: ${proof.signer}`);\n            }\n        }\n        if (args.requestPermission) {\n            const perm = PermissionLevel.from(args.requestPermission);\n            if ((!perm.actor.equals(PlaceholderName) && !perm.actor.equals(proof.signer.actor)) ||\n                (!perm.permission.equals(PlaceholderPermission) &&\n                    !perm.permission.equals(proof.signer.permission))) {\n                throw new IdentityError(`Identity proof singed by ${proof.signer}, expected: ${formatAuth(perm)} `);\n            }\n        }\n        return {\n            ...res,\n            account,\n            proof,\n        };\n    }\n    /**\n     * Login and create a persistent session.\n     * @param identifier The session identifier, an EOSIO name (`[a-z1-5]{1,12}`).\n     *                   Should be set to the contract account if applicable.\n     */\n    async login(identifier) {\n        const privateKey = PrivateKey.generate('K1');\n        const requestKey = privateKey.toPublic();\n        const createInfo = LinkCreate.from({\n            session_name: identifier,\n            request_key: requestKey,\n            user_agent: this.getUserAgent(),\n        });\n        const res = await this.identify({\n            scope: identifier,\n            info: {\n                link: createInfo,\n                scope: identifier,\n            },\n        });\n        const metadata = {\n            // backwards compat, can be removed next major release\n            sameDevice: res.resolved.request.getRawInfo()['return_path'] !== undefined,\n        };\n        // append extra metadata from the signer\n        if (res.payload.link_meta) {\n            try {\n                const parsed = JSON.parse(res.payload.link_meta);\n                for (const key of Object.keys(parsed)) {\n                    // normalize key names to camelCase\n                    metadata[snakeToCamel(key)] = parsed[key];\n                }\n            }\n            catch (error) {\n                // eslint-disable-next-line no-console\n                console.warn('Unable to parse link metadata', error, res.payload.link_meta);\n            }\n        }\n        const signerKey = res.proof.recover();\n        let session;\n        if (res.payload.link_ch && res.payload.link_key && res.payload.link_name) {\n            session = new LinkChannelSession(this, {\n                identifier,\n                chainId: res.chain.chainId,\n                auth: res.signer,\n                publicKey: signerKey,\n                channel: {\n                    url: res.payload.link_ch,\n                    key: res.payload.link_key,\n                    name: res.payload.link_name,\n                },\n                requestKey: privateKey,\n            }, metadata);\n        }\n        else {\n            session = new LinkFallbackSession(this, {\n                identifier,\n                chainId: res.chain.chainId,\n                auth: res.signer,\n                publicKey: signerKey,\n            }, metadata);\n        }\n        if (this.storage) {\n            await this.storeSession(identifier, session);\n        }\n        return {\n            ...res,\n            session,\n        };\n    }\n    /**\n     * Restore previous session, use [[login]] to create a new session.\n     * @param identifier The session identifier, must be same as what was used when creating the session with [[login]].\n     * @param auth A specific session auth to restore, if omitted the most recently used session will be restored.\n     * @param chainId If given function will only consider that specific chain when restoring session.\n     * @returns A [[LinkSession]] instance or null if no session can be found.\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session data.\n     **/\n    async restoreSession(identifier, auth, chainId) {\n        if (!this.storage) {\n            throw new Error('Unable to restore session: No storage adapter configured');\n        }\n        let key;\n        if (auth && chainId) {\n            // both auth and chain id given, we can look up on specific key\n            key = this.sessionKey(identifier, formatAuth(PermissionLevel.from(auth)), String(ChainId.from(chainId)));\n        }\n        else {\n            // otherwise we use the session list to filter down to most recently used matching given params\n            let list = await this.listSessions(identifier);\n            if (auth) {\n                list = list.filter((item) => item.auth.equals(auth));\n            }\n            if (chainId) {\n                const id = ChainId.from(chainId);\n                list = list.filter((item) => item.chainId.equals(id));\n            }\n            const latest = list[0];\n            if (!latest) {\n                return null;\n            }\n            key = this.sessionKey(identifier, formatAuth(latest.auth), String(latest.chainId));\n        }\n        const data = await this.storage.read(key);\n        if (!data) {\n            return null;\n        }\n        let sessionData;\n        try {\n            sessionData = JSON.parse(data);\n        }\n        catch (error) {\n            throw new Error(`Unable to restore session: Stored JSON invalid (${error.message || String(error)})`);\n        }\n        const session = LinkSession.restore(this, sessionData);\n        if (auth || chainId) {\n            // update latest used\n            await this.touchSession(identifier, session.auth, session.chainId);\n        }\n        return session;\n    }\n    /**\n     * List stored session auths for given identifier.\n     * The most recently used session is at the top (index 0).\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session list.\n     **/\n    async listSessions(identifier) {\n        if (!this.storage) {\n            throw new Error('Unable to list sessions: No storage adapter configured');\n        }\n        const key = this.sessionKey(identifier, 'list');\n        let list;\n        try {\n            list = JSON.parse((await this.storage.read(key)) || '[]');\n        }\n        catch (error) {\n            throw new Error(`Unable to list sessions: ${error.message || String(error)}`);\n        }\n        return list.map(({ auth, chainId }) => ({\n            auth: PermissionLevel.from(auth),\n            chainId: ChainId.from(chainId),\n        }));\n    }\n    /**\n     * Remove stored session for given identifier and auth.\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.\n     */\n    async removeSession(identifier, auth, chainId) {\n        if (!this.storage) {\n            throw new Error('Unable to remove session: No storage adapter configured');\n        }\n        const key = this.sessionKey(identifier, formatAuth(auth), String(chainId));\n        await this.storage.remove(key);\n        await this.touchSession(identifier, auth, chainId, true);\n    }\n    /**\n     * Remove all stored sessions for given identifier.\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.\n     */\n    async clearSessions(identifier) {\n        if (!this.storage) {\n            throw new Error('Unable to clear sessions: No storage adapter configured');\n        }\n        for (const { auth, chainId } of await this.listSessions(identifier)) {\n            await this.removeSession(identifier, auth, chainId);\n        }\n    }\n    /**\n     * Create an eosjs compatible signature provider using this link.\n     * @param availableKeys Keys the created provider will claim to be able to sign for.\n     * @param chain Chain to use when configured with multiple chains.\n     * @param transport (internal) Transport override for this call.\n     * @note We don't know what keys are available so those have to be provided,\n     *       to avoid this use [[LinkSession.makeSignatureProvider]] instead. Sessions can be created with [[Link.login]].\n     */\n    makeSignatureProvider(availableKeys, chain, transport) {\n        return {\n            getAvailableKeys: async () => availableKeys,\n            sign: async (args) => {\n                const t = transport || this.transport;\n                const c = chain ? this.getChain(chain) : this.chains[0];\n                let request = SigningRequest.fromTransaction(args.chainId, args.serializedTransaction, { abiProvider: c, zlib });\n                const callback = this.callbackService.create();\n                request.setCallback(callback.url, true);\n                request.setBroadcast(false);\n                if (t.prepare) {\n                    request = await t.prepare(request);\n                }\n                const { transaction, signatures } = await this.sendRequest(request, callback, c, t);\n                const serializedTransaction = Serializer.encode({ object: transaction });\n                return {\n                    ...args,\n                    serializedTransaction,\n                    signatures,\n                };\n            },\n        };\n    }\n    /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */\n    async touchSession(identifier, auth, chainId, remove = false) {\n        const list = await this.listSessions(identifier);\n        const existing = list.findIndex((item) => item.auth.equals(auth) && item.chainId.equals(chainId));\n        if (existing >= 0) {\n            list.splice(existing, 1);\n        }\n        if (remove === false) {\n            list.unshift({ auth, chainId });\n        }\n        const key = this.sessionKey(identifier, 'list');\n        await this.storage.write(key, JSON.stringify(list));\n    }\n    /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */\n    async storeSession(identifier, session) {\n        const key = this.sessionKey(identifier, formatAuth(session.auth), String(session.chainId));\n        const data = JSON.stringify(session.serialize());\n        await this.storage.write(key, data);\n        await this.touchSession(identifier, session.auth, session.chainId);\n    }\n    /** Session storage key for identifier and suffix. */\n    sessionKey(identifier, ...suffix) {\n        return [String(Name.from(identifier)), ...suffix].join('-');\n    }\n    /** Return user agent of this link. */\n    getUserAgent() {\n        let rv = `AnchorLink/${Link.version}`;\n        if (this.transport.userAgent) {\n            rv += ' ' + this.transport.userAgent();\n        }\n        return rv;\n    }\n}\n/** Package version. */\nLink.version = '3.2.2'; // eslint-disable-line @typescript-eslint/no-inferrable-types\n/**\n * Format a EOSIO permission level in the format `actor@permission` taking placeholders into consideration.\n * @internal\n */\nfunction formatAuth(auth) {\n    const a = PermissionLevel.from(auth);\n    const actor = a.actor.equals(PlaceholderName) ? '<any>' : String(a.actor);\n    let permission;\n    if (a.permission.equals(PlaceholderName) || a.permission.equals(PlaceholderPermission)) {\n        permission = '<any>';\n    }\n    else {\n        permission = String(a.permission);\n    }\n    return `${actor}@${permission}`;\n}\n/**\n * Return PascalCase version of snake_case string.\n * @internal\n */\nfunction snakeToPascal(name) {\n    return name\n        .split('_')\n        .map((v) => (v[0] ? v[0].toUpperCase() : '_') + v.slice(1))\n        .join('');\n}\n/**\n * Return camelCase version of snake_case string.\n * @internal\n */\nfunction snakeToCamel(name) {\n    const pascal = snakeToPascal(name);\n    return pascal[0].toLowerCase() + pascal.slice(1);\n}\n\n// export library\n\nexport default Link;\nexport { CancelError, IdentityError, Link, LinkChain, LinkChannelSession, LinkFallbackSession, LinkSession, SessionError };\n//# sourceMappingURL=anchor-link.m.js.map\n"]},"metadata":{},"sourceType":"module"}