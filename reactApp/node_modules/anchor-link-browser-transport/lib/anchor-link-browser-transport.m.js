/**
 * Anchor Link Browser Transport v3.1.2
 * https://github.com/greymass/anchor-link-browser-transport
 *
 * @license
 * Copyright (c) 2020 Greymass Inc. All Rights Reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 *  1. Redistribution of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 
 *  2. Redistribution in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 * 
 *  3. Neither the name of the copyright holder nor the names of its contributors
 *     may be used to endorse or promote products derived from this software without
 *     specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE
 * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.
 */
import { Signature, SigningRequest, PlaceholderName, Link, Base64u, isInstanceOf, APIError } from 'anchor-link';

var styleText = `
/* Anchor Link */

.%prefix% * {
    box-sizing: border-box;
    line-height: 1;
}

.%prefix% {
    font-family: -apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue',
        Arial, sans-serif;
    font-size: 13px;
    background: rgba(0, 0, 0, 0.65);
    position: fixed;
    top: 0px;
    left: 0px;
    width: 100%;
    height: 100%;
    z-index: 2147483647;
    display: none;
    align-items: center;
    justify-content: center;
}

.%prefix%-active {
    display: flex;
}

.%prefix%-inner {
    background: #EFF1F7;
    margin: 20px;
    padding-top: 50px;
    border-radius: 20px;
    box-shadow: 0px 4px 100px rgba(0, 0, 0, .5);
    width: 340px;
    position: relative;
}

.%prefix%-close {
    display: block;
    position: absolute;
    top: 11px;
    right: 16px;
    width: 28px;
    height: 28px;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M.57 12.1a.96.96 0 000 1.34c.37.36 1 .36 1.34 0L7 8.37l5.09 5.09c.36.35.97.35 1.34-.01a.96.96 0 000-1.34L8.34 7.01l5.08-5.08a.95.95 0 000-1.33.97.97 0 00-1.34-.01L6.99 5.68 1.91.59a.96.96 0 00-1.33 0 .97.97 0 00-.01 1.34l5.09 5.08-5.1 5.1z' fill='%23007AFF'/%3E%3C/svg%3E");
    background-size: 14px;
    background-repeat: no-repeat;
    background-position: 50% 7px;
    border-radius: 100%;
    cursor: pointer;
}

.%prefix%-close:hover {
    background-color: white;
}

.%prefix%-version {
    position: absolute;
    top: 19px;
    left: 20px;
    cursor: help;
    color: #B8C0DA;
    opacity: 0.1;
}

.%prefix%-version:hover {
    opacity: 1;
}

.%prefix%-logo {
    width: 70px;
    height: 70px;
    margin: 0 auto;
    margin-top: -56px;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='%23fff' d='M18.81 9.19h33.25V59.5H18.81z'/%3E%3Cpath d='M38.45 28.88h-6.9L35 21.77l3.45 7.1z' fill='%233650A2'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M35 70a35 35 0 100-70 35 35 0 000 70zm2.36-55.4a2.62 2.62 0 00-4.72 0L21.9 36.75h5.84l1.7-3.5h11.13l1.7 3.5h5.83L37.36 14.6zM48.13 44.2h-5.26a7.76 7.76 0 01-5.24 7v-10.5a2.62 2.62 0 10-5.25 0v10.5a7.76 7.76 0 01-5.25-7h-5.25c.16 7.06 6 12.69 13.12 12.69 7.12 0 12.97-5.63 13.13-12.7z' fill='%233650A2'/%3E%3C/svg%3E");
}

.%prefix%-fuel {
    width: 70px;
    height: 70px;
    margin: 0 auto;
    margin-top: -56px;
    background-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='utf-8'%3F%3E%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3ClinearGradient id='linear-gradient-25' x1='104.79' y1='197.49' x2='131.55' y2='108.35' gradientUnits='userSpaceOnUse'%3E%3Cstop offset='0.38' stop-color='%23f6b621'/%3E%3Cstop offset='0.59' stop-color='%23e89124'/%3E%3C/linearGradient%3E%3C/defs%3E%3Cg id='brain-logo' style='' transform='matrix(1, 0, 0, 1, -0.005538, -0.040005)'%3E%3Cg%3E%3Cpath class='cls-4' d='M251.93,111.13,221.28,71.51A23.76,23.76,0,0,0,209,63.61l-77.7-18.09a25.86,25.86,0,0,0-5.78-.6,28.22,28.22,0,0,0-7.88,1L99.06,51.58a6.31,6.31,0,0,0-.61-5l-5.3-9a6.36,6.36,0,0,0-5.47-3.13h0a6.57,6.57,0,0,0-1.92.29L49.61,46.21a6.34,6.34,0,0,0-4.41,6.28l.46,12.2a6.2,6.2,0,0,0,.78,2.81L38.2,70a21.1,21.1,0,0,0-11.73,9.76L3,125.21a17.78,17.78,0,0,0,.54,16.32l12.68,21A16.19,16.19,0,0,0,29.69,170a13.25,13.25,0,0,0,1.67-.1L65,165.81a17.22,17.22,0,0,0,9.2,13.64l12.86,6.08a32.51,32.51,0,0,0,12.26,2.63c.35,0,.7,0,1,0l29.17-1.61a6.12,6.12,0,0,1,2.64,1l29.05,28.79a20,20,0,0,0,13.27,5.29c.52,0,1,0,1.53-.07l23.93-2.47c4.31-.44,7.67-2.87,9-6.48s.36-7.64-2.63-10.78l-10.09-10.64,19.07-5.64a15.76,15.76,0,0,0,10.83-13.09L227.65,157a10.69,10.69,0,0,1,1.86-4.19l21.74-24a14,14,0,0,0,.68-17.65Z' style='fill: rgb(255, 255, 255);'/%3E%3Cg%3E%3Ccircle class='cls-2' cx='173.24' cy='107.45' r='6.19' transform='translate(7.67 226.39) rotate(-67.5)' style='fill: rgb(246, 182, 33);'/%3E%3Cpath class='cls-2' d='M101,97.06a3.71,3.71,0,1,0-3.71-3.71A3.71,3.71,0,0,0,101,97.06Z' style='fill: rgb(246, 182, 33);'/%3E%3Ccircle class='cls-2' cx='135.4' cy='76.29' r='3.71' style='fill: rgb(246, 182, 33);'/%3E%3Cg%3E%3Cpath class='cls-21' d='M79.24,128c-16.71,0-37.79,7.36-48.93,11.68a2.39,2.39,0,0,0-1.19,3.46L33.8,151a2.38,2.38,0,0,0,2.34,1.14L69.27,148a12.74,12.74,0,0,1,1.63-.1,13.22,13.22,0,0,1,13.26,12.74l0,1.1a2.4,2.4,0,0,0,1.37,2.07l10.56,5a14.8,14.8,0,0,0,4.69.95H101L129,168.24c.28,0,.57,0,.85,0a21.23,21.23,0,0,1,14.06,5.68l27.82,27.56a4,4,0,0,0,1.26.45l6.07-.75a1.22,1.22,0,0,0,.86-1.9l-3-4.36a11.51,11.51,0,0,1,5.21-19.44l23.4-6.93a1.44,1.44,0,0,0,1-1.23l1.26-12.72v0a1.44,1.44,0,0,0-1.81-1.54c-8.26,2.21-22.73,5.72-31.63,5.72C136.65,158.74,108.72,128,79.24,128Zm32.48,27a2.77,2.77,0,0,1-1,1,3.78,3.78,0,0,1-5.23-5.23,2.77,2.77,0,0,1,1-1A3.78,3.78,0,0,1,111.72,155Zm63.76,13.39a2.62,2.62,0,0,1-1,1,3.78,3.78,0,0,1-5.23-5.23,2.77,2.77,0,0,1,1-1A3.78,3.78,0,0,1,175.48,168.36Z' style='fill: url(%23linear-gradient-25);'/%3E%3Cpath class='cls-2' d='M173.34,127.62c-37.69,0-69.59-16.73-92.46-16.73-16.08,0-43.36,12.17-55.32,21a2,2,0,0,0-.65,2.46c.35.8.82,1.84,1.26,2.82a2,2,0,0,0,2.62,1C39.07,134,61,125.9,79.24,125.9c30.45,0,58.48,27,91.13,27,14.49,0,35.75-5.69,41.3-10.16,2.42-2.52,10.36-11.93,16-17.78a2.39,2.39,0,0,0-2.32-3.94C214.49,123.51,193.73,127.62,173.34,127.62Zm-1.68,14.25a5.28,5.28,0,0,1-2.49,2.49,6.27,6.27,0,0,1-8.48-8.48,5.37,5.37,0,0,1,2.49-2.49A6.27,6.27,0,0,1,171.66,141.87Z' style='fill: rgb(246, 182, 33);'/%3E%3C/g%3E%3Cpath class='cls-1' d='M248.71,113.13,218.06,73.51a20.05,20.05,0,0,0-10-6.43L130.34,49a25.7,25.7,0,0,0-11.57.38L91.41,57.65a.05.05,0,0,1-.07,0L89.56,53a.05.05,0,0,1,0-.07l4.06-1.46a2.45,2.45,0,0,0,1-.62,2.29,2.29,0,0,0,.29-2.72l-5.29-9a2.3,2.3,0,0,0-2.67-1L50.83,49.59a2.28,2.28,0,0,0-1.59,2.27l.46,12.2a2.27,2.27,0,0,0,1,1.8,2.3,2.3,0,0,0,1.28.4,2.33,2.33,0,0,0,.78-.14l9.18-3.29a0,0,0,0,1,.06,0L63.58,66a0,0,0,0,1,0,.07L39.37,73.4a17.25,17.25,0,0,0-9.31,7.74L6.58,126.59A13.67,13.67,0,0,0,7,139l12.68,21a12.1,12.1,0,0,0,11.19,5.45l37.08-4.54a.83.83,0,0,1,.68.18.82.82,0,0,1,.28.64l.14,3.22a13.25,13.25,0,0,0,6.88,10.39l12.86,6.08a28,28,0,0,0,11.32,2.21l29.2-1.61a9.38,9.38,0,0,1,5.68,2.16L164,212.94a16,16,0,0,0,10.41,4.12,10,10,0,0,0,1.11-.06l23.93-2.46c2.77-.29,4.82-1.69,5.62-3.85s.15-4.56-1.77-6.58l-14.6-15.38a.06.06,0,0,1,0-.09l25.35-7.5a11.74,11.74,0,0,0,7.94-9.59l1.53-15.46a14.22,14.22,0,0,1,2.9-6.52l21.74-24A9.94,9.94,0,0,0,248.71,113.13ZM56.08,56.65,56,54.81a1.29,1.29,0,0,1,.88-1.29l28-9a1.28,1.28,0,0,1,1.48.57l.48.83a1.27,1.27,0,0,1-.68,1.83l-28.35,10A1.27,1.27,0,0,1,56.08,56.65Zm186.57,63.93-21.71,24a21.37,21.37,0,0,0-4.79,10.8l-1.54,15.46A4.37,4.37,0,0,1,212,174l-26.5,7.84a6.52,6.52,0,0,0-3,11.2L194,205.17a1.49,1.49,0,0,1-.93,2.5l-18.31,1.89a8.37,8.37,0,0,1-5.49-1.94l-29.06-28.8a16.74,16.74,0,0,0-10.77-4.33l-.59,0-29.21,1.61a20.07,20.07,0,0,1-7.69-1.5l-12.87-6.09a5,5,0,0,1-2.61-3.93l-.13-3.22A8.27,8.27,0,0,0,67,153.44L29.94,158a4.75,4.75,0,0,1-3.87-1.88l-12.68-21a6.38,6.38,0,0,1-.17-5.05L36.71,84.58a10.08,10.08,0,0,1,4.82-4l79.41-24a18.68,18.68,0,0,1,7.7-.25l77.7,18.09a12.72,12.72,0,0,1,5.8,3.72l30.62,39.59A2.35,2.35,0,0,1,242.65,120.58Z' style='fill: rgb(42, 54, 64);'/%3E%3C/g%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
}

.%prefix%-logo.loading {
    border-radius: 100%;
    background-color: #3650A2;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0.5 0.5 45 45' xmlns='http://www.w3.org/2000/svg' stroke='%23fff'%3E%3Cg fill='none' fill-rule='evenodd' transform='translate(1 1)' stroke-width='2'%3E%3Ccircle cx='22' cy='22' r='6' stroke-opacity='0'%3E%3Canimate attributeName='r' begin='1.5s' dur='3s' values='6;22' calcMode='linear' repeatCount='indefinite' /%3E%3Canimate attributeName='stroke-opacity' begin='1.5s' dur='3s' values='1;0' calcMode='linear' repeatCount='indefinite' /%3E%3Canimate attributeName='stroke-width' begin='1.5s' dur='3s' values='2;0' calcMode='linear' repeatCount='indefinite' /%3E%3C/circle%3E%3Ccircle cx='22' cy='22' r='6' stroke-opacity='0'%3E%3Canimate attributeName='r' begin='3s' dur='3s' values='6;22' calcMode='linear' repeatCount='indefinite' /%3E%3Canimate attributeName='stroke-opacity' begin='3s' dur='3s' values='1;0' calcMode='linear' repeatCount='indefinite' /%3E%3Canimate attributeName='stroke-width' begin='3s' dur='3s' values='2;0' calcMode='linear' repeatCount='indefinite' /%3E%3C/circle%3E%3Ccircle cx='22' cy='22' r='8'%3E%3Canimate attributeName='r' begin='0s' dur='1.5s' values='6;1;2;3;4;5;6' calcMode='linear' repeatCount='indefinite' /%3E%3C/circle%3E%3C/g%3E%3C/svg%3E");
}

.%prefix%-logo.error {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 70 70'%3E%3Cdefs/%3E%3Ccircle cx='35' cy='35' r='35' fill='%23FC3D39'/%3E%3Cpath fill='%23fff' d='M22.3 48h25.4c2.5 0 4-1.7 4-4a4 4 0 00-.5-2L38.5 19.3a4 4 0 00-3.5-2 4 4 0 00-3.5 2L18.8 42.1c-.3.6-.5 1.3-.5 2 0 2.2 1.6 4 4 4zM35 37c-.9 0-1.4-.6-1.4-1.5l-.2-7.7c0-.9.6-1.6 1.6-1.6s1.7.7 1.7 1.6l-.3 7.7c0 1-.5 1.5-1.4 1.5zm0 6c-1 0-1.9-.8-1.9-1.8s.9-1.8 2-1.8c1 0 1.8.7 1.8 1.8 0 1-.9 1.8-1.9 1.8z'/%3E%3C/svg%3E");
}

.%prefix%-logo.success {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 70 70'%3E%3Cdefs/%3E%3Ccircle cx='35' cy='35' r='35' fill='%233DC55D'/%3E%3Cpath fill='%23fff' d='M30.9 49.7a2 2 0 001.8-1L48 24.9c.3-.5.4-1 .4-1.4 0-1-.7-1.7-1.7-1.7-.8 0-1.2.3-1.6 1L30.8 45.4 23.5 36c-.5-.6-1-.9-1.6-.9-1 0-1.8.8-1.8 1.8 0 .4.2.9.6 1.3L29 48.7c.6.7 1.1 1 1.9 1z'/%3E%3C/svg%3E");
}

.%prefix%-request {
    padding: 20px;
    border-radius: 20px;
    border-top-left-radius: 0;
    border-top-right-radius: 0;
    background: white;
}

.%prefix%-fee,
.%prefix%-info {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.%prefix%-title {
    color: #000000;
    font-size: 25px;
    margin-top: 14px;
    font-weight: 700;
    line-height: 30px;
    letter-spacing: 0.5px;
}

.%prefix%-subtitle {
    margin-top: 14px;
    color: #5C5C5C;
    text-align: center;
    line-height: 1.4;
    word-break: break-word;
}

.%prefix%-subtitle a {
    color: #000000;
    cursor: pointer;
    text-decoration: underline;
}

.%prefix%-actions {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.%prefix%-uri {
    width: 100%;
}

.%prefix%-button {
    color: #007AFF;
    background: #EFF1F7;
    border: 1px solid #EFF1F7;
    text-decoration: none;
    font-size: 17px;
    flex-grow: 1;
    flex: 1;
    width: 100%;
    line-height: 1;
    padding: 20px 18px;
    border-radius: 12px;
    font-weight: 400;
    text-align: center;
    display: block;
    margin-top: 21px;
    cursor: pointer;
}

.%prefix%-button:hover {
    border: 1px solid #007AFF;
}

.%prefix%-qr {
    margin-top: 21px;
}

.%prefix%-qr svg {
    width: 100%;
    display: block;
    shape-rendering: crispEdges;
}

.%prefix%-qr svg rect {
    fill: black;
}

.%prefix%-footnote {
    text-align: center;
    width: 100%;
    position: absolute;
    bottom: -26px;
    left: 0;
    color: white;
}

.%prefix%-footnote a {
    color: white;
    text-decoration: underline;
}

.%prefix%-wskeepalive {
    display: none;
}

.%prefix%-choice {
    text-align: center;
    width: 100%;
    color: #666;
}

.%prefix%-choice span {
    display: block;
    margin-top: 1em;
}

.%prefix%-choice a:not(.%prefix%-button) {
    display: block;
    cursor: pointer;
    text-decoration: underline;
    margin-top: 1em;
}

@media (prefers-color-scheme: dark) {
    .%prefix%-inner {
        background: #262D43;
        color: white;
    }
    .%prefix%-request {
        background: #131B33;
    }
    .%prefix%-title {
        color: #FCFCFC;
    }
    .%prefix%-subtitle {
        color: #B8C0DA;
    }
    .%prefix%-subtitle a {
        color: #FCFCFC;
    }
    .%prefix%-qr svg rect {
        fill: white;
    }
    .%prefix%-version {
        color: #546AAF;
    }
    .%prefix%-choice {
        color: #888ea1;
    }
    .%prefix%-button {
        color: #FCFCFC;
        background: #262D43;
        border: 1px solid #262D43;
    }
    .%prefix%-button:hover {
        color: #FCFCFC;
        border: 1px solid #FCFCFC;
        background: #333A50;
    }
    .%prefix%-close {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M.57 12.1a.96.96 0 000 1.34c.37.36 1 .36 1.34 0L7 8.37l5.09 5.09c.36.35.97.35 1.34-.01a.96.96 0 000-1.34L8.34 7.01l5.08-5.08a.95.95 0 000-1.33.97.97 0 00-1.34-.01L6.99 5.68 1.91.59a.96.96 0 00-1.33 0 .97.97 0 00-.01 1.34l5.09 5.08-5.1 5.1z' fill='%23FCFCFC'/%3E%3C/svg%3E");
    }
    .%prefix%-close:hover {
        background-color: black;
    }
}

@media (max-height: 600px) { .%prefix%-inner { transform: scale(0.9); } }
@media (max-height: 540px) { .%prefix%-inner { transform: scale(0.8); } }
@media (max-height: 480px) { .%prefix%-inner { transform: scale(0.7); } }
@media (max-height: 420px) { .%prefix%-inner { transform: scale(0.6); } }
@media (max-height: 360px) { .%prefix%-inner { transform: scale(0.5); } }
@media (max-height: 300px) { .%prefix%-inner { transform: scale(0.4); } }

`;

var ErrorCorrectLevel = {
    L: 1,
    M: 0,
    Q: 3,
    H: 2,
};

var Mode = {
    MODE_NUMBER: 1 << 0,
    MODE_ALPHA_NUM: 1 << 1,
    MODE_8BIT_BYTE: 1 << 2,
    MODE_KANJI: 1 << 3,
};

class QR8bitByte {
    constructor(data) {
        this.mode = Mode.MODE_8BIT_BYTE;
        this.data = data;
    }
    getLength() {
        return this.data.length;
    }
    write(buffer) {
        for (let i = 0; i < this.data.length; i++) {
            // not JIS ...
            buffer.put(this.data.charCodeAt(i), 8);
        }
    }
}

class QRBitBuffer {
    constructor() {
        this.buffer = [];
        this.length = 0;
    }
    get(index) {
        const bufIndex = Math.floor(index / 8);
        return ((this.buffer[bufIndex] >>> (7 - (index % 8))) & 1) == 1;
    }
    put(num, length) {
        for (let i = 0; i < length; i++) {
            this.putBit(((num >>> (length - i - 1)) & 1) == 1);
        }
    }
    getLengthInBits() {
        return this.length;
    }
    putBit(bit) {
        const bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
            this.buffer.push(0);
        }
        if (bit) {
            this.buffer[bufIndex] |= 0x80 >>> this.length % 8;
        }
        this.length++;
    }
}

const QRMath = {
    glog: function (n) {
        if (n < 1) {
            throw new Error('glog(' + n + ')');
        }
        return QRMath.LOG_TABLE[n];
    },
    gexp: function (n) {
        while (n < 0) {
            n += 255;
        }
        while (n >= 256) {
            n -= 255;
        }
        return QRMath.EXP_TABLE[n];
    },
    EXP_TABLE: new Array(256),
    LOG_TABLE: new Array(256),
};
for (let i = 0; i < 8; i++) {
    QRMath.EXP_TABLE[i] = 1 << i;
}
for (let i = 8; i < 256; i++) {
    QRMath.EXP_TABLE[i] =
        QRMath.EXP_TABLE[i - 4] ^
            QRMath.EXP_TABLE[i - 5] ^
            QRMath.EXP_TABLE[i - 6] ^
            QRMath.EXP_TABLE[i - 8];
}
for (let i = 0; i < 255; i++) {
    QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
}

class QRPolynomial {
    constructor(num, shift) {
        if (num.length == undefined) {
            throw new Error(num.length + '/' + shift);
        }
        let offset = 0;
        while (offset < num.length && num[offset] == 0) {
            offset++;
        }
        this.num = new Array(num.length - offset + shift);
        for (let i = 0; i < num.length - offset; i++) {
            this.num[i] = num[i + offset];
        }
    }
    get(index) {
        return this.num[index];
    }
    getLength() {
        return this.num.length;
    }
    multiply(e) {
        const num = new Array(this.getLength() + e.getLength() - 1);
        for (let i = 0; i < this.getLength(); i++) {
            for (let j = 0; j < e.getLength(); j++) {
                num[i + j] ^= QRMath.gexp(QRMath.glog(this.get(i)) + QRMath.glog(e.get(j)));
            }
        }
        return new QRPolynomial(num, 0);
    }
    mod(e) {
        if (this.getLength() - e.getLength() < 0) {
            return this;
        }
        const ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0));
        const num = new Array(this.getLength());
        for (let i = 0; i < this.getLength(); i++) {
            num[i] = this.get(i);
        }
        for (let i = 0; i < e.getLength(); i++) {
            num[i] ^= QRMath.gexp(QRMath.glog(e.get(i)) + ratio);
        }
        // recursive call
        return new QRPolynomial(num, 0).mod(e);
    }
}

// ErrorCorrectLevel
class QRRSBlock {
    constructor(totalCount, dataCount) {
        this.totalCount = totalCount;
        this.dataCount = dataCount;
    }
    static getRSBlocks(typeNumber, errorCorrectLevel) {
        const rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
        if (rsBlock == undefined) {
            throw new Error('bad rs block @ typeNumber:' +
                typeNumber +
                '/errorCorrectLevel:' +
                errorCorrectLevel);
        }
        const length = rsBlock.length / 3;
        const list = [];
        for (let i = 0; i < length; i++) {
            const count = rsBlock[i * 3 + 0];
            const totalCount = rsBlock[i * 3 + 1];
            const dataCount = rsBlock[i * 3 + 2];
            for (let j = 0; j < count; j++) {
                list.push(new QRRSBlock(totalCount, dataCount));
            }
        }
        return list;
    }
    static getRsBlockTable(typeNumber, errorCorrectLevel) {
        switch (errorCorrectLevel) {
            case ErrorCorrectLevel.L:
                return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
            case ErrorCorrectLevel.M:
                return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
            case ErrorCorrectLevel.Q:
                return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
            case ErrorCorrectLevel.H:
                return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
            default:
                return undefined;
        }
    }
}
QRRSBlock.RS_BLOCK_TABLE = [
    // L
    // M
    // Q
    // H
    // 1
    [1, 26, 19],
    [1, 26, 16],
    [1, 26, 13],
    [1, 26, 9],
    // 2
    [1, 44, 34],
    [1, 44, 28],
    [1, 44, 22],
    [1, 44, 16],
    // 3
    [1, 70, 55],
    [1, 70, 44],
    [2, 35, 17],
    [2, 35, 13],
    // 4
    [1, 100, 80],
    [2, 50, 32],
    [2, 50, 24],
    [4, 25, 9],
    // 5
    [1, 134, 108],
    [2, 67, 43],
    [2, 33, 15, 2, 34, 16],
    [2, 33, 11, 2, 34, 12],
    // 6
    [2, 86, 68],
    [4, 43, 27],
    [4, 43, 19],
    [4, 43, 15],
    // 7
    [2, 98, 78],
    [4, 49, 31],
    [2, 32, 14, 4, 33, 15],
    [4, 39, 13, 1, 40, 14],
    // 8
    [2, 121, 97],
    [2, 60, 38, 2, 61, 39],
    [4, 40, 18, 2, 41, 19],
    [4, 40, 14, 2, 41, 15],
    // 9
    [2, 146, 116],
    [3, 58, 36, 2, 59, 37],
    [4, 36, 16, 4, 37, 17],
    [4, 36, 12, 4, 37, 13],
    // 10
    [2, 86, 68, 2, 87, 69],
    [4, 69, 43, 1, 70, 44],
    [6, 43, 19, 2, 44, 20],
    [6, 43, 15, 2, 44, 16],
    // 11
    [4, 101, 81],
    [1, 80, 50, 4, 81, 51],
    [4, 50, 22, 4, 51, 23],
    [3, 36, 12, 8, 37, 13],
    // 12
    [2, 116, 92, 2, 117, 93],
    [6, 58, 36, 2, 59, 37],
    [4, 46, 20, 6, 47, 21],
    [7, 42, 14, 4, 43, 15],
    // 13
    [4, 133, 107],
    [8, 59, 37, 1, 60, 38],
    [8, 44, 20, 4, 45, 21],
    [12, 33, 11, 4, 34, 12],
    // 14
    [3, 145, 115, 1, 146, 116],
    [4, 64, 40, 5, 65, 41],
    [11, 36, 16, 5, 37, 17],
    [11, 36, 12, 5, 37, 13],
    // 15
    [5, 109, 87, 1, 110, 88],
    [5, 65, 41, 5, 66, 42],
    [5, 54, 24, 7, 55, 25],
    [11, 36, 12],
    // 16
    [5, 122, 98, 1, 123, 99],
    [7, 73, 45, 3, 74, 46],
    [15, 43, 19, 2, 44, 20],
    [3, 45, 15, 13, 46, 16],
    // 17
    [1, 135, 107, 5, 136, 108],
    [10, 74, 46, 1, 75, 47],
    [1, 50, 22, 15, 51, 23],
    [2, 42, 14, 17, 43, 15],
    // 18
    [5, 150, 120, 1, 151, 121],
    [9, 69, 43, 4, 70, 44],
    [17, 50, 22, 1, 51, 23],
    [2, 42, 14, 19, 43, 15],
    // 19
    [3, 141, 113, 4, 142, 114],
    [3, 70, 44, 11, 71, 45],
    [17, 47, 21, 4, 48, 22],
    [9, 39, 13, 16, 40, 14],
    // 20
    [3, 135, 107, 5, 136, 108],
    [3, 67, 41, 13, 68, 42],
    [15, 54, 24, 5, 55, 25],
    [15, 43, 15, 10, 44, 16],
    // 21
    [4, 144, 116, 4, 145, 117],
    [17, 68, 42],
    [17, 50, 22, 6, 51, 23],
    [19, 46, 16, 6, 47, 17],
    // 22
    [2, 139, 111, 7, 140, 112],
    [17, 74, 46],
    [7, 54, 24, 16, 55, 25],
    [34, 37, 13],
    // 23
    [4, 151, 121, 5, 152, 122],
    [4, 75, 47, 14, 76, 48],
    [11, 54, 24, 14, 55, 25],
    [16, 45, 15, 14, 46, 16],
    // 24
    [6, 147, 117, 4, 148, 118],
    [6, 73, 45, 14, 74, 46],
    [11, 54, 24, 16, 55, 25],
    [30, 46, 16, 2, 47, 17],
    // 25
    [8, 132, 106, 4, 133, 107],
    [8, 75, 47, 13, 76, 48],
    [7, 54, 24, 22, 55, 25],
    [22, 45, 15, 13, 46, 16],
    // 26
    [10, 142, 114, 2, 143, 115],
    [19, 74, 46, 4, 75, 47],
    [28, 50, 22, 6, 51, 23],
    [33, 46, 16, 4, 47, 17],
    // 27
    [8, 152, 122, 4, 153, 123],
    [22, 73, 45, 3, 74, 46],
    [8, 53, 23, 26, 54, 24],
    [12, 45, 15, 28, 46, 16],
    // 28
    [3, 147, 117, 10, 148, 118],
    [3, 73, 45, 23, 74, 46],
    [4, 54, 24, 31, 55, 25],
    [11, 45, 15, 31, 46, 16],
    // 29
    [7, 146, 116, 7, 147, 117],
    [21, 73, 45, 7, 74, 46],
    [1, 53, 23, 37, 54, 24],
    [19, 45, 15, 26, 46, 16],
    // 30
    [5, 145, 115, 10, 146, 116],
    [19, 75, 47, 10, 76, 48],
    [15, 54, 24, 25, 55, 25],
    [23, 45, 15, 25, 46, 16],
    // 31
    [13, 145, 115, 3, 146, 116],
    [2, 74, 46, 29, 75, 47],
    [42, 54, 24, 1, 55, 25],
    [23, 45, 15, 28, 46, 16],
    // 32
    [17, 145, 115],
    [10, 74, 46, 23, 75, 47],
    [10, 54, 24, 35, 55, 25],
    [19, 45, 15, 35, 46, 16],
    // 33
    [17, 145, 115, 1, 146, 116],
    [14, 74, 46, 21, 75, 47],
    [29, 54, 24, 19, 55, 25],
    [11, 45, 15, 46, 46, 16],
    // 34
    [13, 145, 115, 6, 146, 116],
    [14, 74, 46, 23, 75, 47],
    [44, 54, 24, 7, 55, 25],
    [59, 46, 16, 1, 47, 17],
    // 35
    [12, 151, 121, 7, 152, 122],
    [12, 75, 47, 26, 76, 48],
    [39, 54, 24, 14, 55, 25],
    [22, 45, 15, 41, 46, 16],
    // 36
    [6, 151, 121, 14, 152, 122],
    [6, 75, 47, 34, 76, 48],
    [46, 54, 24, 10, 55, 25],
    [2, 45, 15, 64, 46, 16],
    // 37
    [17, 152, 122, 4, 153, 123],
    [29, 74, 46, 14, 75, 47],
    [49, 54, 24, 10, 55, 25],
    [24, 45, 15, 46, 46, 16],
    // 38
    [4, 152, 122, 18, 153, 123],
    [13, 74, 46, 32, 75, 47],
    [48, 54, 24, 14, 55, 25],
    [42, 45, 15, 32, 46, 16],
    // 39
    [20, 147, 117, 4, 148, 118],
    [40, 75, 47, 7, 76, 48],
    [43, 54, 24, 22, 55, 25],
    [10, 45, 15, 67, 46, 16],
    // 40
    [19, 148, 118, 6, 149, 119],
    [18, 75, 47, 31, 76, 48],
    [34, 54, 24, 34, 55, 25],
    [20, 45, 15, 61, 46, 16],
];

const QRMaskPattern = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7,
};
const QRUtil = {
    PATTERN_POSITION_TABLE: [
        [],
        [6, 18],
        [6, 22],
        [6, 26],
        [6, 30],
        [6, 34],
        [6, 22, 38],
        [6, 24, 42],
        [6, 26, 46],
        [6, 28, 50],
        [6, 30, 54],
        [6, 32, 58],
        [6, 34, 62],
        [6, 26, 46, 66],
        [6, 26, 48, 70],
        [6, 26, 50, 74],
        [6, 30, 54, 78],
        [6, 30, 56, 82],
        [6, 30, 58, 86],
        [6, 34, 62, 90],
        [6, 28, 50, 72, 94],
        [6, 26, 50, 74, 98],
        [6, 30, 54, 78, 102],
        [6, 28, 54, 80, 106],
        [6, 32, 58, 84, 110],
        [6, 30, 58, 86, 114],
        [6, 34, 62, 90, 118],
        [6, 26, 50, 74, 98, 122],
        [6, 30, 54, 78, 102, 126],
        [6, 26, 52, 78, 104, 130],
        [6, 30, 56, 82, 108, 134],
        [6, 34, 60, 86, 112, 138],
        [6, 30, 58, 86, 114, 142],
        [6, 34, 62, 90, 118, 146],
        [6, 30, 54, 78, 102, 126, 150],
        [6, 24, 50, 76, 102, 128, 154],
        [6, 28, 54, 80, 106, 132, 158],
        [6, 32, 58, 84, 110, 136, 162],
        [6, 26, 54, 82, 110, 138, 166],
        [6, 30, 58, 86, 114, 142, 170],
    ],
    G15: (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0),
    G18: (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0),
    G15_MASK: (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1),
    getBCHTypeInfo: function (data) {
        let d = data << 10;
        while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
            d ^= QRUtil.G15 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15));
        }
        return ((data << 10) | d) ^ QRUtil.G15_MASK;
    },
    getBCHTypeNumber: function (data) {
        let d = data << 12;
        while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
            d ^= QRUtil.G18 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18));
        }
        return (data << 12) | d;
    },
    getBCHDigit: function (data) {
        let digit = 0;
        while (data != 0) {
            digit++;
            data >>>= 1;
        }
        return digit;
    },
    getPatternPosition: function (typeNumber) {
        return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
    },
    getMask: function (maskPattern, i, j) {
        switch (maskPattern) {
            case QRMaskPattern.PATTERN000:
                return (i + j) % 2 == 0;
            case QRMaskPattern.PATTERN001:
                return i % 2 == 0;
            case QRMaskPattern.PATTERN010:
                return j % 3 == 0;
            case QRMaskPattern.PATTERN011:
                return (i + j) % 3 == 0;
            case QRMaskPattern.PATTERN100:
                return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
            case QRMaskPattern.PATTERN101:
                return ((i * j) % 2) + ((i * j) % 3) == 0;
            case QRMaskPattern.PATTERN110:
                return (((i * j) % 2) + ((i * j) % 3)) % 2 == 0;
            case QRMaskPattern.PATTERN111:
                return (((i * j) % 3) + ((i + j) % 2)) % 2 == 0;
            default:
                throw new Error('bad maskPattern:' + maskPattern);
        }
    },
    getErrorCorrectPolynomial: function (errorCorrectLength) {
        let a = new QRPolynomial([1], 0);
        for (let i = 0; i < errorCorrectLength; i++) {
            a = a.multiply(new QRPolynomial([1, QRMath.gexp(i)], 0));
        }
        return a;
    },
    getLengthInBits: function (mode, type) {
        if (1 <= type && type < 10) {
            // 1 - 9
            switch (mode) {
                case Mode.MODE_NUMBER:
                    return 10;
                case Mode.MODE_ALPHA_NUM:
                    return 9;
                case Mode.MODE_8BIT_BYTE:
                    return 8;
                case Mode.MODE_KANJI:
                    return 8;
                default:
                    throw new Error('mode:' + mode);
            }
        }
        else if (type < 27) {
            // 10 - 26
            switch (mode) {
                case Mode.MODE_NUMBER:
                    return 12;
                case Mode.MODE_ALPHA_NUM:
                    return 11;
                case Mode.MODE_8BIT_BYTE:
                    return 16;
                case Mode.MODE_KANJI:
                    return 10;
                default:
                    throw new Error('mode:' + mode);
            }
        }
        else if (type < 41) {
            // 27 - 40
            switch (mode) {
                case Mode.MODE_NUMBER:
                    return 14;
                case Mode.MODE_ALPHA_NUM:
                    return 13;
                case Mode.MODE_8BIT_BYTE:
                    return 16;
                case Mode.MODE_KANJI:
                    return 12;
                default:
                    throw new Error('mode:' + mode);
            }
        }
        else {
            throw new Error('type:' + type);
        }
    },
    getLostPoint: function (qrCode) {
        const moduleCount = qrCode.getModuleCount();
        let lostPoint = 0;
        // LEVEL1
        for (let row = 0; row < moduleCount; row++) {
            for (let col = 0; col < moduleCount; col++) {
                let sameCount = 0;
                const dark = qrCode.isDark(row, col);
                for (let r = -1; r <= 1; r++) {
                    if (row + r < 0 || moduleCount <= row + r) {
                        continue;
                    }
                    for (let c = -1; c <= 1; c++) {
                        if (col + c < 0 || moduleCount <= col + c) {
                            continue;
                        }
                        if (r == 0 && c == 0) {
                            continue;
                        }
                        if (dark == qrCode.isDark(row + r, col + c)) {
                            sameCount++;
                        }
                    }
                }
                if (sameCount > 5) {
                    lostPoint += 3 + sameCount - 5;
                }
            }
        }
        // LEVEL2
        for (let row = 0; row < moduleCount - 1; row++) {
            for (let col = 0; col < moduleCount - 1; col++) {
                let count = 0;
                if (qrCode.isDark(row, col))
                    count++;
                if (qrCode.isDark(row + 1, col))
                    count++;
                if (qrCode.isDark(row, col + 1))
                    count++;
                if (qrCode.isDark(row + 1, col + 1))
                    count++;
                if (count == 0 || count == 4) {
                    lostPoint += 3;
                }
            }
        }
        // LEVEL3
        for (let row = 0; row < moduleCount; row++) {
            for (let col = 0; col < moduleCount - 6; col++) {
                if (qrCode.isDark(row, col) &&
                    !qrCode.isDark(row, col + 1) &&
                    qrCode.isDark(row, col + 2) &&
                    qrCode.isDark(row, col + 3) &&
                    qrCode.isDark(row, col + 4) &&
                    !qrCode.isDark(row, col + 5) &&
                    qrCode.isDark(row, col + 6)) {
                    lostPoint += 40;
                }
            }
        }
        for (let col = 0; col < moduleCount; col++) {
            for (let row = 0; row < moduleCount - 6; row++) {
                if (qrCode.isDark(row, col) &&
                    !qrCode.isDark(row + 1, col) &&
                    qrCode.isDark(row + 2, col) &&
                    qrCode.isDark(row + 3, col) &&
                    qrCode.isDark(row + 4, col) &&
                    !qrCode.isDark(row + 5, col) &&
                    qrCode.isDark(row + 6, col)) {
                    lostPoint += 40;
                }
            }
        }
        // LEVEL4
        let darkCount = 0;
        for (let col = 0; col < moduleCount; col++) {
            for (let row = 0; row < moduleCount; row++) {
                if (qrCode.isDark(row, col)) {
                    darkCount++;
                }
            }
        }
        const ratio = Math.abs((100 * darkCount) / moduleCount / moduleCount - 50) / 5;
        lostPoint += ratio * 10;
        return lostPoint;
    },
};

class QRCode {
    constructor(typeNumber, errorCorrectLevel) {
        this.typeNumber = typeNumber;
        this.errorCorrectLevel = errorCorrectLevel;
        this.modules = null;
        this.moduleCount = 0;
        this.dataCache = null;
        this.dataList = [];
    }
    addData(data) {
        const newData = new QR8bitByte(data);
        this.dataList.push(newData);
        this.dataCache = null;
    }
    isDark(row, col) {
        if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
            throw new Error(row + ',' + col);
        }
        return this.modules[row][col];
    }
    getModuleCount() {
        return this.moduleCount;
    }
    make() {
        // Calculate automatically typeNumber if provided is < 1
        if (this.typeNumber < 1) {
            let typeNumber = 1;
            for (typeNumber = 1; typeNumber < 40; typeNumber++) {
                const rsBlocks = QRRSBlock.getRSBlocks(typeNumber, this.errorCorrectLevel);
                const buffer = new QRBitBuffer();
                let totalDataCount = 0;
                for (let i = 0; i < rsBlocks.length; i++) {
                    totalDataCount += rsBlocks[i].dataCount;
                }
                for (let i = 0; i < this.dataList.length; i++) {
                    const data = this.dataList[i];
                    buffer.put(data.mode, 4);
                    buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
                    data.write(buffer);
                }
                if (buffer.getLengthInBits() <= totalDataCount * 8)
                    break;
            }
            this.typeNumber = typeNumber;
        }
        this.makeImpl(false, this.getBestMaskPattern());
    }
    makeImpl(test, maskPattern) {
        this.moduleCount = this.typeNumber * 4 + 17;
        this.modules = new Array(this.moduleCount);
        for (let row = 0; row < this.moduleCount; row++) {
            this.modules[row] = new Array(this.moduleCount);
            for (let col = 0; col < this.moduleCount; col++) {
                this.modules[row][col] = null; //(col + row) % 3;
            }
        }
        this.setupPositionProbePattern(0, 0);
        this.setupPositionProbePattern(this.moduleCount - 7, 0);
        this.setupPositionProbePattern(0, this.moduleCount - 7);
        this.setupPositionAdjustPattern();
        this.setupTimingPattern();
        this.setupTypeInfo(test, maskPattern);
        if (this.typeNumber >= 7) {
            this.setupTypeNumber(test);
        }
        if (this.dataCache == null) {
            this.dataCache = QRCode.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
        }
        this.mapData(this.dataCache, maskPattern);
    }
    setupPositionProbePattern(row, col) {
        for (let r = -1; r <= 7; r++) {
            if (row + r <= -1 || this.moduleCount <= row + r)
                continue;
            for (let c = -1; c <= 7; c++) {
                if (col + c <= -1 || this.moduleCount <= col + c)
                    continue;
                if ((0 <= r && r <= 6 && (c == 0 || c == 6)) ||
                    (0 <= c && c <= 6 && (r == 0 || r == 6)) ||
                    (2 <= r && r <= 4 && 2 <= c && c <= 4)) {
                    this.modules[row + r][col + c] = true;
                }
                else {
                    this.modules[row + r][col + c] = false;
                }
            }
        }
    }
    getBestMaskPattern() {
        let minLostPoint = 0;
        let pattern = 0;
        for (let i = 0; i < 8; i++) {
            this.makeImpl(true, i);
            const lostPoint = QRUtil.getLostPoint(this);
            if (i == 0 || minLostPoint > lostPoint) {
                minLostPoint = lostPoint;
                pattern = i;
            }
        }
        return pattern;
    }
    setupTimingPattern() {
        for (let r = 8; r < this.moduleCount - 8; r++) {
            if (this.modules[r][6] != null) {
                continue;
            }
            this.modules[r][6] = r % 2 == 0;
        }
        for (let c = 8; c < this.moduleCount - 8; c++) {
            if (this.modules[6][c] != null) {
                continue;
            }
            this.modules[6][c] = c % 2 == 0;
        }
    }
    setupPositionAdjustPattern() {
        const pos = QRUtil.getPatternPosition(this.typeNumber);
        for (let i = 0; i < pos.length; i++) {
            for (let j = 0; j < pos.length; j++) {
                const row = pos[i];
                const col = pos[j];
                if (this.modules[row][col] != null) {
                    continue;
                }
                for (let r = -2; r <= 2; r++) {
                    for (let c = -2; c <= 2; c++) {
                        if (r == -2 || r == 2 || c == -2 || c == 2 || (r == 0 && c == 0)) {
                            this.modules[row + r][col + c] = true;
                        }
                        else {
                            this.modules[row + r][col + c] = false;
                        }
                    }
                }
            }
        }
    }
    setupTypeNumber(test) {
        const bits = QRUtil.getBCHTypeNumber(this.typeNumber);
        for (let i = 0; i < 18; i++) {
            const mod = !test && ((bits >> i) & 1) == 1;
            this.modules[Math.floor(i / 3)][(i % 3) + this.moduleCount - 8 - 3] = mod;
        }
        for (let i = 0; i < 18; i++) {
            const mod = !test && ((bits >> i) & 1) == 1;
            this.modules[(i % 3) + this.moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
        }
    }
    setupTypeInfo(test, maskPattern) {
        const data = (this.errorCorrectLevel << 3) | maskPattern;
        const bits = QRUtil.getBCHTypeInfo(data);
        // vertical
        for (let i = 0; i < 15; i++) {
            const mod = !test && ((bits >> i) & 1) == 1;
            if (i < 6) {
                this.modules[i][8] = mod;
            }
            else if (i < 8) {
                this.modules[i + 1][8] = mod;
            }
            else {
                this.modules[this.moduleCount - 15 + i][8] = mod;
            }
        }
        // horizontal
        for (let i = 0; i < 15; i++) {
            const mod = !test && ((bits >> i) & 1) == 1;
            if (i < 8) {
                this.modules[8][this.moduleCount - i - 1] = mod;
            }
            else if (i < 9) {
                this.modules[8][15 - i - 1 + 1] = mod;
            }
            else {
                this.modules[8][15 - i - 1] = mod;
            }
        }
        // fixed module
        this.modules[this.moduleCount - 8][8] = !test;
    }
    mapData(data, maskPattern) {
        let inc = -1;
        let row = this.moduleCount - 1;
        let bitIndex = 7;
        let byteIndex = 0;
        for (let col = this.moduleCount - 1; col > 0; col -= 2) {
            if (col == 6)
                col--;
            for (;;) {
                for (let c = 0; c < 2; c++) {
                    if (this.modules[row][col - c] == null) {
                        let dark = false;
                        if (byteIndex < data.length) {
                            dark = ((data[byteIndex] >>> bitIndex) & 1) == 1;
                        }
                        const mask = QRUtil.getMask(maskPattern, row, col - c);
                        if (mask) {
                            dark = !dark;
                        }
                        this.modules[row][col - c] = dark;
                        bitIndex--;
                        if (bitIndex == -1) {
                            byteIndex++;
                            bitIndex = 7;
                        }
                    }
                }
                row += inc;
                if (row < 0 || this.moduleCount <= row) {
                    row -= inc;
                    inc = -inc;
                    break;
                }
            }
        }
    }
    static createData(typeNumber, errorCorrectLevel, dataList) {
        const rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
        const buffer = new QRBitBuffer();
        for (let i = 0; i < dataList.length; i++) {
            const data = dataList[i];
            buffer.put(data.mode, 4);
            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
            data.write(buffer);
        }
        // calc num max data.
        let totalDataCount = 0;
        for (let i = 0; i < rsBlocks.length; i++) {
            totalDataCount += rsBlocks[i].dataCount;
        }
        if (buffer.getLengthInBits() > totalDataCount * 8) {
            throw new Error('code length overflow. (' +
                buffer.getLengthInBits() +
                '>' +
                totalDataCount * 8 +
                ')');
        }
        // end code
        if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
            buffer.put(0, 4);
        }
        // padding
        while (buffer.getLengthInBits() % 8 != 0) {
            buffer.putBit(false);
        }
        // padding
        for (;;) {
            if (buffer.getLengthInBits() >= totalDataCount * 8) {
                break;
            }
            buffer.put(QRCode.PAD0, 8);
            if (buffer.getLengthInBits() >= totalDataCount * 8) {
                break;
            }
            buffer.put(QRCode.PAD1, 8);
        }
        return QRCode.createBytes(buffer, rsBlocks);
    }
    static createBytes(buffer, rsBlocks) {
        let offset = 0;
        let maxDcCount = 0;
        let maxEcCount = 0;
        const dcdata = new Array(rsBlocks.length);
        const ecdata = new Array(rsBlocks.length);
        for (let r = 0; r < rsBlocks.length; r++) {
            const dcCount = rsBlocks[r].dataCount;
            const ecCount = rsBlocks[r].totalCount - dcCount;
            maxDcCount = Math.max(maxDcCount, dcCount);
            maxEcCount = Math.max(maxEcCount, ecCount);
            dcdata[r] = new Array(dcCount);
            for (let i = 0; i < dcdata[r].length; i++) {
                dcdata[r][i] = 0xff & buffer.buffer[i + offset];
            }
            offset += dcCount;
            const rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
            const rawPoly = new QRPolynomial(dcdata[r], rsPoly.getLength() - 1);
            const modPoly = rawPoly.mod(rsPoly);
            ecdata[r] = new Array(rsPoly.getLength() - 1);
            for (let i = 0; i < ecdata[r].length; i++) {
                const modIndex = i + modPoly.getLength() - ecdata[r].length;
                ecdata[r][i] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
            }
        }
        let totalCodeCount = 0;
        for (let i = 0; i < rsBlocks.length; i++) {
            totalCodeCount += rsBlocks[i].totalCount;
        }
        const data = new Array(totalCodeCount);
        let index = 0;
        for (let i = 0; i < maxDcCount; i++) {
            for (let r = 0; r < rsBlocks.length; r++) {
                if (i < dcdata[r].length) {
                    data[index++] = dcdata[r][i];
                }
            }
        }
        for (let i = 0; i < maxEcCount; i++) {
            for (let r = 0; r < rsBlocks.length; r++) {
                if (i < ecdata[r].length) {
                    data[index++] = ecdata[r][i];
                }
            }
        }
        return data;
    }
}
QRCode.PAD0 = 0xec;
QRCode.PAD1 = 0x11;

/**
 * Generate QR SVG
 * @author Johan Nordberg <code@johan-nordberg.com>
 */
function generate(text, level = 'L', version = -1) {
    const qr = new QRCode(version, ErrorCorrectLevel[level]);
    const rects = [];
    qr.addData(text);
    qr.make();
    const rows = qr.modules;
    const size = rows.length;
    for (const [y, row] of rows.entries()) {
        let rect;
        for (const [x, on] of row.entries()) {
            if (on) {
                if (!rect)
                    rect = { x, y, width: 0, height: 1 };
                rect.width++;
            }
            else {
                if (rect && rect.width > 0) {
                    rects.push(rect);
                }
                rect = undefined;
            }
        }
        if (rect && rect.width > 0) {
            rects.push(rect);
        }
    }
    const svg = [`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${size} ${size}">`];
    for (const { x, y, width, height } of rects) {
        svg.push(`<rect x="${x}" y="${y}" width="${width}" height="${height}" />`);
    }
    svg.push('</svg>');
    return svg.join('');
}

async function apiCall(url, body) {
    return (await fetch(url, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: body ? JSON.stringify(body) : undefined,
    })).json();
}
const version = 'fuel/2';
/** Return true if otherVersion is same or greater than current fuel version. */
function compareVersion(otherVersion) {
    return parseVersion(otherVersion) >= parseVersion(version);
}
function parseVersion(string) {
    const parts = string.trim().split('/');
    if (parts.length === 2 && parts[0] === 'fuel') {
        return parseInt(parts[1]) || 0;
    }
    return -1;
}
async function fuel(request, session, updatePrepareStatus, supportedChains, referrer) {
    assertEligible(request, session);
    updatePrepareStatus('Detecting if network resources are required.');
    const chainId = request.getChainId();
    const nodeUrl = supportedChains[String(chainId)];
    if (!nodeUrl) {
        throw new Error(`Blockchain not supported by this resource provider.`);
    }
    const result = await apiCall(nodeUrl + '/v1/resource_provider/request_transaction', {
        ref: referrer,
        request,
        signer: session.auth,
    });
    if (!result || !result.data) {
        throw new Error('Invalid response from resource provider.');
    }
    if (!result.data.signatures || !result.data.signatures[0]) {
        throw new Error('No signature returned from resource provider.');
    }
    if (result.code === 402 && !result.data.fee) {
        throw new Error('Resource provider returned a response indicating required payment, but provided no fee amount.');
    }
    // Clone the request for modification
    const cloned = request.clone();
    // Set the required fee onto the request for signature providers
    if (result.code === 402) {
        if (request.getInfoKey('no_fee')) {
            throw new Error('Fee required but sender opted out.');
        }
        cloned.setInfoKey('txfee', result.data.fee);
    }
    // If the fee costs exist, set them on the request for the signature provider to consume
    if (result.data.costs) {
        cloned.setInfoKey('txfeecpu', result.data.costs.cpu);
        cloned.setInfoKey('txfeenet', result.data.costs.net);
        cloned.setInfoKey('txfeeram', result.data.costs.ram);
    }
    // Set the cosigner signature onto the request for signature providers
    const signatures = result.data.signatures.map((s) => Signature.from(s));
    cloned.setInfoKey('cosig', signatures, { type: Signature, array: true });
    // Modify the request based on the response from the API
    cloned.data.req = (await SigningRequest.create({ transaction: { ...result.data.request[1] } }, { abiProvider: request.abiProvider })).data.req;
    return cloned;
}
function assertEligible(request, session) {
    if (request.getRawInfoKey('no_modify')) {
        throw new Error('Request cannot be modified.');
    }
    if (request.isIdentity()) {
        throw new Error('Identity requests cannot be co-signed.');
    }
    const firstAction = request.getRawActions()[0];
    if (!firstAction) {
        throw new Error('No actions in request.');
    }
    const firstAuthorizer = firstAction.authorization[0];
    if (!firstAction) {
        throw new Error('First authorization missing.');
    }
    if (!firstAuthorizer.actor.equals(session.auth.actor) &&
        !firstAuthorizer.actor.equals(PlaceholderName)) {
        throw new Error('Not first authorizer.');
    }
}

const AbortPrepare = Symbol();
const SkipFee = Symbol();
const defaultSupportedChains = {
    aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906: 'https://eos.greymass.com',
    '2a02a0053e5a8cf73a56ba0fda11e4d92e0238a4a2aa74fccf46d5a910746840': 'https://jungle3.greymass.com',
    '4667b205c6838ef70ff7988f6e8257e8be0e1284a2f59699054a018f743b1d11': 'https://telos.greymass.com',
    '1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4': 'https://wax.greymass.com',
};
class Storage {
    constructor(keyPrefix) {
        this.keyPrefix = keyPrefix;
    }
    async write(key, data) {
        localStorage.setItem(this.storageKey(key), data);
    }
    async read(key) {
        return localStorage.getItem(this.storageKey(key));
    }
    async remove(key) {
        localStorage.removeItem(this.storageKey(key));
    }
    storageKey(key) {
        return `${this.keyPrefix}-${key}`;
    }
}
class BrowserTransport {
    constructor(options = {}) {
        this.options = options;
        this.classPrefix = options.classPrefix || 'anchor-link';
        this.injectStyles = !(options.injectStyles === false);
        this.importantStyles = !(options.importantStyles === false);
        this.requestStatus = !(options.requestStatus === false);
        this.fuelEnabled = options.disableGreymassFuel !== true;
        this.fuelReferrer = options.fuelReferrer || 'teamgreymass';
        this.storage = new Storage(options.storagePrefix || 'anchor-link');
        this.supportedChains = options.supportedChains || defaultSupportedChains;
    }
    closeModal() {
        this.hide();
        if (this.activeCancel) {
            this.activeRequest = undefined;
            this.activeCancel('Modal closed');
            this.activeCancel = undefined;
        }
    }
    setupElements() {
        if (this.injectStyles && !this.styleEl) {
            this.styleEl = document.createElement('style');
            this.styleEl.type = 'text/css';
            let css = styleText.replace(/%prefix%/g, this.classPrefix);
            if (this.importantStyles) {
                css = css
                    .split('\n')
                    .map((line) => line.replace(/;$/i, ' !important;'))
                    .join('\n');
            }
            this.styleEl.appendChild(document.createTextNode(css));
            document.head.appendChild(this.styleEl);
        }
        if (!this.containerEl) {
            this.containerEl = this.createEl();
            this.containerEl.className = this.classPrefix;
            this.containerEl.onclick = (event) => {
                if (event.target === this.containerEl) {
                    event.stopPropagation();
                    this.closeModal();
                }
            };
            document.body.appendChild(this.containerEl);
        }
        if (!this.requestEl) {
            const wrapper = this.createEl({ class: 'inner' });
            const closeButton = this.createEl({ class: 'close' });
            closeButton.onclick = (event) => {
                event.stopPropagation();
                this.closeModal();
            };
            this.requestEl = this.createEl({ class: 'request' });
            wrapper.appendChild(this.requestEl);
            wrapper.appendChild(closeButton);
            const version = this.createEl({
                class: 'version',
                text: `${BrowserTransport.version} (${Link.version})`,
            });
            version.onclick = (event) => {
                event.stopPropagation();
                window.open('https://github.com/greymass/anchor-link', '_blank');
            };
            wrapper.appendChild(version);
            this.containerEl.appendChild(wrapper);
        }
    }
    createEl(attrs) {
        if (!attrs)
            attrs = {};
        const el = document.createElement(attrs.tag || 'div');
        if (attrs) {
            for (const attr of Object.keys(attrs)) {
                const value = attrs[attr];
                switch (attr) {
                    case 'src':
                        el.setAttribute(attr, value);
                        break;
                    case 'tag':
                        break;
                    case 'text':
                        el.appendChild(document.createTextNode(value));
                        break;
                    case 'class':
                        el.className = `${this.classPrefix}-${value}`;
                        break;
                    default:
                        el.setAttribute(attr, value);
                }
            }
        }
        return el;
    }
    hide() {
        if (this.containerEl) {
            this.containerEl.classList.remove(`${this.classPrefix}-active`);
        }
        this.clearTimers();
    }
    show() {
        if (this.containerEl) {
            this.containerEl.classList.add(`${this.classPrefix}-active`);
        }
    }
    async displayRequest(request) {
        this.setupElements();
        const sameDeviceRequest = request.clone();
        const returnUrl = generateReturnUrl();
        sameDeviceRequest.setInfoKey('same_device', true);
        sameDeviceRequest.setInfoKey('return_path', returnUrl);
        const sameDeviceUri = sameDeviceRequest.encode(true, false);
        const crossDeviceUri = request.encode(true, false);
        const isIdentity = request.isIdentity();
        const title = isIdentity ? 'Login' : 'Sign';
        const subtitle = 'Scan the QR-code with Anchor on another device or use the button to open Anchor on this device.';
        const qrEl = this.createEl({ class: 'qr' });
        try {
            qrEl.innerHTML = generate(crossDeviceUri);
        }
        catch (error) {
            // eslint-disable-next-line no-console
            console.warn('Unable to generate QR code', error);
        }
        const linkEl = this.createEl({ class: 'uri' });
        const linkA = this.createEl({
            tag: 'a',
            class: 'button',
            href: crossDeviceUri,
            text: 'Launch Anchor',
        });
        linkEl.appendChild(linkA);
        if (isFirefox()) {
            // this prevents firefox from killing the websocket connection once the link is clicked
            const iframe = this.createEl({
                class: 'wskeepalive',
                src: 'about:blank',
                tag: 'iframe',
            });
            linkEl.appendChild(iframe);
            linkA.addEventListener('click', (event) => {
                event.preventDefault();
                iframe.setAttribute('src', sameDeviceUri);
            });
        }
        else {
            linkA.addEventListener('click', (event) => {
                event.preventDefault();
                window.location.href = sameDeviceUri;
            });
        }
        const infoEl = this.createEl({ class: 'info' });
        const infoTitle = this.createEl({ class: 'title', tag: 'span', text: title });
        const infoSubtitle = this.createEl({ class: 'subtitle', tag: 'span', text: subtitle });
        infoEl.appendChild(infoTitle);
        infoEl.appendChild(infoSubtitle);
        const actionEl = this.createEl({ class: 'actions' });
        actionEl.appendChild(qrEl);
        actionEl.appendChild(linkEl);
        let footnoteEl;
        if (isIdentity) {
            footnoteEl = this.createEl({ class: 'footnote', text: "Don't have Anchor yet? " });
            const footnoteLink = this.createEl({
                tag: 'a',
                target: '_blank',
                href: 'https://greymass.com/anchor',
                text: 'Download now',
            });
            footnoteEl.appendChild(footnoteLink);
        }
        else {
            footnoteEl = this.createEl({
                class: 'footnote',
                text: 'Anchor signing is brought to you by ',
            });
            const footnoteLink = this.createEl({
                tag: 'a',
                target: '_blank',
                href: 'https://greymass.com',
                text: 'Greymass',
            });
            footnoteEl.appendChild(footnoteLink);
        }
        emptyElement(this.requestEl);
        const logoEl = this.createEl({ class: 'logo' });
        this.requestEl.appendChild(logoEl);
        this.requestEl.appendChild(infoEl);
        this.requestEl.appendChild(actionEl);
        this.requestEl.appendChild(footnoteEl);
        this.show();
    }
    async showLoading() {
        this.setupElements();
        emptyElement(this.requestEl);
        const infoEl = this.createEl({ class: 'info' });
        const infoTitle = this.createEl({ class: 'title', tag: 'span', text: 'Loading' });
        const infoSubtitle = this.createEl({
            class: 'subtitle',
            tag: 'span',
            text: 'Preparing request...',
        });
        this.prepareStatusEl = infoSubtitle;
        infoEl.appendChild(infoTitle);
        infoEl.appendChild(infoSubtitle);
        const logoEl = this.createEl({ class: 'logo loading' });
        this.requestEl.appendChild(logoEl);
        this.requestEl.appendChild(infoEl);
        this.show();
    }
    onRequest(request, cancel) {
        this.activeRequest = request;
        this.activeCancel = cancel;
        this.displayRequest(request).catch(cancel);
    }
    onSessionRequest(session, request, cancel) {
        if (session.metadata.sameDevice) {
            request.setInfoKey('return_path', generateReturnUrl());
        }
        if (session.type === 'fallback') {
            this.onRequest(request, cancel);
            if (session.metadata.sameDevice) {
                // trigger directly on a fallback same-device session
                window.location.href = request.encode();
            }
            return;
        }
        this.activeRequest = request;
        this.activeCancel = cancel;
        this.setupElements();
        const timeout = session.metadata.timeout || 60 * 1000 * 5;
        const deviceName = session.metadata.name;
        const infoTitle = this.createEl({ class: 'title', tag: 'span', text: 'Sign' });
        const expires = this.getExpiration(request, timeout);
        const updateCountdown = () => {
            infoTitle.textContent = `Sign - ${countdownFormat(expires)}`;
        };
        this.countdownTimer = setInterval(updateCountdown, 200);
        updateCountdown();
        const infoEl = this.createEl({ class: 'info' });
        infoEl.appendChild(infoTitle);
        let subtitle;
        if (deviceName && deviceName.length > 0) {
            subtitle = `Please open your Anchor Wallet on your device “${deviceName}” to review and sign the transaction.`;
        }
        else {
            subtitle = 'Please review and sign the transaction in the linked wallet.';
        }
        const infoSubtitle = this.createEl({ class: 'subtitle', tag: 'span', text: subtitle });
        infoEl.appendChild(infoSubtitle);
        emptyElement(this.requestEl);
        const logoEl = this.createEl({ class: 'logo' });
        this.requestEl.appendChild(logoEl);
        this.requestEl.appendChild(infoEl);
        this.show();
        if (session.metadata.sameDevice) {
            if (session.metadata.launchUrl) {
                window.location.href = session.metadata.launchUrl;
            }
            else if (isAppleHandheld()) {
                window.location.href = 'anchor://link';
            }
        }
    }
    sendSessionPayload(payload, session) {
        if (!session.metadata.triggerUrl || !session.metadata.sameDevice) {
            // not same device or no trigger url supported
            return false;
        }
        if (payload.array.length > 700) {
            // url could be clipped by iOS
            return false;
        }
        window.location.href = session.metadata.triggerUrl.replace('%s', Base64u.encode(payload.array));
        return true;
    }
    clearTimers() {
        if (this.closeTimer) {
            clearTimeout(this.closeTimer);
            this.closeTimer = undefined;
        }
        if (this.countdownTimer) {
            clearTimeout(this.countdownTimer);
            this.countdownTimer = undefined;
        }
    }
    getExpiration(request, timeout = 0) {
        // Get expiration of the transaction
        const { expiration } = request.getRawTransaction();
        if (expiration.equals(0)) {
            // If no expiration is present, use the timeout on the session
            return new Date(Date.now() + timeout);
        }
        else {
            return expiration.toDate();
        }
    }
    async showFee(request, fee) {
        this.activeRequest = request;
        const cancelPromise = new Promise((resolve, reject) => {
            this.activeCancel = (reason) => {
                let error;
                if (typeof reason === 'string') {
                    error = new Error(reason);
                }
                else {
                    error = reason;
                }
                error[AbortPrepare] = true;
                reject(error);
            };
        });
        this.setupElements();
        emptyElement(this.requestEl);
        const feeEl = this.createEl({ class: 'fee' });
        const feeTitle = this.createEl({ class: 'title', tag: 'div', text: 'Transaction Fee' });
        const feeSubtitle = this.createEl({
            class: 'subtitle',
            tag: 'span',
            text: `Your account lacks the network resources for this transaction and it cannot be covered for free.`,
        });
        const feePart1 = this.createEl({
            tag: 'span',
            text: 'You can try to ',
        });
        const feeBypass = this.createEl({
            tag: 'a',
            text: 'proceed without the fee',
        });
        const feePart2 = this.createEl({
            tag: 'span',
            text: ' or accept the fee shown below to pay for these costs.',
        });
        const feeDescription = this.createEl({
            class: 'subtitle',
            tag: 'span',
        });
        feeDescription.appendChild(feePart1);
        feeDescription.appendChild(feeBypass);
        feeDescription.appendChild(feePart2);
        feeEl.appendChild(feeTitle);
        feeEl.appendChild(feeSubtitle);
        feeEl.appendChild(feeDescription);
        const logoEl = this.createEl({ class: 'fuel' });
        this.requestEl.appendChild(logoEl);
        this.requestEl.appendChild(feeEl);
        const choiceEl = this.createEl({ class: 'choice' });
        const confirmEl = this.createEl({ tag: 'a', class: 'button', text: `Accept Fee of ${fee}` });
        const expireEl = this.createEl({ tag: 'span', text: 'Offer expires in --:--' });
        choiceEl.appendChild(expireEl);
        choiceEl.appendChild(confirmEl);
        feeEl.appendChild(choiceEl);
        const expires = this.getExpiration(request);
        const expireTimer = setInterval(() => {
            expireEl.textContent = `Offer expires in ${countdownFormat(expires)}`;
            if (expires.getTime() < Date.now()) {
                this.activeCancel('Offer expired');
            }
        }, 200);
        const footnoteEl = this.createEl({
            class: 'footnote',
            text: 'Resources offered by ',
        });
        const footnoteLink = this.createEl({
            tag: 'a',
            target: '_blank',
            href: 'https://greymass.com/en/fuel',
            text: 'Greymass Fuel',
        });
        footnoteEl.appendChild(footnoteLink);
        this.requestEl.appendChild(footnoteEl);
        const skipPromise = waitForEvent(feeBypass, 'click').then(() => {
            const error = new Error('Skipped fee');
            error[SkipFee] = true;
            throw error;
        });
        const confirmPromise = waitForEvent(confirmEl, 'click');
        this.show();
        await Promise.race([confirmPromise, skipPromise, cancelPromise]).finally(() => {
            clearInterval(expireTimer);
        });
    }
    async prepare(request, session) {
        this.showLoading();
        if (!this.fuelEnabled || !session || request.isIdentity()) {
            // don't attempt to cosign id request or if we don't have a session attached
            return request;
        }
        if (typeof session.metadata.cosignerVersion === 'string' &&
            compareVersion(session.metadata.cosignerVersion)) {
            // if signer has cosigner, only attempt to cosign here if we have a newer version
            return request;
        }
        try {
            const result = fuel(request, session, (message) => {
                if (this.prepareStatusEl) {
                    this.prepareStatusEl.textContent = message;
                }
            }, this.supportedChains, this.fuelReferrer);
            const timeout = new Promise((r) => setTimeout(r, 5000)).then(() => {
                throw new Error('API timeout after 5000ms');
            });
            const modified = await Promise.race([result, timeout]);
            const fee = modified.getInfoKey('txfee');
            if (fee) {
                await this.showFee(modified, String(fee));
            }
            return modified;
        }
        catch (error) {
            if (error[AbortPrepare]) {
                this.hide();
                throw error;
            }
            else {
                // eslint-disable-next-line no-console
                console.info(`Skipping resource provider: ${error.message || error}`);
                if (error[SkipFee]) {
                    const modified = request.clone();
                    modified.setInfoKey('no_fee', true, 'bool');
                    return modified;
                }
            }
        }
        return request;
    }
    onSuccess(request) {
        if (request === this.activeRequest) {
            this.clearTimers();
            if (this.requestStatus) {
                this.setupElements();
                const infoEl = this.createEl({ class: 'info' });
                const logoEl = this.createEl({ class: 'logo' });
                logoEl.classList.add('success');
                const infoTitle = this.createEl({ class: 'title', tag: 'span', text: 'Success!' });
                const subtitle = request.isIdentity() ? 'Login completed.' : 'Transaction signed.';
                const infoSubtitle = this.createEl({ class: 'subtitle', tag: 'span', text: subtitle });
                infoEl.appendChild(infoTitle);
                infoEl.appendChild(infoSubtitle);
                emptyElement(this.requestEl);
                this.requestEl.appendChild(logoEl);
                this.requestEl.appendChild(infoEl);
                this.show();
                this.closeTimer = setTimeout(() => {
                    this.hide();
                }, 1.5 * 1000);
            }
            else {
                this.hide();
            }
        }
    }
    onFailure(request, error) {
        if (request === this.activeRequest && error['code'] !== 'E_CANCEL') {
            this.clearTimers();
            if (this.requestStatus) {
                this.setupElements();
                const infoEl = this.createEl({ class: 'info' });
                const logoEl = this.createEl({ class: 'logo' });
                logoEl.classList.add('error');
                const infoTitle = this.createEl({
                    class: 'title',
                    tag: 'span',
                    text: 'Transaction Error',
                });
                let errorMessage;
                if (isInstanceOf(error, APIError)) {
                    if (error.name === 'eosio_assert_message_exception') {
                        errorMessage = error.details[0].message;
                    }
                    else if (error.details.length > 0) {
                        errorMessage = error.details.map((d) => d.message).join('\n');
                    }
                    else {
                        errorMessage = error.message;
                    }
                }
                else {
                    errorMessage = error.message || String(error);
                }
                const infoSubtitle = this.createEl({
                    class: 'subtitle',
                    tag: 'span',
                    text: errorMessage,
                });
                infoEl.appendChild(infoTitle);
                infoEl.appendChild(infoSubtitle);
                emptyElement(this.requestEl);
                this.requestEl.appendChild(logoEl);
                this.requestEl.appendChild(infoEl);
                this.show();
            }
            else {
                this.hide();
            }
        }
        else {
            this.hide();
        }
    }
    userAgent() {
        return `BrowserTransport/${BrowserTransport.version} ${navigator.userAgent}`;
    }
}
/** Package version. */
BrowserTransport.version = '3.1.2'; // replaced by build script
function waitForEvent(element, eventName, timeout) {
    return new Promise((resolve, reject) => {
        const listener = (event) => {
            element.removeEventListener(eventName, listener);
            resolve(event);
        };
        element.addEventListener(eventName, listener);
        if (timeout) {
            setTimeout(() => {
                element.removeEventListener(eventName, listener);
                reject(new Error(`Timed out waiting for ${eventName}`));
            }, timeout);
        }
    });
}
function countdownFormat(date) {
    const timeLeft = date.getTime() - Date.now();
    if (timeLeft > 0) {
        return new Date(timeLeft).toISOString().substr(14, 5);
    }
    return '00:00';
}
function emptyElement(el) {
    while (el.firstChild) {
        el.removeChild(el.firstChild);
    }
}
/** Generate a return url that Anchor will redirect back to w/o reload. */
function generateReturnUrl() {
    if (isChromeiOS()) {
        // google chrome on iOS will always open new tab so we just ask it to open again as a workaround
        return 'googlechrome://';
    }
    if (isFirefoxiOS()) {
        // same for firefox
        return 'firefox:://';
    }
    if (isAppleHandheld() && isBrave()) {
        // and brave ios
        return 'brave://';
    }
    if (isAppleHandheld()) {
        // return url with unique fragment required for iOS safari to trigger the return url
        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let rv = window.location.href.split('#')[0] + '#';
        for (let i = 0; i < 8; i++) {
            rv += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
        }
        return rv;
    }
    if (isAndroid() && isFirefox()) {
        return 'android-intent://org.mozilla.firefox';
    }
    if (isAndroid() && isEdge()) {
        return 'android-intent://com.microsoft.emmx';
    }
    if (isAndroid() && isOpera()) {
        return 'android-intent://com.opera.browser';
    }
    if (isAndroid() && isBrave()) {
        return 'android-intent://com.brave.browser';
    }
    if (isAndroid() && isAndroidWebView()) {
        return 'android-intent://webview';
    }
    if (isAndroid() && isChromeMobile()) {
        return 'android-intent://com.android.chrome';
    }
    return window.location.href;
}
function isAppleHandheld() {
    return /iP(ad|od|hone)/i.test(navigator.userAgent);
}
function isChromeiOS() {
    return /CriOS/.test(navigator.userAgent);
}
function isChromeMobile() {
    return /Chrome\/[.0-9]* Mobile/i.test(navigator.userAgent);
}
function isFirefox() {
    return /Firefox/i.test(navigator.userAgent);
}
function isFirefoxiOS() {
    return /FxiOS/.test(navigator.userAgent);
}
function isOpera() {
    return /OPR/.test(navigator.userAgent) || /Opera/.test(navigator.userAgent);
}
function isEdge() {
    return /Edg/.test(navigator.userAgent);
}
function isBrave() {
    return navigator['brave'] && typeof navigator['brave'].isBrave === 'function';
}
function isAndroid() {
    return /Android/.test(navigator.userAgent);
}
function isAndroidWebView() {
    return /wv/.test(navigator.userAgent);
}

export default BrowserTransport;
//# sourceMappingURL=anchor-link-browser-transport.m.js.map
