/**
 * Anchor Link v3.2.2
 * https://github.com/greymass/anchor-link
 *
 * @license
 * Copyright (c) 2020 Greymass Inc. All Rights Reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 *  1. Redistribution of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 
 *  2. Redistribution in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 * 
 *  3. Neither the name of the copyright holder nor the names of its contributors
 *     may be used to endorse or promote products derived from this software without
 *     specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE
 * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.
 */
'use strict';

var tslib = require('tslib');
var zlib = require('pako');
var eosio = require('@greymass/eosio');
var eosioSigningRequest = require('eosio-signing-request');
var makeFetch = require('fetch-ponyfill');
var asmcrypto_js = require('asmcrypto.js');
var uuid = require('uuid');
var WebSocket = require('isomorphic-ws');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var zlib__default = /*#__PURE__*/_interopDefaultLegacy(zlib);
var eosio__namespace = /*#__PURE__*/_interopNamespace(eosio);
var eosioSigningRequest__namespace = /*#__PURE__*/_interopNamespace(eosioSigningRequest);
var makeFetch__default = /*#__PURE__*/_interopDefaultLegacy(makeFetch);
var WebSocket__default = /*#__PURE__*/_interopDefaultLegacy(WebSocket);

/**
 * Error that is thrown if a [[LinkTransport]] cancels a request.
 * @internal
 */
var CancelError = /** @class */ (function (_super) {
    tslib.__extends(CancelError, _super);
    function CancelError(reason) {
        var _this = _super.call(this, "User canceled request " + (reason ? '(' + reason + ')' : '')) || this;
        _this.code = 'E_CANCEL';
        return _this;
    }
    return CancelError;
}(Error));
/**
 * Error that is thrown if an identity request fails to verify.
 * @internal
 */
var IdentityError = /** @class */ (function (_super) {
    tslib.__extends(IdentityError, _super);
    function IdentityError(reason) {
        var _this = _super.call(this, "Unable to verify identity " + (reason ? '(' + reason + ')' : '')) || this;
        _this.code = 'E_IDENTITY';
        return _this;
    }
    return IdentityError;
}(Error));
/**
 * Error originating from a [[LinkSession]].
 * @internal
 */
var SessionError = /** @class */ (function (_super) {
    tslib.__extends(SessionError, _super);
    function SessionError(reason, code) {
        var _this = _super.call(this, reason) || this;
        _this.code = code;
        return _this;
    }
    return SessionError;
}(Error));

/** @internal */
var LinkOptions;
(function (LinkOptions) {
    /** @internal */
    LinkOptions.defaults = {
        service: 'https://cb.anchor.link',
        verifyProofs: false,
        encodeChainIds: true,
    };
})(LinkOptions || (LinkOptions = {}));

var SealedMessage = /** @class */ (function (_super) {
    tslib.__extends(SealedMessage, _super);
    function SealedMessage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    tslib.__decorate([
        eosio.Struct.field('public_key')
    ], SealedMessage.prototype, "from", void 0);
    tslib.__decorate([
        eosio.Struct.field('uint64')
    ], SealedMessage.prototype, "nonce", void 0);
    tslib.__decorate([
        eosio.Struct.field('bytes')
    ], SealedMessage.prototype, "ciphertext", void 0);
    tslib.__decorate([
        eosio.Struct.field('uint32')
    ], SealedMessage.prototype, "checksum", void 0);
    SealedMessage = tslib.__decorate([
        eosio.Struct.type('sealed_message')
    ], SealedMessage);
    return SealedMessage;
}(eosio.Struct));
var LinkCreate = /** @class */ (function (_super) {
    tslib.__extends(LinkCreate, _super);
    function LinkCreate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    tslib.__decorate([
        eosio.Struct.field('name')
    ], LinkCreate.prototype, "session_name", void 0);
    tslib.__decorate([
        eosio.Struct.field('public_key')
    ], LinkCreate.prototype, "request_key", void 0);
    tslib.__decorate([
        eosio.Struct.field('string', { extension: true })
    ], LinkCreate.prototype, "user_agent", void 0);
    LinkCreate = tslib.__decorate([
        eosio.Struct.type('link_create')
    ], LinkCreate);
    return LinkCreate;
}(eosio.Struct));
var LinkInfo = /** @class */ (function (_super) {
    tslib.__extends(LinkInfo, _super);
    function LinkInfo() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    tslib.__decorate([
        eosio.Struct.field('time_point_sec')
    ], LinkInfo.prototype, "expiration", void 0);
    LinkInfo = tslib.__decorate([
        eosio.Struct.type('link_info')
    ], LinkInfo);
    return LinkInfo;
}(eosio.Struct));

/** @internal */
var fetch = makeFetch__default['default']().fetch;
/**
 * Encrypt a message using AES and shared secret derived from given keys.
 * @internal
 */
function sealMessage(message, privateKey, publicKey, nonce) {
    var secret = privateKey.sharedSecret(publicKey);
    if (!nonce) {
        nonce = eosio.UInt64.random();
    }
    var key = eosio.Checksum512.hash(eosio.Serializer.encode({ object: nonce }).appending(secret.array));
    var cbc = new asmcrypto_js.AES_CBC(key.array.slice(0, 32), key.array.slice(32, 48));
    var ciphertext = eosio.Bytes.from(cbc.encrypt(eosio.Bytes.from(message, 'utf8').array));
    var checksumView = new DataView(eosio.Checksum256.hash(key.array).array.buffer);
    var checksum = checksumView.getUint32(0, true);
    return SealedMessage.from({
        from: privateKey.toPublic(),
        nonce: nonce,
        ciphertext: ciphertext,
        checksum: checksum,
    });
}

/**
 * Type describing a link session that can create a eosjs compatible
 * signature provider and transact for a specific auth.
 */
var LinkSession = /** @class */ (function () {
    /** @internal */
    function LinkSession() {
    } // eslint-disable-line @typescript-eslint/no-empty-function
    /**
     * Convenience, remove this session from associated [[Link]] storage if set.
     * Equivalent to:
     * ```ts
     * session.link.removeSession(session.identifier, session.auth, session.chainId)
     * ```
     */
    LinkSession.prototype.remove = function () {
        return tslib.__awaiter(this, void 0, void 0, function () {
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.link.storage) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.link.removeSession(this.identifier, this.auth, this.chainId)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    Object.defineProperty(LinkSession.prototype, "client", {
        /** API client for the chain this session is valid on. */
        get: function () {
            return this.link.getChain(this.chainId).client;
        },
        enumerable: false,
        configurable: true
    });
    /** Restore a previously serialized session. */
    LinkSession.restore = function (link, data) {
        switch (data.type) {
            case 'channel':
                return new LinkChannelSession(link, data.data, data.metadata);
            case 'fallback':
                return new LinkFallbackSession(link, data.data, data.metadata);
            default:
                throw new Error('Unable to restore, session data invalid');
        }
    };
    return LinkSession;
}());
/**
 * Link session that pushes requests over a channel.
 * @internal
 */
var LinkChannelSession = /** @class */ (function (_super) {
    tslib.__extends(LinkChannelSession, _super);
    function LinkChannelSession(link, data, metadata) {
        var _this = _super.call(this) || this;
        _this.type = 'channel';
        _this.timeout = 2 * 60 * 1000; // ms
        _this.link = link;
        _this.chainId = eosioSigningRequest.ChainId.from(data.chainId);
        _this.auth = eosio.PermissionLevel.from(data.auth);
        _this.publicKey = eosio.PublicKey.from(data.publicKey);
        _this.channel = data.channel;
        _this.identifier = eosio.Name.from(data.identifier);
        var privateKey = eosio.PrivateKey.from(data.requestKey);
        var publicKey = eosio.PublicKey.from(data.channel.key);
        _this.encrypt = function (request) {
            return sealMessage(request.encode(true, false), privateKey, publicKey);
        };
        _this.metadata = tslib.__assign(tslib.__assign({}, (metadata || {})), { timeout: _this.timeout, name: _this.channel.name });
        _this.serialize = function () { return ({
            type: 'channel',
            data: data,
            metadata: _this.metadata,
        }); };
        return _this;
    }
    LinkChannelSession.prototype.onSuccess = function (request, result) {
        if (this.link.transport.onSuccess) {
            this.link.transport.onSuccess(request, result);
        }
    };
    LinkChannelSession.prototype.onFailure = function (request, error) {
        if (this.link.transport.onFailure) {
            this.link.transport.onFailure(request, error);
        }
    };
    LinkChannelSession.prototype.onRequest = function (request, cancel) {
        var info = LinkInfo.from({
            expiration: new Date(Date.now() + this.timeout).toISOString().slice(0, -1),
        });
        if (this.link.transport.onSessionRequest) {
            this.link.transport.onSessionRequest(this, request, cancel);
        }
        setTimeout(function () {
            cancel(new SessionError('Wallet did not respond in time', 'E_TIMEOUT'));
        }, this.timeout + 500);
        request.setInfoKey('link', info);
        var payloadSent = false;
        var payload = eosio.Serializer.encode({ object: this.encrypt(request) });
        if (this.link.transport.sendSessionPayload) {
            try {
                payloadSent = this.link.transport.sendSessionPayload(payload, this);
            }
            catch (error) {
                // eslint-disable-next-line no-console
                console.warn('Unexpected error when transport tried to send session payload', error);
            }
        }
        if (payloadSent) {
            return;
        }
        fetch(this.channel.url, {
            method: 'POST',
            headers: {
                'X-Buoy-Wait': (this.timeout / 1000).toFixed(0),
            },
            body: payload.array,
        })
            .then(function (response) {
            if (response.status !== 200) {
                cancel(new SessionError('Unable to push message', 'E_DELIVERY'));
            }
        })
            .catch(function (error) {
            cancel(new SessionError("Unable to reach link service (" + (error.message || String(error)) + ")", 'E_DELIVERY'));
        });
    };
    LinkChannelSession.prototype.prepare = function (request) {
        if (this.link.transport.prepare) {
            return this.link.transport.prepare(request, this);
        }
        return Promise.resolve(request);
    };
    LinkChannelSession.prototype.showLoading = function () {
        if (this.link.transport.showLoading) {
            return this.link.transport.showLoading();
        }
    };
    LinkChannelSession.prototype.makeSignatureProvider = function () {
        return this.link.makeSignatureProvider([this.publicKey.toString()], this.chainId, this);
    };
    LinkChannelSession.prototype.transact = function (args, options) {
        return this.link.transact(args, tslib.__assign(tslib.__assign({}, options), { chain: this.chainId }), this);
    };
    return LinkChannelSession;
}(LinkSession));
/**
 * Link session that sends every request over the transport.
 * @internal
 */
var LinkFallbackSession = /** @class */ (function (_super) {
    tslib.__extends(LinkFallbackSession, _super);
    function LinkFallbackSession(link, data, metadata) {
        var _this = _super.call(this) || this;
        _this.type = 'fallback';
        _this.link = link;
        _this.auth = eosio.PermissionLevel.from(data.auth);
        _this.publicKey = eosio.PublicKey.from(data.publicKey);
        _this.chainId = eosioSigningRequest.ChainId.from(data.chainId);
        _this.metadata = metadata || {};
        _this.identifier = eosio.Name.from(data.identifier);
        _this.serialize = function () { return ({
            type: _this.type,
            data: data,
            metadata: _this.metadata,
        }); };
        return _this;
    }
    LinkFallbackSession.prototype.onSuccess = function (request, result) {
        if (this.link.transport.onSuccess) {
            this.link.transport.onSuccess(request, result);
        }
    };
    LinkFallbackSession.prototype.onFailure = function (request, error) {
        if (this.link.transport.onFailure) {
            this.link.transport.onFailure(request, error);
        }
    };
    LinkFallbackSession.prototype.onRequest = function (request, cancel) {
        if (this.link.transport.onSessionRequest) {
            this.link.transport.onSessionRequest(this, request, cancel);
        }
        else {
            this.link.transport.onRequest(request, cancel);
        }
    };
    LinkFallbackSession.prototype.prepare = function (request) {
        if (this.link.transport.prepare) {
            return this.link.transport.prepare(request, this);
        }
        return Promise.resolve(request);
    };
    LinkFallbackSession.prototype.showLoading = function () {
        if (this.link.transport.showLoading) {
            return this.link.transport.showLoading();
        }
    };
    LinkFallbackSession.prototype.makeSignatureProvider = function () {
        return this.link.makeSignatureProvider([this.publicKey.toString()], this.chainId, this);
    };
    LinkFallbackSession.prototype.transact = function (args, options) {
        return this.link.transact(args, tslib.__assign(tslib.__assign({}, options), { chain: this.chainId }), this);
    };
    return LinkFallbackSession;
}(LinkSession));

/** @internal */
var BuoyCallbackService = /** @class */ (function () {
    function BuoyCallbackService(address) {
        this.address = address.trim().replace(/\/$/, '');
    }
    BuoyCallbackService.prototype.create = function () {
        var url = this.address + "/" + uuid.v4();
        return new BuoyCallback(url);
    };
    return BuoyCallbackService;
}());
/** @internal */
var BuoyCallback = /** @class */ (function () {
    function BuoyCallback(url) {
        this.url = url;
        this.ctx = {};
    }
    BuoyCallback.prototype.wait = function () {
        if (this.url.includes('hyperbuoy')) {
            return pollForCallback(this.url, this.ctx);
        }
        else {
            return waitForCallback(this.url, this.ctx);
        }
    };
    BuoyCallback.prototype.cancel = function () {
        if (this.ctx.cancel) {
            this.ctx.cancel();
        }
    };
    return BuoyCallback;
}());
/**
 * Connect to a WebSocket channel and wait for a message.
 * @internal
 */
function waitForCallback(url, ctx) {
    return new Promise(function (resolve, reject) {
        var active = true;
        var retries = 0;
        var socketUrl = url.replace(/^http/, 'ws');
        var handleResponse = function (response) {
            try {
                resolve(JSON.parse(response));
            }
            catch (error) {
                error.message = 'Unable to parse callback JSON: ' + error.message;
                reject(error);
            }
        };
        var connect = function () {
            var socket = new WebSocket__default['default'](socketUrl);
            ctx.cancel = function () {
                active = false;
                if (socket.readyState === WebSocket__default['default'].OPEN ||
                    socket.readyState === WebSocket__default['default'].CONNECTING) {
                    socket.close();
                }
            };
            socket.onmessage = function (event) {
                active = false;
                if (socket.readyState === WebSocket__default['default'].OPEN) {
                    socket.close();
                }
                if (typeof Blob !== 'undefined' && event.data instanceof Blob) {
                    var reader_1 = new FileReader();
                    reader_1.onload = function () {
                        handleResponse(reader_1.result);
                    };
                    reader_1.onerror = function (error) {
                        reject(error);
                    };
                    reader_1.readAsText(event.data);
                }
                else {
                    if (typeof event.data === 'string') {
                        handleResponse(event.data);
                    }
                    else {
                        handleResponse(event.data.toString());
                    }
                }
            };
            socket.onopen = function () {
                retries = 0;
            };
            socket.onclose = function () {
                if (active) {
                    setTimeout(connect, backoff(retries++));
                }
            };
        };
        connect();
    });
}
/**
 * Long-poll for message.
 * @internal
 */
function pollForCallback(url, ctx) {
    return tslib.__awaiter(this, void 0, void 0, function () {
        var active, res, error_1;
        return tslib.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    active = true;
                    ctx.cancel = function () {
                        active = false;
                    };
                    _a.label = 1;
                case 1:
                    if (!active) return [3 /*break*/, 11];
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, 8, , 9]);
                    return [4 /*yield*/, fetch(url)];
                case 3:
                    res = _a.sent();
                    if (!(res.status === 408)) return [3 /*break*/, 4];
                    return [3 /*break*/, 1];
                case 4:
                    if (!(res.status === 200)) return [3 /*break*/, 6];
                    return [4 /*yield*/, res.json()];
                case 5: return [2 /*return*/, _a.sent()];
                case 6: throw new Error("HTTP " + res.status + ": " + res.statusText);
                case 7: return [3 /*break*/, 9];
                case 8:
                    error_1 = _a.sent();
                    // eslint-disable-next-line no-console
                    console.warn('Unexpected hyperbuoy error', error_1);
                    return [3 /*break*/, 9];
                case 9: return [4 /*yield*/, sleep(1000)];
                case 10:
                    _a.sent();
                    return [3 /*break*/, 1];
                case 11: return [2 /*return*/, null];
            }
        });
    });
}
/**
 * Exponential backoff function that caps off at 10s after 10 tries.
 * https://i.imgur.com/IrUDcJp.png
 * @internal
 */
function backoff(tries) {
    return Math.min(Math.pow(tries * 10, 2), 10 * 1000);
}
/**
 * Return promise that resolves after given milliseconds.
 * @internal
 */
function sleep(ms) {
    return new Promise(function (resolve) {
        setTimeout(resolve, ms);
    });
}

/**
 * Class representing a EOSIO chain.
 */
var LinkChain = /** @class */ (function () {
    /** @internal */
    function LinkChain(chainId, clientOrUrl) {
        this.abiCache = new Map();
        this.pendingAbis = new Map();
        this.chainId = eosioSigningRequest.ChainId.from(chainId);
        this.client =
            typeof clientOrUrl === 'string' ? new eosio.APIClient({ url: clientOrUrl }) : clientOrUrl;
    }
    /**
     * Fetch the ABI for given account, cached.
     * @internal
     */
    LinkChain.prototype.getAbi = function (account) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var key, rv, getAbi;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        key = String(account);
                        rv = this.abiCache.get(key);
                        if (!!rv) return [3 /*break*/, 2];
                        getAbi = this.pendingAbis.get(key);
                        if (!getAbi) {
                            getAbi = this.client.v1.chain.get_abi(account);
                            this.pendingAbis.set(key, getAbi);
                        }
                        return [4 /*yield*/, getAbi];
                    case 1:
                        rv = (_a.sent()).abi;
                        this.pendingAbis.delete(key);
                        if (rv) {
                            this.abiCache.set(key, rv);
                        }
                        _a.label = 2;
                    case 2: return [2 /*return*/, rv];
                }
            });
        });
    };
    return LinkChain;
}());
/**
 * Anchor Link main class.
 *
 * @example
 *
 * ```ts
 * import AnchorLink from 'anchor-link'
 * import ConsoleTransport from 'anchor-link-console-transport'
 *
 * const link = new AnchorLink({
 *     transport: new ConsoleTransport(),
 *     chains: [
 *         {
 *             chainId: 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906',
 *             nodeUrl: 'https://eos.greymass.com',
 *         },
 *     ],
 * })
 *
 * const result = await link.transact({actions: myActions})
 * ```
 */
var Link = /** @class */ (function () {
    /** Create a new link instance. */
    function Link(options) {
        if (typeof options !== 'object') {
            throw new TypeError('Missing options object');
        }
        if (!options.transport) {
            throw new TypeError('options.transport is required');
        }
        var chains = options.chains || [];
        if (options.chainId && options.client) {
            chains = [{ chainId: options.chainId, nodeUrl: options.client }];
        }
        if (chains.length === 0) {
            throw new TypeError('options.chains is required');
        }
        this.chains = chains.map(function (_a) {
            var chainId = _a.chainId, nodeUrl = _a.nodeUrl;
            if (!chainId) {
                throw new Error('options.chains[].chainId is required');
            }
            if (!nodeUrl) {
                throw new Error('options.chains[].nodeUrl is required');
            }
            return new LinkChain(chainId, nodeUrl);
        });
        if (options.service === undefined || typeof options.service === 'string') {
            this.callbackService = new BuoyCallbackService(options.service || LinkOptions.defaults.service);
        }
        else {
            this.callbackService = options.service;
        }
        this.transport = options.transport;
        if (options.storage !== null) {
            this.storage = options.storage || this.transport.storage;
        }
        this.verifyProofs =
            options.verifyProofs !== undefined
                ? options.verifyProofs
                : LinkOptions.defaults.verifyProofs;
        this.encodeChainIds =
            options.encodeChainIds !== undefined
                ? options.encodeChainIds
                : LinkOptions.defaults.encodeChainIds;
    }
    Object.defineProperty(Link.prototype, "client", {
        /**
         * The APIClient instance for communicating with the node.
         * @note This returns the first APIClient when link is configured with multiple chains.
         */
        get: function () {
            return this.chains[0].client;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Return a [[LinkChain]] object for given chainId or chain reference.
     * @throws If this link instance has no configured chain for given reference.
     * @internal
     */
    Link.prototype.getChain = function (chain) {
        if (chain instanceof LinkChain) {
            return chain;
        }
        if (typeof chain === 'number') {
            var rv_1 = this.chains[chain];
            if (!rv_1) {
                throw new Error("Invalid chain index: " + chain);
            }
            return rv_1;
        }
        var id = eosioSigningRequest.ChainId.from(chain);
        var rv = this.chains.find(function (c) { return c.chainId.equals(id); });
        if (!rv) {
            throw new Error("Unsupported chain: " + id);
        }
        return rv;
    };
    /**
     * Create a SigningRequest instance configured for this link.
     * @internal
     */
    Link.prototype.createRequest = function (args, chain, transport) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var t, request, c, callback;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        t = transport || this.transport;
                        if (!(chain || this.chains.length === 1)) return [3 /*break*/, 2];
                        c = chain || this.chains[0];
                        return [4 /*yield*/, eosioSigningRequest.SigningRequest.create(tslib.__assign(tslib.__assign({}, args), { chainId: c.chainId, broadcast: false }), { abiProvider: c, zlib: zlib__default['default'] })];
                    case 1:
                        request = _a.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, eosioSigningRequest.SigningRequest.create(tslib.__assign(tslib.__assign({}, args), { chainId: null, chainIds: this.encodeChainIds ? this.chains.map(function (c) { return c.chainId; }) : undefined, broadcast: false }), 
                        // abi's will be pulled from the first chain and assumed to be identical on all chains
                        { abiProvider: this.chains[0], zlib: zlib__default['default'] })];
                    case 3:
                        // multi-chain request
                        request = _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!t.prepare) return [3 /*break*/, 6];
                        return [4 /*yield*/, t.prepare(request)];
                    case 5:
                        request = _a.sent();
                        _a.label = 6;
                    case 6:
                        callback = this.callbackService.create();
                        request.setCallback(callback.url, true);
                        return [2 /*return*/, { request: request, callback: callback }];
                }
            });
        });
    };
    /**
     * Send a SigningRequest instance using this link.
     * @internal
     */
    Link.prototype.sendRequest = function (request, callback, chain, transport, broadcast) {
        if (broadcast === void 0) { broadcast = false; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var t, linkUrl, cancel, callbackResponse, payload_1, signer, signatures, c, resolved, cosignerSig, result, signedTx, res, error_1;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        t = transport || this.transport;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 6, , 7]);
                        linkUrl = request.data.callback;
                        if (linkUrl !== callback.url) {
                            throw new Error('Invalid request callback');
                        }
                        if (request.data.flags.broadcast === true || request.data.flags.background === false) {
                            throw new Error('Invalid request flags');
                        }
                        cancel = new Promise(function (resolve, reject) {
                            t.onRequest(request, function (reason) {
                                callback.cancel();
                                if (typeof reason === 'string') {
                                    reject(new CancelError(reason));
                                }
                                else {
                                    reject(reason);
                                }
                            });
                        });
                        return [4 /*yield*/, Promise.race([callback.wait(), cancel])];
                    case 2:
                        callbackResponse = _a.sent();
                        if (typeof callbackResponse.rejected === 'string') {
                            throw new CancelError(callbackResponse.rejected);
                        }
                        payload_1 = callbackResponse;
                        signer = eosio.PermissionLevel.from({
                            actor: payload_1.sa,
                            permission: payload_1.sp,
                        });
                        signatures = Object.keys(payload_1)
                            .filter(function (key) { return key.startsWith('sig') && key !== 'sig0'; })
                            .map(function (key) { return eosio.Signature.from(payload_1[key]); });
                        c = void 0;
                        if (!chain && this.chains.length > 1) {
                            if (!payload_1.cid) {
                                throw new Error('Multi chain response payload must specify resolved chain id (cid)');
                            }
                            c = this.getChain(payload_1.cid);
                        }
                        else {
                            c = chain || this.getChain(0);
                            if (payload_1.cid && !c.chainId.equals(payload_1.cid)) {
                                throw new Error('Got response for wrong chain id');
                            }
                        }
                        return [4 /*yield*/, eosioSigningRequest.ResolvedSigningRequest.fromPayload(payload_1, {
                                zlib: zlib__default['default'],
                                abiProvider: c,
                            })
                            // prepend cosigner signature if present
                        ];
                    case 3:
                        resolved = _a.sent();
                        cosignerSig = resolved.request.getInfoKey('cosig', {
                            type: eosio.Signature,
                            array: true,
                        });
                        if (cosignerSig) {
                            signatures.unshift.apply(signatures, tslib.__spreadArray([], tslib.__read(cosignerSig)));
                        }
                        result = {
                            resolved: resolved,
                            chain: c,
                            transaction: resolved.transaction,
                            resolvedTransaction: resolved.resolvedTransaction,
                            signatures: signatures,
                            payload: payload_1,
                            signer: signer,
                        };
                        if (!broadcast) return [3 /*break*/, 5];
                        signedTx = eosio.SignedTransaction.from(tslib.__assign(tslib.__assign({}, resolved.transaction), { signatures: signatures }));
                        return [4 /*yield*/, c.client.v1.chain.push_transaction(signedTx)];
                    case 4:
                        res = _a.sent();
                        result.processed = res.processed;
                        _a.label = 5;
                    case 5:
                        if (t.onSuccess) {
                            t.onSuccess(request, result);
                        }
                        return [2 /*return*/, result];
                    case 6:
                        error_1 = _a.sent();
                        if (t.onFailure) {
                            t.onFailure(request, error_1);
                        }
                        throw error_1;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sign and optionally broadcast a EOSIO transaction, action or actions.
     *
     * Example:
     *
     * ```ts
     * let result = await myLink.transact({transaction: myTx})
     * ```
     *
     * @param args The action, actions or transaction to use.
     * @param options Options for this transact call.
     * @param transport Transport override, for internal use.
     */
    Link.prototype.transact = function (args, options, transport) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var o, t, c, broadcast, noModify, anyArgs, _a, request, callback, result;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        o = options || {};
                        t = transport || this.transport;
                        c = o.chain !== undefined ? this.getChain(o.chain) : undefined;
                        broadcast = o.broadcast !== false;
                        noModify = o.noModify !== undefined ? o.noModify : !broadcast;
                        // Initialize the loading state of the transport
                        if (t && t.showLoading) {
                            t.showLoading();
                        }
                        anyArgs = args;
                        if (args.actions &&
                            (anyArgs.expiration ||
                                anyArgs.ref_block_num ||
                                anyArgs.ref_block_prefix ||
                                anyArgs.max_net_usage_words ||
                                anyArgs.max_cpu_usage_ms ||
                                anyArgs.delay_sec)) {
                            args = {
                                transaction: tslib.__assign({ expiration: '1970-01-01T00:00:00', ref_block_num: 0, ref_block_prefix: 0, max_net_usage_words: 0, max_cpu_usage_ms: 0, delay_sec: 0 }, anyArgs),
                            };
                        }
                        return [4 /*yield*/, this.createRequest(args, c, t)];
                    case 1:
                        _a = _b.sent(), request = _a.request, callback = _a.callback;
                        if (noModify) {
                            request.setInfoKey('no_modify', true, 'bool');
                        }
                        return [4 /*yield*/, this.sendRequest(request, callback, c, t, broadcast)];
                    case 2:
                        result = _b.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    /**
     * Send an identity request and verify the identity proof if [[LinkOptions.verifyProofs]] is true.
     * @param args.scope The scope of the identity request.
     * @param args.requestPermission Optional request permission if the request is for a specific account or permission.
     * @param args.info Metadata to add to the request.
     * @note This is for advanced use-cases, you probably want to use [[Link.login]] instead.
     */
    Link.prototype.identify = function (args) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, request, callback, res, account, proof, accountPermission, proofValid, perm;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.createRequest({
                            identity: { permission: args.requestPermission, scope: args.scope },
                            info: args.info,
                        })];
                    case 1:
                        _a = _b.sent(), request = _a.request, callback = _a.callback;
                        return [4 /*yield*/, this.sendRequest(request, callback)];
                    case 2:
                        res = _b.sent();
                        if (!res.resolved.request.isIdentity()) {
                            throw new IdentityError('Unexpected response');
                        }
                        proof = res.resolved.getIdentityProof(res.signatures[0]);
                        if (!this.verifyProofs) return [3 /*break*/, 4];
                        return [4 /*yield*/, res.chain.client.v1.chain.get_account(res.signer.actor)];
                    case 3:
                        account = _b.sent();
                        if (!account) {
                            throw new IdentityError("Signature from unknown account: " + proof.signer.actor);
                        }
                        accountPermission = account.permissions.find(function (_a) {
                            var perm_name = _a.perm_name;
                            return proof.signer.permission.equals(perm_name);
                        });
                        if (!accountPermission) {
                            throw new IdentityError(proof.signer.actor + " signed for unknown permission: " + proof.signer.permission);
                        }
                        proofValid = proof.verify(accountPermission.required_auth, account.head_block_time);
                        if (!proofValid) {
                            throw new IdentityError("Invalid identify proof for: " + proof.signer);
                        }
                        _b.label = 4;
                    case 4:
                        if (args.requestPermission) {
                            perm = eosio.PermissionLevel.from(args.requestPermission);
                            if ((!perm.actor.equals(eosioSigningRequest.PlaceholderName) && !perm.actor.equals(proof.signer.actor)) ||
                                (!perm.permission.equals(eosioSigningRequest.PlaceholderPermission) &&
                                    !perm.permission.equals(proof.signer.permission))) {
                                throw new IdentityError("Identity proof singed by " + proof.signer + ", expected: " + formatAuth(perm) + " ");
                            }
                        }
                        return [2 /*return*/, tslib.__assign(tslib.__assign({}, res), { account: account,
                                proof: proof })];
                }
            });
        });
    };
    /**
     * Login and create a persistent session.
     * @param identifier The session identifier, an EOSIO name (`[a-z1-5]{1,12}`).
     *                   Should be set to the contract account if applicable.
     */
    Link.prototype.login = function (identifier) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var privateKey, requestKey, createInfo, res, metadata, parsed, _a, _b, key, signerKey, session;
            var e_1, _c;
            return tslib.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        privateKey = eosio.PrivateKey.generate('K1');
                        requestKey = privateKey.toPublic();
                        createInfo = LinkCreate.from({
                            session_name: identifier,
                            request_key: requestKey,
                            user_agent: this.getUserAgent(),
                        });
                        return [4 /*yield*/, this.identify({
                                scope: identifier,
                                info: {
                                    link: createInfo,
                                    scope: identifier,
                                },
                            })];
                    case 1:
                        res = _d.sent();
                        metadata = {
                            // backwards compat, can be removed next major release
                            sameDevice: res.resolved.request.getRawInfo()['return_path'] !== undefined,
                        };
                        // append extra metadata from the signer
                        if (res.payload.link_meta) {
                            try {
                                parsed = JSON.parse(res.payload.link_meta);
                                try {
                                    for (_a = tslib.__values(Object.keys(parsed)), _b = _a.next(); !_b.done; _b = _a.next()) {
                                        key = _b.value;
                                        // normalize key names to camelCase
                                        metadata[snakeToCamel(key)] = parsed[key];
                                    }
                                }
                                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                                finally {
                                    try {
                                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                                    }
                                    finally { if (e_1) throw e_1.error; }
                                }
                            }
                            catch (error) {
                                // eslint-disable-next-line no-console
                                console.warn('Unable to parse link metadata', error, res.payload.link_meta);
                            }
                        }
                        signerKey = res.proof.recover();
                        if (res.payload.link_ch && res.payload.link_key && res.payload.link_name) {
                            session = new LinkChannelSession(this, {
                                identifier: identifier,
                                chainId: res.chain.chainId,
                                auth: res.signer,
                                publicKey: signerKey,
                                channel: {
                                    url: res.payload.link_ch,
                                    key: res.payload.link_key,
                                    name: res.payload.link_name,
                                },
                                requestKey: privateKey,
                            }, metadata);
                        }
                        else {
                            session = new LinkFallbackSession(this, {
                                identifier: identifier,
                                chainId: res.chain.chainId,
                                auth: res.signer,
                                publicKey: signerKey,
                            }, metadata);
                        }
                        if (!this.storage) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.storeSession(identifier, session)];
                    case 2:
                        _d.sent();
                        _d.label = 3;
                    case 3: return [2 /*return*/, tslib.__assign(tslib.__assign({}, res), { session: session })];
                }
            });
        });
    };
    /**
     * Restore previous session, use [[login]] to create a new session.
     * @param identifier The session identifier, must be same as what was used when creating the session with [[login]].
     * @param auth A specific session auth to restore, if omitted the most recently used session will be restored.
     * @param chainId If given function will only consider that specific chain when restoring session.
     * @returns A [[LinkSession]] instance or null if no session can be found.
     * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session data.
     **/
    Link.prototype.restoreSession = function (identifier, auth, chainId) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var key, list, id_1, latest, data, sessionData, session;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.storage) {
                            throw new Error('Unable to restore session: No storage adapter configured');
                        }
                        if (!(auth && chainId)) return [3 /*break*/, 1];
                        // both auth and chain id given, we can look up on specific key
                        key = this.sessionKey(identifier, formatAuth(eosio.PermissionLevel.from(auth)), String(eosioSigningRequest.ChainId.from(chainId)));
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, this.listSessions(identifier)];
                    case 2:
                        list = _a.sent();
                        if (auth) {
                            list = list.filter(function (item) { return item.auth.equals(auth); });
                        }
                        if (chainId) {
                            id_1 = eosioSigningRequest.ChainId.from(chainId);
                            list = list.filter(function (item) { return item.chainId.equals(id_1); });
                        }
                        latest = list[0];
                        if (!latest) {
                            return [2 /*return*/, null];
                        }
                        key = this.sessionKey(identifier, formatAuth(latest.auth), String(latest.chainId));
                        _a.label = 3;
                    case 3: return [4 /*yield*/, this.storage.read(key)];
                    case 4:
                        data = _a.sent();
                        if (!data) {
                            return [2 /*return*/, null];
                        }
                        try {
                            sessionData = JSON.parse(data);
                        }
                        catch (error) {
                            throw new Error("Unable to restore session: Stored JSON invalid (" + (error.message || String(error)) + ")");
                        }
                        session = LinkSession.restore(this, sessionData);
                        if (!(auth || chainId)) return [3 /*break*/, 6];
                        // update latest used
                        return [4 /*yield*/, this.touchSession(identifier, session.auth, session.chainId)];
                    case 5:
                        // update latest used
                        _a.sent();
                        _a.label = 6;
                    case 6: return [2 /*return*/, session];
                }
            });
        });
    };
    /**
     * List stored session auths for given identifier.
     * The most recently used session is at the top (index 0).
     * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session list.
     **/
    Link.prototype.listSessions = function (identifier) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var key, list, _a, _b, error_2;
            return tslib.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!this.storage) {
                            throw new Error('Unable to list sessions: No storage adapter configured');
                        }
                        key = this.sessionKey(identifier, 'list');
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 3, , 4]);
                        _b = (_a = JSON).parse;
                        return [4 /*yield*/, this.storage.read(key)];
                    case 2:
                        list = _b.apply(_a, [(_c.sent()) || '[]']);
                        return [3 /*break*/, 4];
                    case 3:
                        error_2 = _c.sent();
                        throw new Error("Unable to list sessions: " + (error_2.message || String(error_2)));
                    case 4: return [2 /*return*/, list.map(function (_a) {
                            var auth = _a.auth, chainId = _a.chainId;
                            return ({
                                auth: eosio.PermissionLevel.from(auth),
                                chainId: eosioSigningRequest.ChainId.from(chainId),
                            });
                        })];
                }
            });
        });
    };
    /**
     * Remove stored session for given identifier and auth.
     * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.
     */
    Link.prototype.removeSession = function (identifier, auth, chainId) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var key;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.storage) {
                            throw new Error('Unable to remove session: No storage adapter configured');
                        }
                        key = this.sessionKey(identifier, formatAuth(auth), String(chainId));
                        return [4 /*yield*/, this.storage.remove(key)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.touchSession(identifier, auth, chainId, true)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Remove all stored sessions for given identifier.
     * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.
     */
    Link.prototype.clearSessions = function (identifier) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _a, _b, _c, auth, chainId, e_2_1;
            var e_2, _d;
            return tslib.__generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!this.storage) {
                            throw new Error('Unable to clear sessions: No storage adapter configured');
                        }
                        _e.label = 1;
                    case 1:
                        _e.trys.push([1, 7, 8, 9]);
                        return [4 /*yield*/, this.listSessions(identifier)];
                    case 2:
                        _a = tslib.__values.apply(void 0, [_e.sent()]), _b = _a.next();
                        _e.label = 3;
                    case 3:
                        if (!!_b.done) return [3 /*break*/, 6];
                        _c = _b.value, auth = _c.auth, chainId = _c.chainId;
                        return [4 /*yield*/, this.removeSession(identifier, auth, chainId)];
                    case 4:
                        _e.sent();
                        _e.label = 5;
                    case 5:
                        _b = _a.next();
                        return [3 /*break*/, 3];
                    case 6: return [3 /*break*/, 9];
                    case 7:
                        e_2_1 = _e.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 9];
                    case 8:
                        try {
                            if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                        }
                        finally { if (e_2) throw e_2.error; }
                        return [7 /*endfinally*/];
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Create an eosjs compatible signature provider using this link.
     * @param availableKeys Keys the created provider will claim to be able to sign for.
     * @param chain Chain to use when configured with multiple chains.
     * @param transport (internal) Transport override for this call.
     * @note We don't know what keys are available so those have to be provided,
     *       to avoid this use [[LinkSession.makeSignatureProvider]] instead. Sessions can be created with [[Link.login]].
     */
    Link.prototype.makeSignatureProvider = function (availableKeys, chain, transport) {
        var _this = this;
        return {
            getAvailableKeys: function () { return tslib.__awaiter(_this, void 0, void 0, function () { return tslib.__generator(this, function (_a) {
                return [2 /*return*/, availableKeys];
            }); }); },
            sign: function (args) { return tslib.__awaiter(_this, void 0, void 0, function () {
                var t, c, request, callback, _a, transaction, signatures, serializedTransaction;
                return tslib.__generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            t = transport || this.transport;
                            c = chain ? this.getChain(chain) : this.chains[0];
                            request = eosioSigningRequest.SigningRequest.fromTransaction(args.chainId, args.serializedTransaction, { abiProvider: c, zlib: zlib__default['default'] });
                            callback = this.callbackService.create();
                            request.setCallback(callback.url, true);
                            request.setBroadcast(false);
                            if (!t.prepare) return [3 /*break*/, 2];
                            return [4 /*yield*/, t.prepare(request)];
                        case 1:
                            request = _b.sent();
                            _b.label = 2;
                        case 2: return [4 /*yield*/, this.sendRequest(request, callback, c, t)];
                        case 3:
                            _a = _b.sent(), transaction = _a.transaction, signatures = _a.signatures;
                            serializedTransaction = eosio.Serializer.encode({ object: transaction });
                            return [2 /*return*/, tslib.__assign(tslib.__assign({}, args), { serializedTransaction: serializedTransaction,
                                    signatures: signatures })];
                    }
                });
            }); },
        };
    };
    /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */
    Link.prototype.touchSession = function (identifier, auth, chainId, remove) {
        if (remove === void 0) { remove = false; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var list, existing, key;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.listSessions(identifier)];
                    case 1:
                        list = _a.sent();
                        existing = list.findIndex(function (item) { return item.auth.equals(auth) && item.chainId.equals(chainId); });
                        if (existing >= 0) {
                            list.splice(existing, 1);
                        }
                        if (remove === false) {
                            list.unshift({ auth: auth, chainId: chainId });
                        }
                        key = this.sessionKey(identifier, 'list');
                        return [4 /*yield*/, this.storage.write(key, JSON.stringify(list))];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */
    Link.prototype.storeSession = function (identifier, session) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var key, data;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        key = this.sessionKey(identifier, formatAuth(session.auth), String(session.chainId));
                        data = JSON.stringify(session.serialize());
                        return [4 /*yield*/, this.storage.write(key, data)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.touchSession(identifier, session.auth, session.chainId)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /** Session storage key for identifier and suffix. */
    Link.prototype.sessionKey = function (identifier) {
        var suffix = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            suffix[_i - 1] = arguments[_i];
        }
        return tslib.__spreadArray([String(eosio.Name.from(identifier))], tslib.__read(suffix)).join('-');
    };
    /** Return user agent of this link. */
    Link.prototype.getUserAgent = function () {
        var rv = "AnchorLink/" + Link.version;
        if (this.transport.userAgent) {
            rv += ' ' + this.transport.userAgent();
        }
        return rv;
    };
    /** Package version. */
    Link.version = '3.2.2'; // eslint-disable-line @typescript-eslint/no-inferrable-types
    return Link;
}());
/**
 * Format a EOSIO permission level in the format `actor@permission` taking placeholders into consideration.
 * @internal
 */
function formatAuth(auth) {
    var a = eosio.PermissionLevel.from(auth);
    var actor = a.actor.equals(eosioSigningRequest.PlaceholderName) ? '<any>' : String(a.actor);
    var permission;
    if (a.permission.equals(eosioSigningRequest.PlaceholderName) || a.permission.equals(eosioSigningRequest.PlaceholderPermission)) {
        permission = '<any>';
    }
    else {
        permission = String(a.permission);
    }
    return actor + "@" + permission;
}
/**
 * Return PascalCase version of snake_case string.
 * @internal
 */
function snakeToPascal(name) {
    return name
        .split('_')
        .map(function (v) { return (v[0] ? v[0].toUpperCase() : '_') + v.slice(1); })
        .join('');
}
/**
 * Return camelCase version of snake_case string.
 * @internal
 */
function snakeToCamel(name) {
    var pascal = snakeToPascal(name);
    return pascal[0].toLowerCase() + pascal.slice(1);
}

// export library

var pkg = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), eosioSigningRequest__namespace, eosio__namespace, {
    'default': Link,
    IdentityProof: eosioSigningRequest.IdentityProof,
    ChainId: eosioSigningRequest.ChainId,
    ChainName: eosioSigningRequest.ChainName,
    LinkChain: LinkChain,
    Link: Link,
    LinkSession: LinkSession,
    LinkChannelSession: LinkChannelSession,
    LinkFallbackSession: LinkFallbackSession,
    CancelError: CancelError,
    IdentityError: IdentityError,
    SessionError: SessionError
}));

var e_1, _a;
var AnchorLink = Link;
try {
    for (var _b = tslib.__values(Object.keys(pkg)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var key = _c.value;
        if (key === 'default')
            continue;
        AnchorLink[key] = pkg[key];
    }
}
catch (e_1_1) { e_1 = { error: e_1_1 }; }
finally {
    try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
    }
    finally { if (e_1) throw e_1.error; }
}

module.exports = AnchorLink;
//# sourceMappingURL=anchor-link.js.map
